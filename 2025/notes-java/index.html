<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://images.kisechan.space/icon.png"><link rel="icon" href="https://images.kisechan.space/icon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#004e66"><meta name="author" content="Kisechan"><meta name="keywords" content=""><meta name="description" content="速通的倒数第二门，唉这学期怎么都在速通，活得太没意思了。 祝我好运。  Java 基础 概述 Java 是一种“简单、面向对象、分布式、解释型、健壮、安全、体系结构中立、可移植、高性能、多线程和动态”的编程语言。  简单性  去掉了指针，取消多重继承和运算符重载。 自动内存分配与回收机制。   纯粹的面向对象 分布式，面向网络 健壮性  内存自动管理。 异常处理机制。   安全性  直接去掉指针"><meta property="og:type" content="article"><meta property="og:title" content="Java 程序设计"><meta property="og:url" content="https://blog.kisechan.space/2025/notes-java/index.html"><meta property="og:site_name" content="Kisechan&#39;s Blog"><meta property="og:description" content="速通的倒数第二门，唉这学期怎么都在速通，活得太没意思了。 祝我好运。  Java 基础 概述 Java 是一种“简单、面向对象、分布式、解释型、健壮、安全、体系结构中立、可移植、高性能、多线程和动态”的编程语言。  简单性  去掉了指针，取消多重继承和运算符重载。 自动内存分配与回收机制。   纯粹的面向对象 分布式，面向网络 健壮性  内存自动管理。 异常处理机制。   安全性  直接去掉指针"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.kisechan.space/6a0828d64cd102fd673eda5f3f2fdb30_720.jpg"><meta property="article:published_time" content="2025-06-24T12:52:38.000Z"><meta property="article:modified_time" content="2025-06-25T11:13:54.947Z"><meta property="article:author" content="Kisechan"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://images.kisechan.space/6a0828d64cd102fd673eda5f3f2fdb30_720.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><title>Java 程序设计 - Kisechan&#39;s Blog</title><link rel="stylesheet" type="text/css" href="/css/loading.css"><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4890189_5ms3yf4n747.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"blog.kisechan.space",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),n=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3837;break}}),i=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+6136;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="Kisechan's Blog" type="application/atom+xml"></head><body><div><div class="real_mask" style="background-color:rgba(0,0,0,.3);width:100%;height:100%;position:fixed;z-index:-777"></div><div id="banner_video_insert"></div><div id="vvd_banner_img"></div></div><div id="banner"></div><div id="loader-box"><div class="loader-wrapper"><div class="loader"></div><div class="loader-text"><div>L</div><div>O</div><div>A</div><div>D</div><div>I</div><div>N</div><div>G</div><div></div><div></div><div></div></div></div><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loader-box").remove()};window.addEventListener("load",endLoading)</script></div><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KISECHAN</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/" target="_self"><i class="iconfont icon-Homehomepagemenu"></i> <span>主站</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-newstextarticle"></i> <span>文章</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-categories"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user"></i> <span>个人</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.kisechan.space/" target="_self"><i class="iconfont icon-info-fill"></i> <span>关于</span> </a><a class="dropdown-item" href="/playlist/" target="_self"><i class="iconfont icon-music"></i> <span>歌单</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/Kisechan.github.io" target="_self"><i class="iconfont icon-git"></i> <span>仓库</span> </a><a class="dropdown-item" href="/atom.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS 订阅</span></a></div></li><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/tools/" target="_self"><i class="iconfont icon-tool-fill"></i> <span>工具</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/links" target="_self"><i class="iconfont icon-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://images.kisechan.space/202502042159748.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Java 程序设计</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kisechan </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-06-24 20:52" pubdate>2025年6月24日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.3k 字 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div><script type="text/javascript" src="/vvd_js/jquery.js"></script><div class="banner" id="banner"><div class="full-bg-img"></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="课程笔记" id="heading-311a46cfdaa3afda544e9285644f70d7" role="tab" data-toggle="collapse" href="#collapse-311a46cfdaa3afda544e9285644f70d7" aria-expanded="true">课程笔记 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-311a46cfdaa3afda544e9285644f70d7" role="tabpanel" aria-labelledby="heading-311a46cfdaa3afda544e9285644f70d7"><div class="category-post-list"><a href="/2024/oop/" title="面向对象程序设计课程笔记" class="list-group-item list-group-item-action"><span class="category-post">面向对象程序设计课程笔记</span> </a><a href="/2024/linux-note/" title="Linux课程笔记" class="list-group-item list-group-item-action"><span class="category-post">Linux课程笔记</span> </a><a href="/2024/ds/" title="数据结构课程板子合集&amp;笔记" class="list-group-item list-group-item-action"><span class="category-post">数据结构课程板子合集&amp;笔记</span> </a><a href="/2025/notes-algorithm-analysis/" title="算法设计与分析 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">算法设计与分析 课程笔记</span> </a><a href="/2025/notes-database-1/" title="数据库原理 课程笔记 (1) 数据库、关系代数和 SQL" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (1) 数据库、关系代数和 SQL</span> </a><a href="/2025/notes-database-2/" title="数据库原理 课程笔记 (2) E-R 模型和关系模式" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (2) E-R 模型和关系模式</span> </a><a href="/2025/notes-database-3/" title="数据库原理 课程笔记 (3) 存储、索引、事务和并发" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (3) 存储、索引、事务和并发</span> </a><a href="/2025/notes-database-4/" title="数据库原理 课程笔记 (4) 杂项和题目整理" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (4) 杂项和题目整理</span> </a><a href="/2025/notes-os/" title="操作系统复习" class="list-group-item list-group-item-action"><span class="category-post">操作系统复习</span> </a><a href="/2025/notes-ptms/" title="概率论与数理统计" class="list-group-item list-group-item-action"><span class="category-post">概率论与数理统计</span> </a><a href="/2025/notes-java/" title="Java 程序设计" class="list-group-item list-group-item-action active"><span class="category-post">Java 程序设计</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java 程序设计</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2025-06-25T19:13:54+08:00</p><div class="markdown-body"><blockquote><p>速通的倒数第二门，唉这学期怎么都在速通，活得太没意思了。</p><p>祝我好运。</p></blockquote><h2 id="Java-基础">Java 基础</h2><h3 id="概述">概述</h3><p>Java 是一种“<strong>简单、面向对象、分布式、解释型、健壮、安全、体系结构中立、可移植、高性能、多线程和动态</strong>”的编程语言。</p><ul><li><strong>简单性</strong><ul><li>去掉了指针，取消多重继承和运算符重载。</li><li>自动内存分配与回收机制。</li></ul></li><li><strong>纯粹的面向对象</strong></li><li><strong>分布式</strong>，面向网络</li><li><strong>健壮性</strong><ul><li>内存自动管理。</li><li>异常处理机制。</li></ul></li><li><strong>安全性</strong><ul><li>直接去掉指针。</li><li>所有程序和数据都在沙箱中。</li></ul></li><li><strong>体系结构中立</strong>，平台无关<ul><li>只要安装了 <strong>Java 虚拟机</strong> (JVM)，代码就可以在随处运行。</li></ul></li><li><strong>可移植性</strong></li><li><strong>解释执行</strong><ul><li>Java 程序被编译成 JVM 字节码，不依赖机器，可运行在任意安装了 Java 解释器的机器上。</li></ul></li><li><strong>高性能</strong></li><li><strong>多线程</strong></li><li><strong>动态性</strong><ul><li>在类库中可以自由地加入新的方法和实例变量而不会影响用户程序的执行。</li></ul></li></ul><h3 id="Java-和-C">Java 和 C++</h3><ol><li>Java 语言中<strong>不允许在类之外定义全局变量</strong>，而只能通过在类中定义静态变量来实现。</li><li>Java 语言中<strong>没有 <code>goto</code> 语句</strong>。</li><li>Java 语言中<strong>没有指针型变量</strong>。</li><li><strong>内存管理</strong>实现了自动化。</li><li>Java 语言对于<strong>不同的数据类型定义统一的规格</strong>，保证了平台无关性。</li><li>Java 语言中<strong>不允许像 C 和 C++ 中那样任意进行类型转换</strong>。</li><li>Java 语言中<strong>无头文件</strong>。</li><li>Java 语言中<strong>无结构体和联合</strong>。</li><li>Java 语言中<strong>无预处理和宏定义</strong>。</li></ol><hr><p>Java 语言特色：</p><ul><li><strong>类不支持多重继承</strong></li><li><strong><code>Abstract</code>/<code>Final</code> 类</strong></li><li><strong>接口</strong></li><li><strong>自动内存回收</strong></li><li><strong>多线程</strong></li></ul><h3 id="标识符使用惯例">标识符使用惯例</h3><ul><li><strong>类和接口</strong> <code>SimpleApp</code><ul><li>类名和接口名通常用名词，且每个单词的首字母大写。</li></ul></li><li><strong>方法</strong> <code>processResult</code><ul><li>方法名用动词开头的单词序列，首单词全部小写，后面的每个单词首<br>字母大写。</li></ul></li><li><strong>常量</strong> <code>PI</code><ul><li>常量名全部用大写字母。</li></ul></li><li><strong>变量</strong> <code>outputResult</code><ul><li>所有的对象实例名和全局变量名都使用首单词全部小写，后面的每个<br>单词首字母大写的格式。</li></ul></li></ul><h2 id="对象">对象</h2><h3 id="访问控制">访问控制</h3><table><thead><tr><th style="text-align:center">控制符</th><th style="text-align:center">同一个类中</th><th style="text-align:center">同一个包 中</th><th style="text-align:center">不同包中的子类</th><th style="text-align:center">不同包中的非子类</th></tr></thead><tbody><tr><td style="text-align:center"><code>public</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center"><code>protected</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>default</code> （什么都不写）</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>private</code></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="接口和类">接口和类</h3><p>Java 中所有的类都继承自 <code>java.lang.Object</code>。</p><table><thead><tr><th style="text-align:center">基本方法</th><th style="text-align:center">作用</th><th style="text-align:center">是否常重写</th></tr></thead><tbody><tr><td style="text-align:center"><code>toString()</code></td><td style="text-align:center">返回对象的字符串表示</td><td style="text-align:center">✅ 常重写</td></tr><tr><td style="text-align:center"><code>equals(Object obj)</code></td><td style="text-align:center">判断两个对象是否“相等”</td><td style="text-align:center">✅ 常重写</td></tr><tr><td style="text-align:center"><code>hashCode()</code></td><td style="text-align:center">返回对象的哈希值</td><td style="text-align:center">✅ 常和 <code>equals</code> 一起重写</td></tr><tr><td style="text-align:center"><code>getClass()</code></td><td style="text-align:center">返回运行时类对象</td><td style="text-align:center">❌ 一般不重写</td></tr><tr><td style="text-align:center"><code>clone()</code></td><td style="text-align:center">对对象进行浅拷贝</td><td style="text-align:center">❌ 少用，需实现 <code>Cloneable</code> 接口</td></tr><tr><td style="text-align:center"><code>finalize()</code></td><td style="text-align:center">垃圾回收前调用（不推荐使用）</td><td style="text-align:center">❌ 废弃</td></tr><tr><td style="text-align:center"><code>wait()</code></td><td style="text-align:center">线程等待（需在同步块中）</td><td style="text-align:center">❌ 通常不重写</td></tr><tr><td style="text-align:center"><code>notify()</code></td><td style="text-align:center">唤醒等待的线程</td><td style="text-align:center">❌ 通常不重写</td></tr><tr><td style="text-align:center"><code>notifyAll()</code></td><td style="text-align:center">唤醒所有等待的线程</td><td style="text-align:center">❌ 通常不重写</td></tr></tbody></table><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">接口（interface）</th><th style="text-align:center">类（class）</th></tr></thead><tbody><tr><td style="text-align:center">语义</td><td style="text-align:center">定义行为规范，类似“能力”</td><td style="text-align:center">定义对象的属性和行为</td></tr><tr><td style="text-align:center">方法</td><td style="text-align:center">默认是 <code>public abstract</code>（除非是 <code>default</code>/<code>static</code>/<code>private</code>）</td><td style="text-align:center">可包含具体实现的方法</td></tr><tr><td style="text-align:center">字段</td><td style="text-align:center">默认是 <code>public static final</code>（常量）</td><td style="text-align:center">可定义变量，有访问权限控制</td></tr><tr><td style="text-align:center">继承</td><td style="text-align:center">可以多继承多个接口</td><td style="text-align:center">只能单继承一个类</td></tr><tr><td style="text-align:center">实现方式</td><td style="text-align:center">类用 <code>implements</code> 来实现接口</td><td style="text-align:center">类用 <code>extends</code> 继承另一个类</td></tr><tr><td style="text-align:center">实例化</td><td style="text-align:center">无法直接实例化</td><td style="text-align:center">可以实例化（如果不是 <code>abstract</code>）</td></tr></tbody></table><h2 id="图形化界面">图形化界面</h2><h3 id="Swing">Swing</h3><ul><li><strong>AWT (Abstract Window Toolkit)</strong>:<ul><li>提供一套与本地图形界面交互的接口。</li><li>依赖本地方法实现功能，因此 AWT 控件被称为<strong>重量级控件</strong>。</li></ul></li><li><strong>Swing</strong>:<ul><li>在 AWT 基础上构建的新图形界面系统。</li><li>提供 AWT 的所有功能，并进行大幅扩充。</li><li>没有使用本地方法实现图形功能，因此 Swing 控件被称为<strong>轻量级控件</strong>。</li><li>随着 Java2 的发布，Swing 逐渐替代了 AWT，本章主要介绍 Swing 组件。</li><li>Swing 组件类以字母 “J” 开头，除了与 AWT 类似的组件外，还增加了丰富的<strong>高层组件</strong>。</li><li>Java 语言采用<strong>向容器中添加组件</strong>的方式构建 GUI。通常使用<strong>顶级容器</strong>作为所有组件的承载物，可以向其中添加包括容器在内的各种组件，并合理安排布局。容器之间允许嵌套。</li></ul></li></ul><hr><p>GUI 组件从使用上可分为三大类：</p><ol><li><strong>容器类</strong> (Container):<ul><li>用于包含其他组件的容器。</li><li>例如： <code>JFrame</code> (顶层容器), <code>JApplet</code>, <code>JDialog</code>, <code>JPanel</code> (普通容器)。</li></ul></li><li><strong>控件类</strong> (Control):<ul><li>都是 <code>JComponent</code> 类（抽象类）的子类。</li><li>例如： <code>JButton</code>, <code>JTextField</code>, <code>JTextArea</code>, <code>JComboBox</code>, <code>JList</code>, <code>JRadioButton</code>, <code>JMenu</code>。</li></ul></li><li><strong>辅助类</strong> (Auxiliary Class):<ul><li>描述和绘制容器类和组件类属性和放置的类。</li><li>例如： <code>Graphics</code>, <code>Color</code>, <code>Font</code>, <code>FontMetrics</code>, <code>Dimension</code>, <code>LayoutManager</code>。</li></ul></li></ol><h3 id="常用组件">常用组件</h3><h4 id="JFrame-类"><code>JFrame</code> 类</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>java.awt.Window</code> -&gt; <code>java.awt.Frame</code> -&gt; <code>javax.swing.JFrame</code>。</li><li><strong>构造方法</strong>: <code>public JFrame()</code>, <code>public JFrame(String title)</code>。</li><li><strong>成员方法</strong>:<ul><li><code>setSize()</code>: 设置<strong>窗口大小</strong>。</li><li><code>setVisible()</code>: 设置<strong>窗口可见性</strong>。</li><li><code>setLocation()</code>: 设置<strong>窗口位置</strong>。</li><li><code>setDefaultCloseOperation(int operation)</code>: 设置<strong>窗口关闭时的动作</strong>。<ul><li>参数 <code>operation</code> 有四种取值：<code>DO_NOTHING_ON_CLOSE</code>, <code>HIDE_ON_CLOSE</code>, <code>DISPOSE_ON_CLOSE</code>, <code>EXIT_ON_CLOSE</code>。</li></ul></li><li><code>getContentPane()</code>: 获取<strong>内容面板</strong>。</li><li><code>setTitle()</code>: 设置<strong>窗口标题</strong>。</li></ul></li></ul><h4 id="JLabel-类"><code>JLabel</code> 类</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>javax.swing.JComponent</code> -&gt; <code>javax.swing.JLabel</code>。</li><li><strong>构造方法</strong>: 支持多种构造方法，如只带文本、只带图标、或同时带文本和图标及对齐方式。</li><li><strong>对齐属性</strong>: <code>SwingConstants.LEFT</code>, <code>SwingConstants.CENTER</code>, <code>SwingConstants.RIGHT</code>, <code>SwingConstants.BOTTOM</code>。</li><li><strong>成员方法</strong>: <code>setText()</code>, <code>setIcon()</code>, <code>getText()</code>, <code>setHorizontalTextPosition()</code>, <code>setVerticalTextPosition()</code>。</li></ul><h4 id="JPanel-类"><code>JPanel</code> 类</h4><ul><li><strong>面板容器</strong>: <code>JPanel</code> 是分组放置组件的、位于框架更低一级的普通容器。</li><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>javax.swing.JComponent</code> -&gt; <code>javax.swing.JPanel</code>。</li><li><strong>构造方法</strong>: <code>public JPanel()</code>。</li><li><strong>成员方法</strong>: <code>paintComponents(Graphics g)</code>, <code>add(Component comp)</code>。</li></ul><h4 id="JButton-类"><code>JButton</code> 类</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>javax.swing.JComponent</code> -&gt; <code>javax.swing.AbstractButton</code> -&gt; <code>javax.swing.JButton</code>。</li><li><strong>构造方法</strong>: 支持多种构造方法，如无文本、带文本、带图标、或同时带文本和图标。</li><li><strong>成员方法</strong>: <code>setText()</code>, <code>setIcon()</code>, <code>setBounds()</code>, <code>addActionListener(ActionListener l)</code>。</li></ul><h4 id="文本框-JTextField">文本框 <code>JTextField</code></h4><ul><li><strong>构造方法</strong>: <code>public JTextField()</code>, <code>public JTextField(String text)</code>, <code>public JTextField(int columns)</code>, <code>public JTextField(String text, int columns)</code>。</li><li><strong>成员方法</strong>: <code>addActionListener(ActionListener l)</code>, <code>setColumns(int columns)</code>, <code>setText(String text)</code>。</li></ul><h4 id="其他常用组件">其他常用组件</h4><ul><li><strong><code>JTextArea</code></strong>: 提供多行文本编辑功能。</li><li><strong><code>JCheckBox</code></strong>: 复选框。</li><li><strong><code>JRadioButton</code></strong>: 单选按钮，常与 <code>ButtonGroup</code> 配合使用。</li><li><strong><code>JComboBox</code></strong>: 组合框（下拉列表）。</li><li><strong><code>JDialog</code></strong>: 对话框，可设置模式（应用程序只能响应对话框内事件）或非模式（可响应其他窗口事件）。</li><li><strong><code>JFileChooser</code></strong>: 文件对话框，用于打开或存储文件。</li><li><strong><code>JMenuBar</code>, <code>JMenu</code>, <code>JMenuItem</code></strong>: 用于创建菜单栏、菜单和菜单项。</li></ul><h3 id="布局管理">布局管理</h3><p>当向窗口中放置组件时，需要指定组件放置策略。</p><p>Java 中有两种定位组件的方法：</p><ul><li><p><strong>硬编码</strong>: 屏幕绝对位置，与机器相关。</p></li><li><p><strong>软编码</strong>: 布局管理器，与机器无关。</p><ul><li><p>Java 布局管理器类存在于</p><p><code>java.awt</code> 包中。</p></li><li><p>在 <code>Container</code> 中有一个 <code>setLayout()</code> 方法，可以选择不同的布局方式。</p></li></ul></li></ul><h4 id="FlowLayout-（顺序布局）"><code>FlowLayout</code> （顺序布局）</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.FlowLayout</code>。</li><li><strong>构造方法</strong>: <code>public FlowLayout()</code>, <code>public FlowLayout(int align)</code>, <code>public FlowLayout(int align, int hGap, int vGap)</code>。</li><li><strong>成员属性</strong>: <code>LEFT</code>, <code>CENTER</code>, <code>RIGHT</code>。</li><li><strong>特点</strong>: 将组件从左到右放置，直到占满上方空间，再向下移动一行继续放置。所有组件将被压缩到它们的最小尺寸，按“合适”的大小呈现。</li></ul><h4 id="BorderLayout-（边界布局）"><code>BorderLayout</code> （边界布局）</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.BorderLayout</code>。</li><li><strong>构造方法</strong>: <code>public BorderLayout()</code>, <code>public BorderLayout(int hGap, int vGap)</code>。</li><li><strong>成员属性</strong>: <code>NORTH</code>, <code>SOUTH</code>, <code>EAST</code>, <code>WEST</code>, <code>CENTER</code>。</li><li><strong>特点</strong>: 将组件分置五个区域：北、南、东、西、中。<code>BorderLayout</code> 是 <code>JFrame</code> 的默认布局。</li><li>使用 <code>add()</code> 方法时，第一个参数可以指定区域，如 <code>BorderLayout.NORTH</code>。 未指定区域的组件将放置在中央并拉伸。</li></ul><h4 id="GridLayout-网格布局">GridLayout (网格布局)</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.GridLayout</code>。</li><li><strong>构造方法</strong>: <code>public GridLayout()</code>, <code>public GridLayout(int rows, int columns)</code>, <code>public GridLayout(int rows, int columns, int hGap, int vGap)</code>。</li><li><strong>特点</strong>: 在网格里从左到右、从上到下布局。确定行列数后，组件将以相同的长宽比排列。</li></ul><h3 id="事件处理">事件处理</h3><h4 id="事件处理机制">事件处理机制</h4><p>要让图形界面接收用户的操作，必须为组件添加事件处理机制。</p><p>事件处理主要涉及三类对象：</p><ol><li><p><strong>Event (事件)</strong>: 用户对界面操作在 Java 语言上的描述，以类的形式出现。例如键盘操作对应的事件类是 <code>KeyEvent</code>。</p></li><li><p><strong>Event Source (事件源)</strong>: 事件发生的场所，通常是各个组件，例如按钮 <code>JButton</code>。</p></li><li><p><strong>Event Handler (事件处理者)</strong>: 接收事件对象并对其进行处理的对象，也称为事件监听器 (<code>Listener</code>)。</p><hr></li></ol><p><strong>事件响应过程</strong>:</p><ol><li>组件（事件源）触发相应类型的事件。</li><li>生成事件对象。</li><li>把事件对象传入事件处理器。</li><li>事件由相应类型的 <code>Listener</code>（事件监听器）接收并处理。<ul><li><strong>实现事件监听器的方式</strong>:<ul><li><strong>内部类实现监听器方式</strong>：定义一个独立的内部类实现监听器接口，并在组件中注册该内部类的对象。</li><li><strong>匿名内部类实现监听器方式</strong>：直接在 <code>addActionListener()</code> 方法中定义并实例化一个匿名内部类来实现监听器接口。</li><li><strong>直接实现监听器方式</strong>：主类直接实现监听器接口，然后将 <code>this</code> 关键字作为监听器对象注册到组件中。</li></ul></li></ul></li></ol><h4 id="事件类与事件监听接口">事件类与事件监听接口</h4><ul><li>Java 使用 <code>AWTEvent</code> 类表示事件，其继承关系为 <code>java.lang.Object</code> -&gt; <code>java.util.EventObject</code> -&gt; <code>java.awt.AWTEvent</code>。</li><li>各种事件类别对应不同的监听器接口和方法：<ul><li><code>ActionEvent</code>: <code>ActionListener</code> ( <code>actionPerformed</code> )</li><li><code>ItemEvent</code>: <code>ItemListener</code> ( <code>itemStateChanged</code> )</li><li><code>MouseEvent</code>: <code>MouseListener</code> ( <code>mousePressed</code>, <code>mouseReleased</code>, <code>mouseEntered</code>, <code>mouseExited</code>, <code>mouseClicked</code> )</li><li><code>MouseEvent</code> (移动): <code>MouseMotionListener</code> ( <code>mouseDragged</code>, <code>mouseMoved</code> )</li><li><code>KeyEvent</code>: <code>KeyListener</code> ( <code>keyPressed</code>, <code>keyReleased</code>, <code>keyTyped</code> )</li><li><code>FocusEvent</code>: <code>FocusListener</code> ( <code>focusGained</code>, <code>focusLost</code> )</li><li><code>AdjustmentEvent</code>: <code>AdjustmentListener</code> ( <code>adjustmentValueChanged</code> )</li><li><code>ComponentEvent</code>: <code>ComponentListener</code> ( <code>componentMoved</code>, <code>componentHidden</code>, <code>componentResized</code>, <code>componentShown</code> )</li><li><code>WindowEvent</code>: <code>WindowListener</code> ( <code>windowClosing</code>, <code>windowOpened</code>, <code>windowIconified</code>, <code>windowDeiconified</code>, <code>windowClosed</code>, <code>windowActivated</code>, <code>windowDeactivated</code> )</li><li><code>ContainerEvent</code>: <code>ContainerListener</code> ( <code>componentAdded</code>, <code>componentRemoved</code> )</li><li><code>TextEvent</code>: <code>TextListener</code> ( <code>textValueChanged</code> )</li></ul></li></ul><h4 id="适配器类-Adapter">适配器类 (<code>Adapter</code>)</h4><p>每个具有不止一个方法的 AWT 监听器接口都有一个实现了其所有方法但</p><p><strong>不做任何工作</strong>的适配器类。</p><p>可以通过<strong>继承适配器类</strong>来只重写需要的方法，避免实现接口中所有的方法。</p><p><code>java.awt.event</code> 包中定义的事件适配器类包括：</p><ul><li><code>ComponentAdapter</code></li><li><code>ContainerAdapter</code></li><li><code>FocusAdapter</code></li><li><code>KeyAdapter</code></li><li><code>MouseAdapter</code> (示例显示其实现了 <code>mouseClicked</code> 等空方法)</li><li><code>MouseMotionAdapter</code></li><li><code>WindowAdapter</code></li></ul><h2 id="I-O-流">I/O 流</h2><p><strong>I/O (Input/Output)</strong> 指计算机与外部世界进行数据交换的过程，例如从键盘读取数据、向屏幕输出信息、读写文件、网络通信等。</p><p>**流 (Stream) **是 Java 语言输入/输出的方式， Java 程序通过流来完成输入/输出工作。是一个想象中的无限长的数据序列。 Java 提供了各种各样的流类来实现 I/O，封装了数据处理的细节.</p><p><strong>流的分类</strong>:</p><ul><li><strong>按数据流向</strong>：<ul><li><strong>输入流 (InputStream/Reader)</strong>： 从数据源读取数据到程序中。</li><li><strong>输出流 (OutputStream/Writer)</strong>： 从程序中写入数据到数据目的地。</li></ul></li><li><strong>按处理数据单位</strong>：<ul><li><strong>字节流 (Byte Stream)</strong>: 以字节（8位）为单位处理数据，适用于所有类型的数据（如图片、视频、文本等）。</li><li><strong>字符流 (Character Stream)</strong>: 以字符（16位 Unicode 字符）为单位处理数据，专门用于处理文本数据，可以避免编码问题。</li></ul></li><li><strong>按功能</strong>：<ul><li><strong>节点流 (Node Stream)</strong>: 直接与数据源（如文件、内存数组、管道）连接，提供基本的读写功能。</li><li><strong>处理流 / 包装流 (Processing Stream / Wrapper Stream)</strong>: 包装在其他流之上，修改或管理流中数据，提供额外的功能（如缓冲、数据转换、对象序列化、打印等）。</li></ul></li></ul><h4 id="文件-I-O">文件 I/O</h4><p><strong>文件存储格式</strong>：</p><ul><li><p>文件可以看作一系列字节的集合。</p></li><li><p>无论是字符 I/O 还是字节 I/O，最终文件中存储的都是这些字符的编码（字节序列）。</p></li><li><p>字符 I/O 程序：处理字符的统一码，进行编码/解码，文件中存储的是字符的编码（如 UTF-8, GBK 等）。</p></li><li><p>字节 I/O 程序：直接读写字节，文件中存储的是等价的字节数据。</p></li></ul><hr><p><strong><code>File</code> 类</strong>:</p><ul><li><code>java.io.File</code>：文件和目录路径名的抽象表示形式，用于获取文件或目录的信息.</li><li><strong>构造器</strong>:<ul><li><code>public File(String pathname)</code>: 以 <code>pathname</code> 为路径创建 <code>File</code> 对象，如果为相对路径则在默认的当前路径下存储.</li><li><code>public File(String parent, String child)</code>: 以 <code>parent</code> 为父路径，<code>child</code> 为子路径创建 <code>File</code> 对象.</li></ul></li><li><strong>常用方法</strong>:<ul><li><code>boolean canRead()</code>: 判断是否可读.</li><li><code>boolean canWrite()</code>: 判断是否可写.</li><li><code>boolean exists()</code>: 判断文件或目录是否存在.</li><li><code>boolean isDirectory()</code>: 判断是否是目录.</li><li><code>boolean isFile()</code>: 判断是否是文件.</li><li><code>boolean isHidden()</code>: 判断是否是隐藏文件.</li><li><code>long lastModified()</code>: 返回最后修改时间.</li><li><code>long length()</code>: 返回文件长度（字节数）.</li><li><code>String getName()</code>: 返回文件或目录名.</li><li><code>String getPath()</code>: 返回文件或目录的路径名字符串.</li><li><code>String getAbsolutePath()</code>: 返回文件的绝对路径名字符串.</li><li><code>boolean createNewFile()</code>: 创建新文件.</li><li><code>boolean delete()</code>: 删除文件或目录.</li><li><code>boolean mkdir()</code>: 创建单级目录.</li><li><code>boolean mkdirs()</code>: 创建多级目录.</li><li><code>File getParentFile()</code>: 返回父目录的 <code>File</code> 对象.</li><li><code>String[] list()</code>: 列出目录下的文件和目录名.</li><li><code>File[] listFiles()</code>: 返回目录下的 <code>File</code> 对象数组.</li></ul></li></ul><h4 id="流与相关类">流与相关类</h4><ul><li><p><strong>字节流类层次结构</strong>:</p><ul><li><p><strong><code>InputStream</code> (抽象基类)</strong>: 所有字节输入流的父类.</p><ul><li><p><code>int read()</code>: 读取一个字节并以整数形式返回.</p></li><li><p><code>int read(byte[] buffer)</code>: 读取一系列字节到数组 <code>buffer</code> 中，返回读取的字节数.</p></li><li><p><code>int read(byte[] buffer, int offset, int length)</code>: 从 <code>offset</code> 位置开始存储到 <code>buffer</code> 中.</p></li><li><p><code>void close()</code>: 关闭流，释放内存资源.</p></li><li><p><code>long skip(long n)</code>: 跳过 <code>n</code> 个字节.</p></li><li><p><strong>主要子类 (节点流)</strong>:</p><ul><li><code>FileInputStream</code>: 从文件中读取信息.</li><li><code>ByteArrayInputStream</code>: 将内存的缓冲区当作 <code>InputStream</code> 使用.</li><li><code>PipedInputStream</code>: 产生用于写入相关 <code>PipedOutputStream</code> 的数据，实现“管道化”.</li><li><code>SequenceInputStream</code>: 将两个或多个 <code>InputStream</code> 对象转换成单一 <code>InputStream</code>.</li><li><code>StringBufferInputStream</code> (已弃用): 将 <code>String</code> 转换成 <code>InputStream</code>.</li></ul></li><li><p><strong>处理流 (<code>FilterInputStream</code> 的子类)</strong>:</p><ul><li><code>DataInputStream</code>: 与 <code>DataOutputStream</code> 搭配使用，可以可移植方式从流读取基本数据类型 (<code>int</code>, <code>char</code>, <code>long</code> 等).</li><li><code>BufferedInputStream</code>: 使用缓冲区，防止每次读取都进行实际的读操作，提高效率.</li><li><code>LineNumberInputStream</code>: 跟踪输入流中的行号.</li><li><code>PushbackInputStream</code>: 具有一个字节的回退缓冲区，可以将读到的最后一个字符回退.</li><li><code>ObjectInputStream</code>: 用于读取对象，也可以处理基本数据类型.</li></ul></li></ul></li><li><p><strong><code>OutputStream</code> (抽象基类)</strong>: 所有字节输出流的父类.</p><ul><li><strong>常用方法</strong> (可能抛出 <code>IOException</code>):<ul><li><code>void write(int b)</code>: 写入一个字节.</li><li><code>void write(byte[] b)</code>: 写入字节数组.</li><li><code>void write(byte[] b, int off, int len)</code>: 写入字节数组的一部分.</li><li><code>void close()</code>: 关闭流.</li><li><code>void flush()</code>: 刷新缓冲区，强制写入数据.</li></ul></li><li><strong>主要子类 (节点流)</strong>:<ul><li><code>FileOutputStream</code>: 用于向文件中写入信息.</li><li><code>ByteArrayOutputStream</code>: 将数据写入内存缓冲区.</li><li><code>PipedOutputStream</code>: 写入数据到相关 <code>PipedInputStream</code>.</li></ul></li><li><strong>处理流 (<code>FilterOutputStream</code> 的子类)</strong>:<ul><li><code>DataOutputStream</code>: 与 <code>DataInputStream</code> 搭配使用，可移植地向流写入基本数据类型.</li><li><code>BufferedOutputStream</code>: 使用缓冲区，提高写入效率.</li><li><code>PrintStream</code>: 打印流，为其他输出流添加打印各种数据值表示形式的功能，不抛出 <code>IOException</code>，自动刷新.</li><li><code>ObjectOutputStream</code>: 用于写入对象.</li></ul></li></ul></li></ul></li><li><p><strong>字符流类层次结构</strong>:</p><ul><li><p><strong><code>Reader</code> (抽象基类)</strong>: 所有字符输入流的父类.</p><ul><li><p><strong>常用方法</strong> (可能抛出 <code>IOException</code>): <code>int read()</code>, <code>int read(char[] cbuf)</code>, <code>int read(char[] cbuf, int offset, int length)</code>, <code>void close()</code>, <code>long skip(long n)</code>.</p></li><li><p><strong>主要子类 (节点流)</strong>:</p><p><code>FileReader</code> (文件), <code>CharArrayReader</code> (内存字符数组), <code>StringReader</code> (内存字符串), <code>PipedReader</code> (管道).</p></li><li><p><strong>处理流 (<code>FilterReader</code> 的子类 或 其他)</strong>:</p><p><code>BufferedReader</code> (缓冲), <code>LineNumberReader</code> (行号), <code>PushbackReader</code> (回退), <code>InputStreamReader</code> (字节到字符的转换流).</p></li></ul></li><li><p><strong><code>Writer</code> (抽象基类)</strong>: 所有字符输出流的父类.</p><ul><li><p><strong>常用方法</strong> (可能抛出 <code>IOException</code>):</p><p><code>void write(int c)</code>, <code>void write(char[] cbuf)</code>, <code>void write(char[] cbuf, int offset, int length)</code>, <code>void write(String string)</code>, <code>void write(String string, int offset, int length)</code>, <code>void close()</code>, <code>void flush()</code>.</p></li><li><p><strong>主要子类 (节点流)</strong>:</p><p><code>FileWriter</code> (文件), <code>CharArrayWriter</code> (内存字符数组), <code>StringWriter</code> (内存字符串), <code>PipedWriter</code> (管道).</p></li><li><p><strong>处理流 (<code>FilterWriter</code> 的子类 或 其他)</strong>:</p><p><code>BufferedWriter</code> (缓冲), <code>PrintWriter</code> (打印流), <code>OutputStreamWriter</code> (字符到字节的转换流).</p></li></ul></li></ul></li><li><p><strong>特殊流类型</strong>:</p><ul><li><p><strong><code>DataInputStream</code> / <code>DataOutputStream</code></strong>: 用于对已经存在的输入/输出流进行包装，以便在原始流中过滤数据。支持原始数据类型（<code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>）的输入输出，与机器无关.</p></li><li><p><strong><code>BufferedInputStream</code> / <code>BufferedOutputStream</code></strong>: 减少读写次数，提高 I/O 效率，通过在高速设备和低速设备之间使用缓冲区实现。缓冲区默认大小为 512 字节。当缓冲满或调用 <code>flush</code> 方法时，数据写入.</p><ul><li><p><strong>常用方法</strong> (仅 <code>BufferedReader</code>/<code>BufferedWriter</code>):</p><p><code>readLine()</code> (读取一行), <code>newLine()</code> (写入行分隔符), <code>mark()</code>, <code>reset()</code>.</p></li></ul></li><li><p><strong><code>ObjectInputStream</code> / <code>ObjectOutputStream</code></strong>: 支持对象的输入输出，像数据流一样支持对象的输入输出。可序列化对象实现了 <code>java.io.Serializable</code> 接口。<code>Serializable</code> 是一个标记性接口，没有方法，实现它可启动 Java 序列化机制.</p><ul><li>读取对象时，必须与写入时的类型顺序一致.</li><li>要使用读回的对象，必须使用 Java 安全类型转换.</li><li>数组也可以被序列化.</li></ul></li><li><p><strong><code>PrintStream</code> / <code>PrintWriter</code></strong>: 为其他输出流添加了方便地打印各种数据值表示形式的功能。分别针对字节和字符，提供重载的 <code>print</code> 和 <code>println</code> 方法。特点是不抛出 <code>IOException</code>，自动刷新.</p></li></ul></li></ul><h4 id="标准-I-O-流">标准 I/O 流</h4><p><strong>三个标准 I/O 流</strong>:</p><ul><li><p><code>System.in</code>: <code>InputStream</code> 类的对象实例 <code>in</code> 作为标准输入流对象，对应于键盘输入.</p></li><li><p><code>System.out</code>: <code>PrintStream</code> 类的对象实例 <code>out</code> 作为标准输出流对象，对应于显示器输出.</p></li><li><p><code>System.err</code>: <code>PrintStream</code> 类的对象实例 <code>err</code> 作为标准错误输出流对象，对应于显示器输出.</p></li><li><p>标准 I/O 流可以被重定向到文件或其他流，实现文件复制等功能。</p></li></ul><h4 id="随机访问文件-RandomAccessFile">随机访问文件 (<code>RandomAccessFile</code>)</h4><p><code>RandomAccessFile</code>: 适用于由大小已知的记录组成的文件，可以使用 <code>seek()</code> 将记录从一处转移到另一处.</p><p>它不是继承自 <code>InputStream</code> 和 <code>OutputStream</code>，而是像 <code>DataInputStream</code> 和 <code>DataOutputStream</code> 一样实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口.</p><ul><li><p>类似于把 <code>DataInputStream</code> 和 <code>DataOutputStream</code> 结合在一起使用.</p></li><li><p>只有 <code>RandomAccessFile</code> 类在文件上支持搜寻（<code>seek()</code>）方法.</p></li><li><p><strong>构造器</strong>:</p><p><code>RandomAccessFile(File file, String mode)</code>, <code>RandomAccessFile(String name, String mode)</code>.</p></li><li><p><strong>常用方法</strong>:</p><ul><li><code>void seek(long pos)</code>: 用于文件内移至新位置.</li><li><code>long getFilePointer()</code>: 得到当前位置.</li><li><code>long length()</code>: 判断文件大小.</li></ul></li></ul><p>压缩流</p><p><strong><code>ZipOutputStream</code> / <code>GZIPOutputStream</code></strong>: 压缩数据，生成 Zip 或 GZip 格式文件.</p><p><strong><code>ZipInputStream</code> / <code>GZIPInputStream</code></strong>: 解压缩已经生成的 Zip 或 GZip 文件.</p><p>它们继承于 <code>InputStream</code> 和 <code>OutputStream</code>.</p><h4 id="Scanner-类"><code>Scanner</code> 类</h4><p><code>java.util.Scanner</code>: Java 5 添加的类，用于从各种输入源（如 <code>System.in</code>、文件、字符串）解析基本类型和字符串。</p><p>使用<strong>正则表达式</strong>来检索、替换那些符合某个模式（规则）的文本。</p><ul><li><strong>常用方法</strong>：<ul><li><code>boolean hasNext(Pattern pattern)</code></li><li><code>boolean hasNextInt()</code> / <code>boolean hasNextLine()</code>: 判断输入中是否还有下一个标记/行。</li><li><code>String next()</code> / <code>String nextLine()</code>: 读取并返回下一个标记/行。</li><li><code>int nextInt()</code>: 读取并返回下一个整数。</li></ul></li><li><code>next()</code> 方法在读取时以空格为分隔符，<code>nextLine()</code> 读取一行直到换行符。</li><li>使用后应调用 <code>close()</code> 关闭 <code>Scanner</code>。</li></ul><h2 id="并发">并发</h2><p>实现并发有两种方法：</p><ul><li><strong>继承 <code>Thread</code> 类</strong>，重写 <code>run</code> 方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>    <span class="hljs-keyword">private</span> String threadName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String threadName)</span> {<br>        <span class="hljs-built_in">this</span>.threadName = threadName;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 线程执行的逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {<br>            System.out.println(threadName + <span class="hljs-string">" --- "</span> + i);<br>        }<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">"Thread-1"</span>);<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">"Thread-2"</span>);<br>        t1.start(); <span class="hljs-comment">// 启动线程，JVM 调用 run 方法</span><br>        t2.start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>实现 <code>Runnable</code> 接口</strong>，重写 <code>run</code> 方法，并创建 <code>Thread</code> 对象</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {<br>    <span class="hljs-keyword">private</span> String threadName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(String threadName)</span> {<br>        <span class="hljs-built_in">this</span>.threadName = threadName;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 线程执行的逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {<br>            System.out.println(threadName + <span class="hljs-string">" --- "</span> + i);<br>        }<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-string">"Runnable-1"</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-string">"Runnable-2"</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1).start(); <span class="hljs-comment">// 将 Runnable 实例包装到 Thread 对象中</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r2).start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="同步">同步</h3><p>Java 提供了 <strong><code>synchronized</code> 关键字</strong>作为最基本的同步机制。每个 Java 对象都可以作为一个<strong>监视器锁</strong> (monitor lock)。</p><p>当一个线程进入 <code>synchronized</code> 代码块或方法时，它会尝试获取该对象的锁。如果锁已经被其他线程持有，当前线程就会被阻塞，直到锁被释放。</p><ul><li><strong><code>synchronized</code> 方法</strong></li><li><strong><code>synchronized</code> 块</strong></li></ul><h3 id="协作">协作</h3><p>除了简单的同步访问共享资源，线程有时还需要<strong>相互协调</strong>，即一个线程等待某个条件满足，而另一个线程负责满足条件并通知等待的线程。Java 的 <code>Object</code> 类提供了 <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 方法来实现这种协作。</p><ul><li><strong><code>wait()</code></strong>:<ul><li><strong>作用</strong>: 使当前线程<strong>释放它所持有的对象锁</strong> ，并进入该对象的<strong>等待池</strong>（或称等待队列），从而暂停执行。</li><li><strong>调用时机</strong>: 必须在 <code>synchronized</code> 块或方法中调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li><li><strong>唤醒</strong>: 线程会一直等待，直到被 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒，或者达到超时时间 (<code>wait(long timeout)</code>)，或者被中断 (<code>InterruptedException</code>)。</li><li><strong>虚假唤醒 (Spurious Wakeup)</strong>: 线程有可能在没有被 <code>notify()</code> 或 <code>notifyAll()</code> 明确通知的情况下被唤醒。因此，等待的条件<strong>必须用 <code>while</code> 循环进行检查</strong>，而不是 <code>if</code> 语句 。</li></ul></li><li><strong><code>notify()</code></strong>:<ul><li><strong>作用</strong>: 唤醒在该对象上等待的<strong>一个</strong>任意线程（JVM 决定唤醒哪个）。被唤醒的线程会尝试重新获取对象锁，然后从 <code>wait()</code> 暂停的地方继续执行。</li><li><strong>调用时机</strong>: 必须在 <code>synchronized</code> 块或方法中调用。</li></ul></li><li><strong><code>notifyAll()</code></strong>:<ul><li><strong>作用</strong>: 唤醒在该对象上等待的<strong>所有</strong>线程。所有被唤醒的线程都会竞争对象锁。</li><li><strong>调用时机</strong>: 必须在 <code>synchronized</code> 块或方法中调用。</li><li><strong>建议</strong>: 鉴于虚假唤醒和条件竞争的复杂性，通常建议使用 <code>notifyAll()</code> 而非 <code>notify()</code>，以确保所有相关线程都有机会重新检查条件并继续执行 。</li></ul></li></ul><h2 id="参考和注解">参考和注解</h2></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>Java 程序设计</div><div>https://blog.kisechan.space/2025/notes-java/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kisechan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年6月24日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2025年6月25日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2025/notes-ptms/" title="概率论与数理统计"><span class="hidden-mobile">概率论与数理统计</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",function(){var e=Object.assign({clientID:"Ov23liWYIiu2jxReIEhB",clientSecret:"d7b44817ae2553b2175fdecfde9718b582bdc653",repo:"Comment-Kisechan",owner:"Kisechan",admin:["Kisechan"],language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!0,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enabled:!0},{id:"283020abd4f0802c4c2e97bdd1fb4b83"});new Gitalk(e).render("gitalk-container")})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><div><span>Frame by </span><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>| Theme </span><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div style="font-size:.85rem"><span id="timeStart">本站自 2024 年 4 月 26 日 20 : 46 : 17 起</span> <span><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></span><span><span><br>本站总访问量&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span> <span>总访客数&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人 &nbsp<br></span></span><span>&copy; 2024 - 2025 By <a href="https://github.com/Kisechan" target="_blank" rel="nofollow noopener"><strong>Kisechan</strong></a><br></span><span>今天也很喜欢你！</span><br><a href="https://icp.gov.moe/?keyword=20251453" target="_blank">萌ICP备20251453号</a></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/cursor.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script><script type="text/javascript">var originalTitle=document.title;window.onblur=function(){document.title="等你回来哦"},window.onfocus=function(){document.title=originalTitle}</script><div id="tooltip-rightmenu" class="tooltip-rightmenu">如果需要使用原始右键菜单请按下 <strong>Ctrl+右键</strong></div><div id="tooltip-clipboard" class="tooltip-rightmenu">链接复制成功！</div><div id="rightmenu-wrapper"><ul class="list-v rightmenu" id="rightmenu-content"><li class="navigation menuNavigation-Content"><a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa fa-arrow-left rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa fa-arrow-right rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa fa-refresh rightmenu-icon"></i></a> <a aria-label="TOP" href="#" role="button"><i class="fa fa-arrow-up rightmenu-icon"></i></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><span><i class="fa fa-search rightmenu-icon"></i> 站内搜索</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="toggleFullScreen()"><span><i class="fa fa-arrows-alt rightmenu-icon"></i> 切换全屏</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="copyPageUrl()"><span><i class="fa fa-clipboard rightmenu-icon"></i> 复制链接</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="scrollToComments()"><span><i class="fa fa-commenting rightmenu-icon"></i> 立即评论</span></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_blank" rel="noopener" href="https://www.kisechan.space/" data-group="link"><span><i class="fa fa-info-circle rightmenu-icon"></i> 关于本站</span></a></li></ul></div><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/css/custom_right_menu_icons.css" type="text/css" rel="stylesheet"><script src="/js/right_menu.js" type="text/javascript"></script><link href="/css/right_menu.css" type="text/css" rel="stylesheet"><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>