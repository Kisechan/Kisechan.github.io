<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><link rel=manifest href=/manifest.json><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://images.kisechan.space/apple-touch-icon.png"><link rel="icon" href="https://images.kisechan.space/icon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#004e66"><meta name="author" content="Kisechan"><meta name="keywords" content=""><meta name="description" content="速通的倒数第二门，唉这学期怎么都在速通，活得太没意思了。 祝我好运。  Java 基础 概述 Java 是一种“简单、面向对象、分布式、解释型、健壮、安全、体系结构中立、可移植、高性能、多线程和动态”的编程语言。  简单性  去掉了指针，取消多重继承和运算符重载。 自动内存分配与回收机制。   纯粹的面向对象 分布式，面向网络 健壮性  内存自动管理。 异常处理机制。   安全性  直接去掉指针"><meta property="og:type" content="article"><meta property="og:title" content="Java 程序设计"><meta property="og:url" content="https://blog.kisechan.space/2025/notes-java/index.html"><meta property="og:site_name" content="Kisechan&#39;s Blog"><meta property="og:description" content="速通的倒数第二门，唉这学期怎么都在速通，活得太没意思了。 祝我好运。  Java 基础 概述 Java 是一种“简单、面向对象、分布式、解释型、健壮、安全、体系结构中立、可移植、高性能、多线程和动态”的编程语言。  简单性  去掉了指针，取消多重继承和运算符重载。 自动内存分配与回收机制。   纯粹的面向对象 分布式，面向网络 健壮性  内存自动管理。 异常处理机制。   安全性  直接去掉指针"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.kisechan.space/6a0828d64cd102fd673eda5f3f2fdb30_720.jpg"><meta property="article:published_time" content="2025-06-24T12:52:38.000Z"><meta property="article:modified_time" content="2025-06-26T11:02:27.115Z"><meta property="article:author" content="Kisechan"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://images.kisechan.space/6a0828d64cd102fd673eda5f3f2fdb30_720.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><title>Java 程序设计 - Kisechan&#39;s Blog</title><link rel="stylesheet" type="text/css" href="/css/loading.css"><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4890189_5ms3yf4n747.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"blog.kisechan.space",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),n=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3837;break}}),i=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+6136;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="Kisechan's Blog" type="application/atom+xml"></head><body><div><div class="real_mask" style="background-color:rgba(0,0,0,.3);width:100%;height:100%;position:fixed;z-index:-777"></div><div id="banner_video_insert"></div><div id="vvd_banner_img"></div></div><div id="banner"></div><div id="loader-box"><div class="loader-wrapper"><div class="loader"></div><div class="loader-text"><div>L</div><div>O</div><div>A</div><div>D</div><div>I</div><div>N</div><div>G</div><div></div><div></div><div></div></div></div><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loader-box").remove()};window.addEventListener("load",endLoading)</script></div><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KISECHAN</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-Homehomepagemenu"></i> <span>博客</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-newstextarticle"></i> <span>文章</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-categories"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user"></i> <span>个人</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.kisechan.space/" target="_self"><i class="iconfont icon-info-fill"></i> <span>关于</span> </a><a class="dropdown-item" href="/playlist/" target="_self"><i class="iconfont icon-music"></i> <span>歌单</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/Kisechan.github.io" target="_self"><i class="iconfont icon-git"></i> <span>仓库</span> </a><a class="dropdown-item" href="/atom.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS 订阅</span></a></div></li><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/tools/" target="_self"><i class="iconfont icon-tool-fill"></i> <span>工具</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/links" target="_self"><i class="iconfont icon-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://images.kisechan.space/202502042159748.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Java 程序设计</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kisechan </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-06-24 20:52" pubdate>2025年6月24日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.7k 字 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div><script type="text/javascript" src="/vvd_js/jquery.js"></script><div class="banner" id="banner"><div class="full-bg-img"></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="课程笔记" id="heading-311a46cfdaa3afda544e9285644f70d7" role="tab" data-toggle="collapse" href="#collapse-311a46cfdaa3afda544e9285644f70d7" aria-expanded="true">课程笔记 <span class="list-group-count">(12)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-311a46cfdaa3afda544e9285644f70d7" role="tabpanel" aria-labelledby="heading-311a46cfdaa3afda544e9285644f70d7"><div class="category-post-list"><a href="/2024/oop/" title="面向对象程序设计课程笔记" class="list-group-item list-group-item-action"><span class="category-post">面向对象程序设计课程笔记</span> </a><a href="/2024/linux-note/" title="Linux课程笔记" class="list-group-item list-group-item-action"><span class="category-post">Linux课程笔记</span> </a><a href="/2024/ds/" title="数据结构课程板子合集&amp;笔记" class="list-group-item list-group-item-action"><span class="category-post">数据结构课程板子合集&amp;笔记</span> </a><a href="/2025/notes-algorithm-analysis/" title="算法设计与分析 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">算法设计与分析 课程笔记</span> </a><a href="/2025/notes-database-1/" title="数据库原理 课程笔记 (1) 数据库、关系代数和 SQL" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (1) 数据库、关系代数和 SQL</span> </a><a href="/2025/notes-database-2/" title="数据库原理 课程笔记 (2) E-R 模型和关系模式" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (2) E-R 模型和关系模式</span> </a><a href="/2025/notes-database-3/" title="数据库原理 课程笔记 (3) 存储、索引、事务和并发" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (3) 存储、索引、事务和并发</span> </a><a href="/2025/notes-database-4/" title="数据库原理 课程笔记 (4) 杂项和题目整理" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (4) 杂项和题目整理</span> </a><a href="/2025/notes-os/" title="操作系统复习" class="list-group-item list-group-item-action"><span class="category-post">操作系统复习</span> </a><a href="/2025/notes-ptms/" title="概率论与数理统计" class="list-group-item list-group-item-action"><span class="category-post">概率论与数理统计</span> </a><a href="/2025/notes-java/" title="Java 程序设计" class="list-group-item list-group-item-action active"><span class="category-post">Java 程序设计</span> </a><a href="/2025/notes-networks/" title="计算机网络课程笔记" class="list-group-item list-group-item-action"><span class="category-post">计算机网络课程笔记</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java 程序设计</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2025-06-26T19:02:27+08:00</p><div class="markdown-body"><blockquote><p>速通的倒数第二门，唉这学期怎么都在速通，活得太没意思了。</p><p>祝我好运。</p></blockquote><h2 id="Java-基础">Java 基础</h2><h3 id="概述">概述</h3><p>Java 是一种“<strong>简单、面向对象、分布式、解释型、健壮、安全、体系结构中立、可移植、高性能、多线程和动态</strong>”的编程语言。</p><ul><li><strong>简单性</strong><ul><li>去掉了指针，取消多重继承和运算符重载。</li><li>自动内存分配与回收机制。</li></ul></li><li><strong>纯粹的面向对象</strong></li><li><strong>分布式</strong>，面向网络</li><li><strong>健壮性</strong><ul><li>内存自动管理。</li><li>异常处理机制。</li></ul></li><li><strong>安全性</strong><ul><li>直接去掉指针。</li><li>所有程序和数据都在沙箱中。</li></ul></li><li><strong>体系结构中立</strong>，平台无关<ul><li>只要安装了 <strong>Java 虚拟机</strong> (JVM)，代码就可以在随处运行。</li></ul></li><li><strong>可移植性</strong></li><li><strong>解释执行</strong><ul><li>Java 程序被编译成 JVM 字节码，不依赖机器，可运行在任意安装了 Java 解释器的机器上。</li></ul></li><li><strong>高性能</strong></li><li><strong>多线程</strong></li><li><strong>动态性</strong><ul><li>在类库中可以自由地加入新的方法和实例变量而不会影响用户程序的执行。</li></ul></li></ul><h3 id="Java-和-C">Java 和 C++</h3><ol><li>Java 语言中<strong>不允许在类之外定义全局变量</strong>，而只能通过在类中定义静态变量来实现。</li><li>Java 语言中<strong>没有 <code>goto</code> 语句</strong>。</li><li>Java 语言中<strong>没有指针型变量</strong>。</li><li><strong>内存管理</strong>实现了自动化。</li><li>Java 语言对于<strong>不同的数据类型定义统一的规格</strong>，保证了平台无关性。</li><li>Java 语言中<strong>不允许像 C 和 C++ 中那样任意进行类型转换</strong>。</li><li>Java 语言中<strong>无头文件</strong>。</li><li>Java 语言中<strong>无结构体和联合</strong>。</li><li>Java 语言中<strong>无预处理和宏定义</strong>。</li></ol><hr><p>Java 语言特色：</p><ul><li><strong>类不支持多重继承</strong></li><li><strong><code>Abstract</code>/<code>Final</code> 类</strong></li><li><strong>接口</strong></li><li><strong>自动内存回收</strong></li><li><strong>多线程</strong></li></ul><h3 id="标识符使用惯例">标识符使用惯例</h3><ul><li><strong>类和接口</strong> <code>SimpleApp</code><ul><li>类名和接口名通常用名词，且每个单词的首字母大写。</li></ul></li><li><strong>方法</strong> <code>processResult</code><ul><li>方法名用动词开头的单词序列，首单词全部小写，后面的每个单词首<br>字母大写。</li></ul></li><li><strong>常量</strong> <code>PI</code><ul><li>常量名全部用大写字母。</li></ul></li><li><strong>变量</strong> <code>outputResult</code><ul><li>所有的对象实例名和全局变量名都使用首单词全部小写，后面的每个<br>单词首字母大写的格式。</li></ul></li></ul><h2 id="对象">对象</h2><h3 id="访问控制">访问控制</h3><table><thead><tr><th style="text-align:center">控制符</th><th style="text-align:center">同一个类中</th><th style="text-align:center">同一个包 中</th><th style="text-align:center">不同包中的子类</th><th style="text-align:center">不同包中的非子类</th></tr></thead><tbody><tr><td style="text-align:center"><code>public</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center"><code>protected</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>default</code> （什么都不写）</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>private</code></td><td style="text-align:center">✅</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="接口和类">接口和类</h3><p>Java 中所有的类都继承自 <code>java.lang.Object</code>。</p><table><thead><tr><th style="text-align:center">基本方法</th><th style="text-align:center">作用</th><th style="text-align:center">是否常重写</th></tr></thead><tbody><tr><td style="text-align:center"><code>toString()</code></td><td style="text-align:center">返回对象的字符串表示</td><td style="text-align:center">✅ 常重写</td></tr><tr><td style="text-align:center"><code>equals(Object obj)</code></td><td style="text-align:center">判断两个对象是否“相等”</td><td style="text-align:center">✅ 常重写</td></tr><tr><td style="text-align:center"><code>hashCode()</code></td><td style="text-align:center">返回对象的哈希值</td><td style="text-align:center">✅ 常和 <code>equals</code> 一起重写</td></tr><tr><td style="text-align:center"><code>getClass()</code></td><td style="text-align:center">返回运行时类对象</td><td style="text-align:center">❌ 一般不重写</td></tr><tr><td style="text-align:center"><code>clone()</code></td><td style="text-align:center">对对象进行浅拷贝</td><td style="text-align:center">❌ 少用，需实现 <code>Cloneable</code> 接口</td></tr><tr><td style="text-align:center"><code>finalize()</code></td><td style="text-align:center">垃圾回收前调用（不推荐使用）</td><td style="text-align:center">❌ 废弃</td></tr><tr><td style="text-align:center"><code>wait()</code></td><td style="text-align:center">线程等待（需在同步块中）</td><td style="text-align:center">❌ 通常不重写</td></tr><tr><td style="text-align:center"><code>notify()</code></td><td style="text-align:center">唤醒等待的线程</td><td style="text-align:center">❌ 通常不重写</td></tr><tr><td style="text-align:center"><code>notifyAll()</code></td><td style="text-align:center">唤醒所有等待的线程</td><td style="text-align:center">❌ 通常不重写</td></tr></tbody></table><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">接口（interface）</th><th style="text-align:center">类（class）</th></tr></thead><tbody><tr><td style="text-align:center">语义</td><td style="text-align:center">定义行为规范，类似“能力”</td><td style="text-align:center">定义对象的属性和行为</td></tr><tr><td style="text-align:center">方法</td><td style="text-align:center">默认是 <code>public abstract</code>（除非是 <code>default</code>/<code>static</code>/<code>private</code>）</td><td style="text-align:center">可包含具体实现的方法</td></tr><tr><td style="text-align:center">字段</td><td style="text-align:center">默认是 <code>public static final</code>（常量），且只能是 <code>public</code></td><td style="text-align:center">可定义变量，有访问权限控制</td></tr><tr><td style="text-align:center">继承</td><td style="text-align:center">可以多继承多个接口</td><td style="text-align:center">只能单继承一个类</td></tr><tr><td style="text-align:center">实现方式</td><td style="text-align:center">类用 <code>implements</code> 来实现接口</td><td style="text-align:center">类用 <code>extends</code> 继承另一个类</td></tr><tr><td style="text-align:center">实例化</td><td style="text-align:center">无法直接实例化</td><td style="text-align:center">可以实例化（如果不是 <code>abstract</code>）</td></tr></tbody></table><h2 id="数据结构">数据结构</h2><h3 id="数组">数组</h3><p>数组是一种固定大小的同类型数据序列。</p><p>声明数组变量有两种形式：</p><ul><li><code>类型[] 数组名;</code> (推荐)</li><li><code>类型 数组名[];</code></li></ul><p>例如：<code>int[] a;</code> 或 <code>String[] names;</code></p><p><strong>创建与初始化</strong>：</p><ul><li><p><strong>静态初始化</strong>：在声明时直接指定元素值。数组长度由元素个数决定 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}; <span class="hljs-comment">// 长度为 5</span><br>String[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{<span class="hljs-string">"Red"</span>, <span class="hljs-string">"Green"</span>, <span class="hljs-string">"Blue"</span>};<br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>动态初始化</strong>：指定数组长度，元素会自动赋为默认值（数值型为 0，布尔型为 <code>false</code>，引用型为 <code>null</code>）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 长度为 10，所有元素初始化为 0</span><br>String[] names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 长度为 5，所有元素初始化为 null</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>对象数组</strong>：数组元素是对象引用，需要单独初始化每个对象 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明并动态初始化一个 Person 对象数组</span><br>Person[] people = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[<span class="hljs-number">2</span>];<br>people[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 单独初始化对象</span><br>people[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></tbody></table></figure></li></ul><p><strong>访问</strong>：使用 <code>数组名[索引值]</code> 访问元素，索引从 0 开始 。</p><p><strong>长度属性</strong>：数组具有唯一的 <code>length</code> 属性，记录数组中元素的个数 ，用 <code>numbers.length</code> 获取数组长度 。</p><ul><li><p><strong>多维数组</strong>：是数组的数组，可以是不规则数组（各维长度不等） 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] matrix = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}}; <span class="hljs-comment">// 2x3 矩阵</span><br><span class="hljs-type">int</span>[][] irregularArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][]; <span class="hljs-comment">// 不规则数组</span><br>irregularArray[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 第一行 2 列</span><br>irregularArray[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 第二行 3 列</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>数组引用</strong>：Java 数组是特殊的对象，数组变量存放一个数组对象的引用 。因此，数组作为方法参数时，传递的是引用，可以改变数组元素的值 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeArrayValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>; <span class="hljs-comment">// 改变原数组的值</span><br>}<br><span class="hljs-comment">// 调用：int[] myArr = {1, 2, 3}; changeArrayValue(myArr); System.out.println(myArr[0]); // 输出 99</span><br></code></pre></td></tr></tbody></table></figure></li></ul><p><strong><code>Arrays</code> 工具类</strong>：<code>java.util.Arrays</code> 提供了一套静态方法，用于数组的排序 (<code>sort()</code>)、查找 (<code>binarySearch()</code>)、复制 (<code>copyOf()</code>)、比较 (<code>equals()</code>) 等 。</p><h3 id="枚举">枚举</h3><p>枚举是一种<strong>特殊的类</strong>，用于定义固定数量的命名常量。</p><p>使用 <code>enum</code> 关键字定义，枚举类型变量只能保存此类声明时给定的某个枚举值 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> {<br>    SPRING, SUMMER, FALL, WINTER; <span class="hljs-comment">// 枚举常量列表</span><br>}<br><span class="hljs-type">Season</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Season.SPRING; <span class="hljs-comment">// 声明和赋值</span><br></code></pre></td></tr></tbody></table></figure><p><strong>本质</strong>：Java 的枚举是真正的类，它们可以有构造方法、成员变量、方法，甚至可以实现接口 。每个枚举常量都是该枚举类型的一个实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TrafficLight</span> {<br>    RED(<span class="hljs-string">"Stop"</span>), YELLOW(<span class="hljs-string">"Caution"</span>), GREEN(<span class="hljs-string">"Go"</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String action;<br><br>    TrafficLight(String action) { <span class="hljs-comment">// 构造方法</span><br>        <span class="hljs-built_in">this</span>.action = action;<br>    }<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAction</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 方法</span><br>        <span class="hljs-keyword">return</span> action;<br>    }<br>}<br><span class="hljs-type">TrafficLight</span> <span class="hljs-variable">currentLight</span> <span class="hljs-operator">=</span> TrafficLight.RED;<br>System.out.println(currentLight.getAction()); <span class="hljs-comment">// 输出 "Stop"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>使用</strong>：</p><ul><li>可以在 <code>switch</code> 语句中使用 。</li><li><code>name()</code> 方法：返回枚举常量的名称字符串。</li><li><code>ordinal()</code> 方法：返回枚举常量的序数（在枚举声明中的位置，从 0 开始）。</li><li><code>valueOf(String name)</code>：返回具有指定名称的枚举常量。</li><li><code>values()</code>：返回包含所有枚举常量的数组。</li></ul><h3 id="容器">容器</h3><p>Java 集合框架（<code>java.util</code> 包）提供了一套用于存储和管理对象的接口和类，具有动态容量。这是 Java 处理对象集合的主要方式，与 C++ 的 STL 类似。</p><p><strong>Java 中的容器：</strong></p><ul><li><p><strong>核心接口</strong>：</p><ul><li><code>Collection</code>：所有集合的根接口，定义了集合的基本操作（添加、删除、判断包含等） 。</li><li><code>List</code>：有序的 <code>Collection</code>，元素有索引，允许重复元素 。<ul><li><strong>实现类</strong>：<ul><li><code>ArrayList</code>：基于动态数组实现，随机访问效率高，中间插入删除慢 。</li><li><code>LinkedList</code>：基于双向链表实现，中间插入删除效率高，随机访问慢 。</li></ul></li></ul></li><li><code>Set</code>：无序的 <code>Collection</code>，<strong>不允许重复元素</strong> 。<ul><li><strong>实现类</strong>：<ul><li><code>HashSet</code>：基于哈希表实现，查找、添加、删除效率高（平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>），元素无序 。要求元素类正确重写 <code>hashCode()</code> 和 <code>equals()</code> 。</li><li><code>LinkedHashSet</code>：基于哈希表和链表实现，保持元素的插入顺序 。</li><li><code>TreeSet</code>：基于红黑树实现，元素按自然顺序或比较器顺序排序 。查找效率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span>。</li></ul></li></ul></li><li><code>Map</code>：存储<strong>键值对 (KV Pair)</strong>，键唯一，值可重复 。<ul><li><strong>实现类</strong>：<ul><li><code>HashMap</code>：基于哈希表实现，查找、添加、删除效率高（平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>），键值对无序 。要求键类正确重写 <code>hashCode()</code> 和 <code>equals()</code> 。</li><li><code>LinkedHashMap</code>：基于哈希表和链表实现，保持键值对的插入顺序 。</li><li><code>TreeMap</code>：基于红黑树实现，键按自然顺序或比较器顺序排序 。查找效率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mclose">)</span></span></span></span>。</li></ul></li></ul></li></ul></li><li><p><strong>迭代器</strong>：</p><ul><li><code>Iterator</code>：用于遍历 <code>Collection</code> 中的元素 。</li><li><code>ListIterator</code>：专门用于 <code>List</code>，支持双向遍历和修改元素 。</li></ul></li><li><p><strong>泛型 (Generics)</strong>：Java 1.5 引入，用于在编译时提供类型安全，避免运行时类型转换错误 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 编译时检查，只能存 String</span><br>Map&lt;Integer, String&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>工具类</strong>：</p><ul><li><code>java.util.Collections</code>：提供对 <code>Collection</code> 进行操作的静态方法（排序、查找、反转等） 。</li><li><code>java.util.Arrays</code>：提供对数组进行操作的静态方法 。</li></ul></li></ul><h2 id="图形化界面">图形化界面</h2><h3 id="Swing">Swing</h3><ul><li><strong>AWT (Abstract Window Toolkit)</strong>:<ul><li>提供一套与本地图形界面交互的接口。</li><li>依赖本地方法实现功能，因此 AWT 控件被称为<strong>重量级控件</strong>。</li></ul></li><li><strong>Swing</strong>:<ul><li>在 AWT 基础上构建的新图形界面系统。</li><li>提供 AWT 的所有功能，并进行大幅扩充。</li><li>没有使用本地方法实现图形功能，因此 Swing 控件被称为<strong>轻量级控件</strong>。</li><li>随着 Java2 的发布，Swing 逐渐替代了 AWT，本章主要介绍 Swing 组件。</li><li>Swing 组件类以字母 “J” 开头，除了与 AWT 类似的组件外，还增加了丰富的<strong>高层组件</strong>。</li><li>Java 语言采用<strong>向容器中添加组件</strong>的方式构建 GUI。通常使用<strong>顶级容器</strong>作为所有组件的承载物，可以向其中添加包括容器在内的各种组件，并合理安排布局。容器之间允许嵌套。</li></ul></li></ul><hr><p>GUI 组件从使用上可分为三大类：</p><ol><li><strong>容器类</strong> (Container):<ul><li>用于包含其他组件的容器。</li><li>例如： <code>JFrame</code> (顶层容器), <code>JApplet</code>, <code>JDialog</code>, <code>JPanel</code> (普通容器)。</li></ul></li><li><strong>控件类</strong> (Control):<ul><li>都是 <code>JComponent</code> 类（抽象类）的子类。</li><li>例如： <code>JButton</code>, <code>JTextField</code>, <code>JTextArea</code>, <code>JComboBox</code>, <code>JList</code>, <code>JRadioButton</code>, <code>JMenu</code>。</li></ul></li><li><strong>辅助类</strong> (Auxiliary Class):<ul><li>描述和绘制容器类和组件类属性和放置的类。</li><li>例如： <code>Graphics</code>, <code>Color</code>, <code>Font</code>, <code>FontMetrics</code>, <code>Dimension</code>, <code>LayoutManager</code>。</li></ul></li></ol><h3 id="常用组件">常用组件</h3><h4 id="JFrame-类"><code>JFrame</code> 类</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>java.awt.Window</code> -&gt; <code>java.awt.Frame</code> -&gt; <code>javax.swing.JFrame</code>。</li><li><strong>构造方法</strong>: <code>public JFrame()</code>, <code>public JFrame(String title)</code>。</li><li><strong>成员方法</strong>:<ul><li><code>setSize()</code>: 设置<strong>窗口大小</strong>。</li><li><code>setVisible()</code>: 设置<strong>窗口可见性</strong>。</li><li><code>setLocation()</code>: 设置<strong>窗口位置</strong>。</li><li><code>setDefaultCloseOperation(int operation)</code>: 设置<strong>窗口关闭时的动作</strong>。<ul><li>参数 <code>operation</code> 有四种取值：<code>DO_NOTHING_ON_CLOSE</code>, <code>HIDE_ON_CLOSE</code>, <code>DISPOSE_ON_CLOSE</code>, <code>EXIT_ON_CLOSE</code>。</li></ul></li><li><code>getContentPane()</code>: 获取<strong>内容面板</strong>。</li><li><code>setTitle()</code>: 设置<strong>窗口标题</strong>。</li></ul></li></ul><h4 id="JLabel-类"><code>JLabel</code> 类</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>javax.swing.JComponent</code> -&gt; <code>javax.swing.JLabel</code>。</li><li><strong>构造方法</strong>: 支持多种构造方法，如只带文本、只带图标、或同时带文本和图标及对齐方式。</li><li><strong>对齐属性</strong>: <code>SwingConstants.LEFT</code>, <code>SwingConstants.CENTER</code>, <code>SwingConstants.RIGHT</code>, <code>SwingConstants.BOTTOM</code>。</li><li><strong>成员方法</strong>: <code>setText()</code>, <code>setIcon()</code>, <code>getText()</code>, <code>setHorizontalTextPosition()</code>, <code>setVerticalTextPosition()</code>。</li></ul><h4 id="JPanel-类"><code>JPanel</code> 类</h4><ul><li><strong>面板容器</strong>: <code>JPanel</code> 是分组放置组件的、位于框架更低一级的普通容器。</li><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>javax.swing.JComponent</code> -&gt; <code>javax.swing.JPanel</code>。</li><li><strong>构造方法</strong>: <code>public JPanel()</code>。</li><li><strong>成员方法</strong>: <code>paintComponents(Graphics g)</code>, <code>add(Component comp)</code>。</li></ul><h4 id="JButton-类"><code>JButton</code> 类</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.Component</code> -&gt; <code>java.awt.Container</code> -&gt; <code>javax.swing.JComponent</code> -&gt; <code>javax.swing.AbstractButton</code> -&gt; <code>javax.swing.JButton</code>。</li><li><strong>构造方法</strong>: 支持多种构造方法，如无文本、带文本、带图标、或同时带文本和图标。</li><li><strong>成员方法</strong>: <code>setText()</code>, <code>setIcon()</code>, <code>setBounds()</code>, <code>addActionListener(ActionListener l)</code>。</li></ul><h4 id="文本框-JTextField">文本框 <code>JTextField</code></h4><ul><li><strong>构造方法</strong>: <code>public JTextField()</code>, <code>public JTextField(String text)</code>, <code>public JTextField(int columns)</code>, <code>public JTextField(String text, int columns)</code>。</li><li><strong>成员方法</strong>: <code>addActionListener(ActionListener l)</code>, <code>setColumns(int columns)</code>, <code>setText(String text)</code>。</li></ul><h4 id="其他常用组件">其他常用组件</h4><ul><li><strong><code>JTextArea</code></strong>: 提供多行文本编辑功能。</li><li><strong><code>JCheckBox</code></strong>: 复选框。</li><li><strong><code>JRadioButton</code></strong>: 单选按钮，常与 <code>ButtonGroup</code> 配合使用。</li><li><strong><code>JComboBox</code></strong>: 组合框（下拉列表）。</li><li><strong><code>JDialog</code></strong>: 对话框，可设置模式（应用程序只能响应对话框内事件）或非模式（可响应其他窗口事件）。</li><li><strong><code>JFileChooser</code></strong>: 文件对话框，用于打开或存储文件。</li><li><strong><code>JMenuBar</code>, <code>JMenu</code>, <code>JMenuItem</code></strong>: 用于创建菜单栏、菜单和菜单项。</li></ul><h3 id="布局管理">布局管理</h3><p>当向窗口中放置组件时，需要指定组件放置策略。</p><p>Java 中有两种定位组件的方法：</p><ul><li><p><strong>硬编码</strong>: 屏幕绝对位置，与机器相关。</p></li><li><p><strong>软编码</strong>: 布局管理器，与机器无关。</p><ul><li><p>Java 布局管理器类存在于</p><p><code>java.awt</code> 包中。</p></li><li><p>在 <code>Container</code> 中有一个 <code>setLayout()</code> 方法，可以选择不同的布局方式。</p></li></ul></li></ul><h4 id="FlowLayout-（顺序布局）"><code>FlowLayout</code> （顺序布局）</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.FlowLayout</code>。</li><li><strong>构造方法</strong>: <code>public FlowLayout()</code>, <code>public FlowLayout(int align)</code>, <code>public FlowLayout(int align, int hGap, int vGap)</code>。</li><li><strong>成员属性</strong>: <code>LEFT</code>, <code>CENTER</code>, <code>RIGHT</code>。</li><li><strong>特点</strong>: 将组件从左到右放置，直到占满上方空间，再向下移动一行继续放置。所有组件将被压缩到它们的最小尺寸，按“合适”的大小呈现。</li></ul><h4 id="BorderLayout-（边界布局）"><code>BorderLayout</code> （边界布局）</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.BorderLayout</code>。</li><li><strong>构造方法</strong>: <code>public BorderLayout()</code>, <code>public BorderLayout(int hGap, int vGap)</code>。</li><li><strong>成员属性</strong>: <code>NORTH</code>, <code>SOUTH</code>, <code>EAST</code>, <code>WEST</code>, <code>CENTER</code>。</li><li><strong>特点</strong>: 将组件分置五个区域：北、南、东、西、中。<code>BorderLayout</code> 是 <code>JFrame</code> 的默认布局。</li><li>使用 <code>add()</code> 方法时，第一个参数可以指定区域，如 <code>BorderLayout.NORTH</code>。 未指定区域的组件将放置在中央并拉伸。</li></ul><h4 id="GridLayout-网格布局">GridLayout (网格布局)</h4><ul><li><strong>继承关系</strong>: <code>java.lang.Object</code> -&gt; <code>java.awt.GridLayout</code>。</li><li><strong>构造方法</strong>: <code>public GridLayout()</code>, <code>public GridLayout(int rows, int columns)</code>, <code>public GridLayout(int rows, int columns, int hGap, int vGap)</code>。</li><li><strong>特点</strong>: 在网格里从左到右、从上到下布局。确定行列数后，组件将以相同的长宽比排列。</li></ul><h3 id="事件处理">事件处理</h3><h4 id="事件处理机制">事件处理机制</h4><p>要让图形界面接收用户的操作，必须为组件添加事件处理机制。</p><p>事件处理主要涉及三类对象：</p><ol><li><p><strong>Event (事件)</strong>: 用户对界面操作在 Java 语言上的描述，以类的形式出现。例如键盘操作对应的事件类是 <code>KeyEvent</code>。</p></li><li><p><strong>Event Source (事件源)</strong>: 事件发生的场所，通常是各个组件，例如按钮 <code>JButton</code>。</p></li><li><p><strong>Event Handler (事件处理者)</strong>: 接收事件对象并对其进行处理的对象，也称为事件监听器 (<code>Listener</code>)。</p><hr></li></ol><p><strong>事件响应过程</strong>:</p><ol><li>组件（事件源）触发相应类型的事件。</li><li>生成事件对象。</li><li>把事件对象传入事件处理器。</li><li>事件由相应类型的 <code>Listener</code>（事件监听器）接收并处理。<ul><li><strong>实现事件监听器的方式</strong>:<ul><li><strong>内部类实现监听器方式</strong>：定义一个独立的内部类实现监听器接口，并在组件中注册该内部类的对象。</li><li><strong>匿名内部类实现监听器方式</strong>：直接在 <code>addActionListener()</code> 方法中定义并实例化一个匿名内部类来实现监听器接口。</li><li><strong>直接实现监听器方式</strong>：主类直接实现监听器接口，然后将 <code>this</code> 关键字作为监听器对象注册到组件中。</li></ul></li></ul></li></ol><h4 id="事件类与事件监听接口">事件类与事件监听接口</h4><ul><li>Java 使用 <code>AWTEvent</code> 类表示事件，其继承关系为 <code>java.lang.Object</code> -&gt; <code>java.util.EventObject</code> -&gt; <code>java.awt.AWTEvent</code>。</li><li>各种事件类别对应不同的监听器接口和方法：<ul><li><code>ActionEvent</code>: <code>ActionListener</code> ( <code>actionPerformed</code> )</li><li><code>ItemEvent</code>: <code>ItemListener</code> ( <code>itemStateChanged</code> )</li><li><code>MouseEvent</code>: <code>MouseListener</code> ( <code>mousePressed</code>, <code>mouseReleased</code>, <code>mouseEntered</code>, <code>mouseExited</code>, <code>mouseClicked</code> )</li><li><code>MouseEvent</code> (移动): <code>MouseMotionListener</code> ( <code>mouseDragged</code>, <code>mouseMoved</code> )</li><li><code>KeyEvent</code>: <code>KeyListener</code> ( <code>keyPressed</code>, <code>keyReleased</code>, <code>keyTyped</code> )</li><li><code>FocusEvent</code>: <code>FocusListener</code> ( <code>focusGained</code>, <code>focusLost</code> )</li><li><code>AdjustmentEvent</code>: <code>AdjustmentListener</code> ( <code>adjustmentValueChanged</code> )</li><li><code>ComponentEvent</code>: <code>ComponentListener</code> ( <code>componentMoved</code>, <code>componentHidden</code>, <code>componentResized</code>, <code>componentShown</code> )</li><li><code>WindowEvent</code>: <code>WindowListener</code> ( <code>windowClosing</code>, <code>windowOpened</code>, <code>windowIconified</code>, <code>windowDeiconified</code>, <code>windowClosed</code>, <code>windowActivated</code>, <code>windowDeactivated</code> )</li><li><code>ContainerEvent</code>: <code>ContainerListener</code> ( <code>componentAdded</code>, <code>componentRemoved</code> )</li><li><code>TextEvent</code>: <code>TextListener</code> ( <code>textValueChanged</code> )</li></ul></li></ul><h4 id="适配器类-Adapter">适配器类 (<code>Adapter</code>)</h4><p>每个具有不止一个方法的 AWT 监听器接口都有一个实现了其所有方法但</p><p><strong>不做任何工作</strong>的适配器类。</p><p>可以通过<strong>继承适配器类</strong>来只重写需要的方法，避免实现接口中所有的方法。</p><p><code>java.awt.event</code> 包中定义的事件适配器类包括：</p><ul><li><code>ComponentAdapter</code></li><li><code>ContainerAdapter</code></li><li><code>FocusAdapter</code></li><li><code>KeyAdapter</code></li><li><code>MouseAdapter</code> (示例显示其实现了 <code>mouseClicked</code> 等空方法)</li><li><code>MouseMotionAdapter</code></li><li><code>WindowAdapter</code></li></ul><h2 id="I-O-流">I/O 流</h2><p><strong>I/O (Input/Output)</strong> 指计算机与外部世界进行数据交换的过程，例如从键盘读取数据、向屏幕输出信息、读写文件、网络通信等。</p><p>**流 (Stream) **是 Java 语言输入/输出的方式， Java 程序通过流来完成输入/输出工作。是一个想象中的无限长的数据序列。 Java 提供了各种各样的流类来实现 I/O，封装了数据处理的细节.</p><p><strong>流的分类</strong>:</p><ul><li><strong>按数据流向</strong>：<ul><li><strong>输入流 (InputStream/Reader)</strong>： 从数据源读取数据到程序中。</li><li><strong>输出流 (OutputStream/Writer)</strong>： 从程序中写入数据到数据目的地。</li></ul></li><li><strong>按处理数据单位</strong>：<ul><li><strong>字节流 (Byte Stream)</strong>: 以字节（8位）为单位处理数据，适用于所有类型的数据（如图片、视频、文本等）。</li><li><strong>字符流 (Character Stream)</strong>: 以字符（16位 Unicode 字符）为单位处理数据，专门用于处理文本数据，可以避免编码问题。</li></ul></li><li><strong>按功能</strong>：<ul><li><strong>节点流 (Node Stream)</strong>: 直接与数据源（如文件、内存数组、管道）连接，提供基本的读写功能。</li><li><strong>处理流 / 包装流 (Processing Stream / Wrapper Stream)</strong>: 包装在其他流之上，修改或管理流中数据，提供额外的功能（如缓冲、数据转换、对象序列化、打印等）。</li></ul></li></ul><hr><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字节流</th><th style="text-align:center">字符流</th></tr></thead><tbody><tr><td style="text-align:center">输入流（读）</td><td style="text-align:center"><code>InputStream</code> 及其子类</td><td style="text-align:center"><code>Reader</code> 及其子类</td></tr><tr><td style="text-align:center">输出流（写）</td><td style="text-align:center"><code>OutputStream</code> 及其子类</td><td style="text-align:center"><code>Writer</code> 及其子类</td></tr></tbody></table><p>常见的 I/O 流类：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字节流类</th><th style="text-align:center">字符流类</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>文件输入</strong></td><td style="text-align:center"><code>FileInputStream</code></td><td style="text-align:center"><code>FileReader</code></td><td style="text-align:center">从文件中读取</td></tr><tr><td style="text-align:center"><strong>文件输出</strong></td><td style="text-align:center"><code>FileOutputStream</code></td><td style="text-align:center"><code>FileWriter</code></td><td style="text-align:center">写入文件</td></tr><tr><td style="text-align:center"><strong>缓冲输入</strong></td><td style="text-align:center"><code>BufferedInputStream</code></td><td style="text-align:center"><code>BufferedReader</code></td><td style="text-align:center">提高读性能，支持按行读取</td></tr><tr><td style="text-align:center"><strong>缓冲输出</strong></td><td style="text-align:center"><code>BufferedOutputStream</code></td><td style="text-align:center"><code>BufferedWriter</code></td><td style="text-align:center">提高写性能</td></tr><tr><td style="text-align:center">转换流</td><td style="text-align:center">—</td><td style="text-align:center"><code>InputStreamReader</code> / <code>OutputStreamWriter</code></td><td style="text-align:center">将字节流转为字符流</td></tr><tr><td style="text-align:center"><strong>数据流</strong></td><td style="text-align:center"><code>DataInputStream</code></td><td style="text-align:center">—</td><td style="text-align:center">读写 Java 原始类型（如 <code>int</code>, <code>double</code>）</td></tr><tr><td style="text-align:center">打印流</td><td style="text-align:center"><code>PrintStream</code></td><td style="text-align:center"><code>PrintWriter</code></td><td style="text-align:center">方便格式化输出</td></tr><tr><td style="text-align:center"><strong>对象流</strong></td><td style="text-align:center"><code>ObjectInputStream</code></td><td style="text-align:center">—</td><td style="text-align:center">对象序列化与反序列化</td></tr><tr><td style="text-align:center"><strong>标准流</strong></td><td style="text-align:center"><code>System.in</code></td><td style="text-align:center">—</td><td style="text-align:center">控制台输入（字节流）</td></tr></tbody></table><h4 id="文件-I-O">文件 I/O</h4><p><strong>文件存储格式</strong>：</p><ul><li><p>文件可以看作一系列字节的集合。</p></li><li><p>无论是字符 I/O 还是字节 I/O，最终文件中存储的都是这些字符的编码（字节序列）。</p></li><li><p>字符 I/O 程序：处理字符的统一码，进行编码/解码，文件中存储的是字符的编码（如 UTF-8, GBK 等）。</p></li><li><p>字节 I/O 程序：直接读写字节，文件中存储的是等价的字节数据。</p></li></ul><hr><p><strong><code>File</code> 类</strong>:</p><ul><li><code>java.io.File</code>：文件和目录路径名的抽象表示形式，用于获取文件或目录的信息.</li><li><strong>构造器</strong>:<ul><li><code>public File(String pathname)</code>: 以 <code>pathname</code> 为路径创建 <code>File</code> 对象，如果为相对路径则在默认的当前路径下存储.</li><li><code>public File(String parent, String child)</code>: 以 <code>parent</code> 为父路径，<code>child</code> 为子路径创建 <code>File</code> 对象.</li></ul></li><li><strong>常用方法</strong>:<ul><li><code>boolean canRead()</code>: 判断是否可读.</li><li><code>boolean canWrite()</code>: 判断是否可写.</li><li><code>boolean exists()</code>: 判断文件或目录是否存在.</li><li><code>boolean isDirectory()</code>: 判断是否是目录.</li><li><code>boolean isFile()</code>: 判断是否是文件.</li><li><code>boolean isHidden()</code>: 判断是否是隐藏文件.</li><li><code>long lastModified()</code>: 返回最后修改时间.</li><li><code>long length()</code>: 返回文件长度（字节数）.</li><li><code>String getName()</code>: 返回文件或目录名.</li><li><code>String getPath()</code>: 返回文件或目录的路径名字符串.</li><li><code>String getAbsolutePath()</code>: 返回文件的绝对路径名字符串.</li><li><code>boolean createNewFile()</code>: 创建新文件.</li><li><code>boolean delete()</code>: 删除文件或目录.</li><li><code>boolean mkdir()</code>: 创建单级目录.</li><li><code>boolean mkdirs()</code>: 创建多级目录.</li><li><code>File getParentFile()</code>: 返回父目录的 <code>File</code> 对象.</li><li><code>String[] list()</code>: 列出目录下的文件和目录名.</li><li><code>File[] listFiles()</code>: 返回目录下的 <code>File</code> 对象数组.</li></ul></li></ul><h4 id="流与相关类">流与相关类</h4><ul><li><p><strong>字节流类层次结构</strong>:</p><ul><li><p><strong><code>InputStream</code> (抽象基类)</strong>: 所有字节输入流的父类.</p><ul><li><p><code>int read()</code>: 读取一个字节并以整数形式返回.</p></li><li><p><code>int read(byte[] buffer)</code>: 读取一系列字节到数组 <code>buffer</code> 中，返回读取的字节数.</p></li><li><p><code>int read(byte[] buffer, int offset, int length)</code>: 从 <code>offset</code> 位置开始存储到 <code>buffer</code> 中.</p></li><li><p><code>void close()</code>: 关闭流，释放内存资源.</p></li><li><p><code>long skip(long n)</code>: 跳过 <code>n</code> 个字节.</p></li><li><p><strong>主要子类 (节点流)</strong>:</p><ul><li><code>FileInputStream</code>: 从文件中读取信息.</li><li><code>ByteArrayInputStream</code>: 将内存的缓冲区当作 <code>InputStream</code> 使用.</li><li><code>PipedInputStream</code>: 产生用于写入相关 <code>PipedOutputStream</code> 的数据，实现“管道化”.</li><li><code>SequenceInputStream</code>: 将两个或多个 <code>InputStream</code> 对象转换成单一 <code>InputStream</code>.</li><li><code>StringBufferInputStream</code> (已弃用): 将 <code>String</code> 转换成 <code>InputStream</code>.</li></ul></li><li><p><strong>处理流 (<code>FilterInputStream</code> 的子类)</strong>:</p><ul><li><code>DataInputStream</code>: 与 <code>DataOutputStream</code> 搭配使用，可以可移植方式从流读取基本数据类型 (<code>int</code>, <code>char</code>, <code>long</code> 等).</li><li><code>BufferedInputStream</code>: 使用缓冲区，防止每次读取都进行实际的读操作，提高效率.</li><li><code>LineNumberInputStream</code>: 跟踪输入流中的行号.</li><li><code>PushbackInputStream</code>: 具有一个字节的回退缓冲区，可以将读到的最后一个字符回退.</li><li><code>ObjectInputStream</code>: 用于读取对象，也可以处理基本数据类型.</li></ul></li></ul></li><li><p><strong><code>OutputStream</code> (抽象基类)</strong>: 所有字节输出流的父类.</p><ul><li><strong>常用方法</strong> (可能抛出 <code>IOException</code>):<ul><li><code>void write(int b)</code>: 写入一个字节.</li><li><code>void write(byte[] b)</code>: 写入字节数组.</li><li><code>void write(byte[] b, int off, int len)</code>: 写入字节数组的一部分.</li><li><code>void close()</code>: 关闭流.</li><li><code>void flush()</code>: 刷新缓冲区，强制写入数据.</li></ul></li><li><strong>主要子类 (节点流)</strong>:<ul><li><code>FileOutputStream</code>: 用于向文件中写入信息.</li><li><code>ByteArrayOutputStream</code>: 将数据写入内存缓冲区.</li><li><code>PipedOutputStream</code>: 写入数据到相关 <code>PipedInputStream</code>.</li></ul></li><li><strong>处理流 (<code>FilterOutputStream</code> 的子类)</strong>:<ul><li><code>DataOutputStream</code>: 与 <code>DataInputStream</code> 搭配使用，可移植地向流写入基本数据类型.</li><li><code>BufferedOutputStream</code>: 使用缓冲区，提高写入效率.</li><li><code>PrintStream</code>: 打印流，为其他输出流添加打印各种数据值表示形式的功能，不抛出 <code>IOException</code>，自动刷新.</li><li><code>ObjectOutputStream</code>: 用于写入对象.</li></ul></li></ul></li></ul></li><li><p><strong>字符流类层次结构</strong>:</p><ul><li><p><strong><code>Reader</code> (抽象基类)</strong>: 所有字符输入流的父类.</p><ul><li><p><strong>常用方法</strong> (可能抛出 <code>IOException</code>): <code>int read()</code>, <code>int read(char[] cbuf)</code>, <code>int read(char[] cbuf, int offset, int length)</code>, <code>void close()</code>, <code>long skip(long n)</code>.</p></li><li><p><strong>主要子类 (节点流)</strong>:</p><p><code>FileReader</code> (文件), <code>CharArrayReader</code> (内存字符数组), <code>StringReader</code> (内存字符串), <code>PipedReader</code> (管道).</p></li><li><p><strong>处理流 (<code>FilterReader</code> 的子类 或 其他)</strong>:</p><p><code>BufferedReader</code> (缓冲), <code>LineNumberReader</code> (行号), <code>PushbackReader</code> (回退), <code>InputStreamReader</code> (字节到字符的转换流).</p></li></ul></li><li><p><strong><code>Writer</code> (抽象基类)</strong>: 所有字符输出流的父类.</p><ul><li><p><strong>常用方法</strong> (可能抛出 <code>IOException</code>):</p><p><code>void write(int c)</code>, <code>void write(char[] cbuf)</code>, <code>void write(char[] cbuf, int offset, int length)</code>, <code>void write(String string)</code>, <code>void write(String string, int offset, int length)</code>, <code>void close()</code>, <code>void flush()</code>.</p></li><li><p><strong>主要子类 (节点流)</strong>:</p><p><code>FileWriter</code> (文件), <code>CharArrayWriter</code> (内存字符数组), <code>StringWriter</code> (内存字符串), <code>PipedWriter</code> (管道).</p></li><li><p><strong>处理流 (<code>FilterWriter</code> 的子类 或 其他)</strong>:</p><p><code>BufferedWriter</code> (缓冲), <code>PrintWriter</code> (打印流), <code>OutputStreamWriter</code> (字符到字节的转换流).</p></li></ul></li></ul></li><li><p><strong>特殊流类型</strong>:</p><ul><li><p><strong><code>DataInputStream</code> / <code>DataOutputStream</code></strong>: 用于对已经存在的输入/输出流进行包装，以便在原始流中过滤数据。支持原始数据类型（<code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>）的输入输出，与机器无关.</p></li><li><p><strong><code>BufferedInputStream</code> / <code>BufferedOutputStream</code></strong>: 减少读写次数，提高 I/O 效率，通过在高速设备和低速设备之间使用缓冲区实现。缓冲区默认大小为 512 字节。当缓冲满或调用 <code>flush</code> 方法时，数据写入.</p><ul><li><p><strong>常用方法</strong> (仅 <code>BufferedReader</code>/<code>BufferedWriter</code>):</p><p><code>readLine()</code> (读取一行), <code>newLine()</code> (写入行分隔符), <code>mark()</code>, <code>reset()</code>.</p></li></ul></li><li><p><strong><code>ObjectInputStream</code> / <code>ObjectOutputStream</code></strong>: 支持对象的输入输出，像数据流一样支持对象的输入输出。可序列化对象实现了 <code>java.io.Serializable</code> 接口。<code>Serializable</code> 是一个标记性接口，没有方法，实现它可启动 Java 序列化机制.</p><ul><li>读取对象时，必须与写入时的类型顺序一致.</li><li>要使用读回的对象，必须使用 Java 安全类型转换.</li><li>数组也可以被序列化.</li></ul></li><li><p><strong><code>PrintStream</code> / <code>PrintWriter</code></strong>: 为其他输出流添加了方便地打印各种数据值表示形式的功能。分别针对字节和字符，提供重载的 <code>print</code> 和 <code>println</code> 方法。特点是不抛出 <code>IOException</code>，自动刷新.</p></li></ul></li></ul><h4 id="标准-I-O-流">标准 I/O 流</h4><p><strong>三个标准 I/O 流</strong>:</p><ul><li><p><code>System.in</code>: <code>InputStream</code> 类的对象实例 <code>in</code> 作为标准输入流对象，对应于键盘输入.</p></li><li><p><code>System.out</code>: <code>PrintStream</code> 类的对象实例 <code>out</code> 作为标准输出流对象，对应于显示器输出.</p></li><li><p><code>System.err</code>: <code>PrintStream</code> 类的对象实例 <code>err</code> 作为标准错误输出流对象，对应于显示器输出.</p></li><li><p>标准 I/O 流可以被重定向到文件或其他流，实现文件复制等功能。</p></li></ul><h4 id="随机访问文件-RandomAccessFile">随机访问文件 (<code>RandomAccessFile</code>)</h4><p><code>RandomAccessFile</code>: 适用于由大小已知的记录组成的文件，可以使用 <code>seek()</code> 将记录从一处转移到另一处.</p><p>它不是继承自 <code>InputStream</code> 和 <code>OutputStream</code>，而是像 <code>DataInputStream</code> 和 <code>DataOutputStream</code> 一样实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口.</p><ul><li><p>类似于把 <code>DataInputStream</code> 和 <code>DataOutputStream</code> 结合在一起使用.</p></li><li><p>只有 <code>RandomAccessFile</code> 类在文件上支持搜寻（<code>seek()</code>）方法.</p></li><li><p><strong>构造器</strong>:</p><p><code>RandomAccessFile(File file, String mode)</code>, <code>RandomAccessFile(String name, String mode)</code>.</p></li><li><p><strong>常用方法</strong>:</p><ul><li><code>void seek(long pos)</code>: 用于文件内移至新位置.</li><li><code>long getFilePointer()</code>: 得到当前位置.</li><li><code>long length()</code>: 判断文件大小.</li></ul></li></ul><p>压缩流</p><p><strong><code>ZipOutputStream</code> / <code>GZIPOutputStream</code></strong>: 压缩数据，生成 Zip 或 GZip 格式文件.</p><p><strong><code>ZipInputStream</code> / <code>GZIPInputStream</code></strong>: 解压缩已经生成的 Zip 或 GZip 文件.</p><p>它们继承于 <code>InputStream</code> 和 <code>OutputStream</code>.</p><h4 id="Scanner-类"><code>Scanner</code> 类</h4><p><code>java.util.Scanner</code>: Java 5 添加的类，用于从各种输入源（如 <code>System.in</code>、文件、字符串）解析基本类型和字符串。</p><p>支持使用<strong>正则表达式</strong>来检索、替换那些符合某个模式（规则）的文本。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>next()</code></td><td style="text-align:center">读取下一个单词（以空格为界）</td></tr><tr><td style="text-align:center"><code>nextLine()</code></td><td style="text-align:center">读取整行</td></tr><tr><td style="text-align:center"><code>nextInt()</code> / <code>nextDouble()</code></td><td style="text-align:center">读取指定类型</td></tr><tr><td style="text-align:center"><code>hasNext()</code> / <code>hasNextInt()</code></td><td style="text-align:center">判断是否还有下一个输入</td></tr><tr><td style="text-align:center"><code>useDelimiter()</code></td><td style="text-align:center">自定义分隔符（如读取 CSV）</td></tr></tbody></table><h2 id="并发">并发</h2><p>实现并发有两种方法：</p><ul><li><strong>继承 <code>Thread</code> 类</strong>，重写 <code>run</code> 方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>    <span class="hljs-keyword">private</span> String threadName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String threadName)</span> {<br>        <span class="hljs-built_in">this</span>.threadName = threadName;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 线程执行的逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {<br>            System.out.println(threadName + <span class="hljs-string">" --- "</span> + i);<br>        }<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">"Thread-1"</span>);<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">"Thread-2"</span>);<br>        t1.start(); <span class="hljs-comment">// 启动线程，JVM 调用 run 方法</span><br>        t2.start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>实现 <code>Runnable</code> 接口</strong>，重写 <code>run</code> 方法，并创建 <code>Thread</code> 对象</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {<br>    <span class="hljs-keyword">private</span> String threadName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(String threadName)</span> {<br>        <span class="hljs-built_in">this</span>.threadName = threadName;<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 线程执行的逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {<br>            System.out.println(threadName + <span class="hljs-string">" --- "</span> + i);<br>        }<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-string">"Runnable-1"</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-string">"Runnable-2"</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1).start(); <span class="hljs-comment">// 将 Runnable 实例包装到 Thread 对象中</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r2).start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>线程生命周期</strong>:</p><ul><li><strong>Born state / New Thread (出生)</strong>：线程对象被创建但尚未启动。</li><li><strong>Ready state / Runnable Thread (就绪)</strong>：线程调用 <code>start()</code> 方法后进入此状态，等待 CPU 调度。</li><li><strong>Running state (运行)</strong>：线程获得 CPU 时间片，正在执行 <code>run()</code> 方法中的代码。</li><li><strong>Sleeping state (休眠)</strong>：线程调用 <code>Thread.sleep()</code> 方法后进入此状态，暂停执行指定时间，时间结束后进入就绪态。</li><li><strong>Waiting state (等待)</strong>：线程调用 <code>Object.wait()</code> 或 <code>Thread.join()</code> 等方法后进入此状态，等待其他线程的特定通知或完成。</li><li><strong>Blocked state (阻塞)</strong>：线程试图获取一个被其他线程持有的 <code>synchronized</code> 锁时进入此状态。</li><li><strong>Dead state (死亡)</strong>：线程的 <code>run()</code> 方法执行完毕或因未捕获的异常而终止。</li></ul><hr><p>Java 线程优先级由操作系统实现。</p><ul><li>分为 <strong>1 到 10 级</strong>（<code>Thread.MIN_PRIORITY</code> 到 <code>Thread.MAX_PRIORITY</code>），默认是 5 (<code>Thread.NORM_PRIORITY</code>)。</li><li><code>setPriority(int newPriority)</code>: 设置线程优先级。</li><li>线程组调度依赖于宿主系统的调度算法，优先级设置的复杂性。Java 线程优先级只是给操作系统的一个提示，具体调度由操作系统决定。</li></ul><h3 id="同步">同步</h3><p>Java 提供了 <strong><code>synchronized</code> 关键字</strong>作为最基本的同步机制。每个 Java 对象都可以作为一个<strong>监视器锁</strong> (monitor lock)。</p><p>当一个线程进入 <code>synchronized</code> 代码块或方法时，它会尝试获取该对象的锁。如果锁已经被其他线程持有，当前线程就会被阻塞，直到锁被释放。</p><ul><li><strong><code>synchronized</code> 方法</strong></li><li><strong><code>synchronized</code> 块</strong></li></ul><h3 id="协作">协作</h3><p>除了简单的同步访问共享资源，线程有时还需要<strong>相互协调</strong>，即一个线程等待某个条件满足，而另一个线程负责满足条件并通知等待的线程。Java 的 <code>Object</code> 类提供了 <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 方法来实现这种协作。</p><ul><li><strong><code>wait()</code></strong>:<ul><li><strong>作用</strong>: 使当前线程<strong>释放它所持有的对象锁</strong> ，并进入该对象的<strong>等待池</strong>（或称等待队列），从而暂停执行。</li><li><strong>调用时机</strong>: 必须在 <code>synchronized</code> 块或方法中调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li><li><strong>唤醒</strong>: 线程会一直等待，直到被 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒，或者达到超时时间 (<code>wait(long timeout)</code>)，或者被中断 (<code>InterruptedException</code>)。</li><li><strong>虚假唤醒 (Spurious Wakeup)</strong>: 线程有可能在没有被 <code>notify()</code> 或 <code>notifyAll()</code> 明确通知的情况下被唤醒。因此，等待的条件<strong>必须用 <code>while</code> 循环进行检查</strong>，而不是 <code>if</code> 语句 。</li></ul></li><li><strong><code>notify()</code></strong>:<ul><li><strong>作用</strong>: 唤醒在该对象上等待的<strong>一个</strong>任意线程（JVM 决定唤醒哪个）。被唤醒的线程会尝试重新获取对象锁，然后从 <code>wait()</code> 暂停的地方继续执行。</li><li><strong>调用时机</strong>: 必须在 <code>synchronized</code> 块或方法中调用。</li></ul></li><li><strong><code>notifyAll()</code></strong>:<ul><li><strong>作用</strong>: 唤醒在该对象上等待的<strong>所有</strong>线程。所有被唤醒的线程都会竞争对象锁。</li><li><strong>调用时机</strong>: 必须在 <code>synchronized</code> 块或方法中调用。</li><li><strong>建议</strong>: 鉴于虚假唤醒和条件竞争的复杂性，通常建议使用 <code>notifyAll()</code> 而非 <code>notify()</code>，以确保所有相关线程都有机会重新检查条件并继续执行 。</li></ul></li></ul><hr><h4 id="volatile-关键字"><code>volatile</code> 关键字</h4><p><code>volatile</code> 关键字典型的应用是作为<strong>状态标志</strong>或<strong>开关</strong>。</p><ol><li><strong>保证可见性</strong> (Visibility)<ul><li>在多核处理器系统中，每个 CPU 都可能有自己的高速缓存 (cache) 。当一个线程修改了一个共享变量时，它可能只修改了自己 CPU 缓存中的副本，而没有立即写入主内存 (main memory) 。其他线程在读取同一个变量时，可能仍然从自己的旧缓存中读取，从而看不到最新的修改。</li><li><code>volatile</code> 关键字的作用是强制对变量的所有修改都立即从 CPU 缓存写入到主内存中，并且强制对该变量的所有读取都直接从主内存中进行，而不是从线程的本地缓存中读取 。这确保了当一个线程修改了 <code>volatile</code> 变量的值，其他线程能够立即看到最新的值。</li></ul></li><li><strong>保证有序性</strong> (Ordering) ，禁止指令重排序<ul><li>为了提高性能，编译器和处理器可能会对指令进行重排序。例如，在一个线程中，如果代码是 <code>operation1(); volatileVariable = true; operation2();</code>，在没有 <code>volatile</code> 的情况下，<code>operation1()</code> 和 <code>operation2()</code> 可能会被重排序到 <code>volatileVariable = true;</code> 之前或之后执行，只要它们之间没有数据依赖。</li><li><code>volatile</code> 关键字会禁止对其前后代码的<strong>指令重排序</strong>。具体来说，当一个变量被声明为 <code>volatile</code> 后，读操作不能被重排序到写操作之后，写操作不能被重排序到读操作之前 。这确保了在写入 <code>volatile</code> 变量之前的所有操作都已完成，并且在读取 <code>volatile</code> 变量之后的所有操作都能看到最新的值。</li></ul></li></ol><p><code>volatile</code> <strong>不保证原子性</strong>，只能保证可见性和有序性。这意味着对于复合操作（如 <code>i++</code>，它实际上是读-改-写三个步骤），即使变量是 <code>volatile</code> 的，仍然可能出现竞态条件和数据不一致问题。</p><h2 id="网络编程">网络编程</h2><h3 id="TCP">TCP</h3><p>服务端：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.DataOutputStream; <span class="hljs-comment">// 用于发送数据 [cite: 339]</span><br><span class="hljs-keyword">import</span> java.io.IOException;     <span class="hljs-comment">// 处理 I/O 异常 [cite: 333]</span><br><span class="hljs-keyword">import</span> java.net.ServerSocket;   <span class="hljs-comment">// 服务器 Socket 类 [cite: 333]</span><br><span class="hljs-keyword">import</span> java.net.Socket;         <span class="hljs-comment">// 客户端 Socket 类 [cite: 334]</span><br><span class="hljs-keyword">import</span> java.io.BufferedOutputStream; <span class="hljs-comment">// 用于提高写入效率</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleTCPServer</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8081</span>; <span class="hljs-comment">// 服务器监听端口 [cite: 338]</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 服务器套接字 [cite: 333]</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;     <span class="hljs-comment">// 客户端套接字 [cite: 334]</span><br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 1. 创建 ServerSocket 对象，指定服务端口 [cite: 338]</span><br>            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>            System.out.println(<span class="hljs-string">"服务器已启动，正在监听端口 "</span> + port + <span class="hljs-string">"..."</span>);<br><br>            <span class="hljs-comment">// 2. 接受客户端的连接，此方法会阻塞直到有客户端连接 [cite: 333]</span><br>            clientSocket = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">"服务端接受连接! 客户端地址: "</span> + clientSocket.getInetAddress().getHostAddress()); [cite: <span class="hljs-number">339</span>]<br><br>            <span class="hljs-comment">// 3. 获取输出流并发送数据 [cite: 334]</span><br>            <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(clientSocket.getOutputStream()));<br>            dos.writeUTF(<span class="hljs-string">"你好!我是服务端!"</span>); <span class="hljs-comment">// 发送 UTF 字符串 [cite: 339]</span><br>            dos.flush(); <span class="hljs-comment">// 刷新缓冲区，确保数据发送 [cite: 339]</span><br>            System.out.println(<span class="hljs-string">"服务端已发送消息。"</span>);<br><br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"服务器发生 I/O 错误: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 4. 关闭连接和流，释放资源 [cite: 333, 334]</span><br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">if</span> (clientSocket != <span class="hljs-literal">null</span>) clientSocket.close();<br>                <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-literal">null</span>) serverSocket.close();<br>                System.out.println(<span class="hljs-string">"服务器连接已关闭。"</span>);<br>            } <span class="hljs-keyword">catch</span> (IOException e) {<br>                System.err.println(<span class="hljs-string">"关闭资源时发生错误: "</span> + e.getMessage());<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>客户端：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream; <span class="hljs-comment">// 用于提高读取效率</span><br><span class="hljs-keyword">import</span> java.io.DataInputStream;     <span class="hljs-comment">// 用于接收数据 [cite: 340]</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.Socket;             <span class="hljs-comment">// 客户端 Socket 类 [cite: 334]</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleTCPClient</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">"localhost"</span>; <span class="hljs-comment">// 服务器地址 [cite: 340]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">serverPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">8081</span>;             <span class="hljs-comment">// 服务器端口 [cite: 340]</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 客户端套接字 [cite: 334]</span><br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 1. 创建 Socket 对象，连接到服务器 [cite: 337]</span><br>            clientSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(serverAddress, serverPort);<br>            System.out.println(<span class="hljs-string">"客户端已连接到服务器 "</span> + serverAddress + <span class="hljs-string">":"</span> + serverPort);<br><br>            <span class="hljs-comment">// 2. 获取输入流并接收数据 [cite: 337]</span><br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(clientSocket.getInputStream()));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> dis.readUTF(); <span class="hljs-comment">// 接收 UTF 字符串 [cite: 340]</span><br>            System.out.println(<span class="hljs-string">"客户端收到消息: "</span> + message);<br><br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"客户端发生 I/O 错误: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 3. 关闭连接和流，释放资源 [cite: 337]</span><br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">if</span> (clientSocket != <span class="hljs-literal">null</span>) clientSocket.close();<br>                System.out.println(<span class="hljs-string">"客户端连接已关闭。"</span>);<br>            } <span class="hljs-keyword">catch</span> (IOException e) {<br>                System.err.println(<span class="hljs-string">"关闭资源时发生错误: "</span> + e.getMessage());<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="UDP">UDP</h3><p>Sender:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream; <span class="hljs-comment">// 用于将字符串转换为字节数组</span><br><span class="hljs-keyword">import</span> java.io.DataOutputStream;     <span class="hljs-comment">// 用于将字符串写入字节流</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;      <span class="hljs-comment">// UDP 数据报包 [cite: 362]</span><br><span class="hljs-keyword">import</span> java.net.DatagramSocket;      <span class="hljs-comment">// UDP 套接字 [cite: 361]</span><br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;   <span class="hljs-comment">// IP 地址和端口的组合</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleUDPSender</span> {<br><br>    <span class="hljs-comment">// 辅助方法：将字符串转换为字节数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] convertStringToBytes(String str) <span class="hljs-keyword">throws</span> IOException { [cite: <span class="hljs-number">378</span>]<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(bos);<br>        dos.writeUTF(str); <span class="hljs-comment">// 写入 UTF 字符串</span><br>        dos.flush();<br>        <span class="hljs-type">byte</span>[] data = bos.toByteArray();<br>        dos.close();<br>        <span class="hljs-keyword">return</span> data;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// UDP 套接字 [cite: 376]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">"哈哈哈!"</span>; <span class="hljs-comment">// 要发送的数据 [cite: 377]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">receiverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">"localhost"</span>; <span class="hljs-comment">// 接收方地址 [cite: 377]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">receiverPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">8086</span>;             <span class="hljs-comment">// 接收方端口 [cite: 377]</span><br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 1. 创建 DatagramSocket 对象 (客户端通常无需指定端口，系统会随机分配) [cite: 376]</span><br>            clientSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br>            System.out.println(<span class="hljs-string">"UDP 发送方已启动。"</span>);<br><br>            <span class="hljs-comment">// 2. 准备要发送的数据 (转换为字节数组) [cite: 377]</span><br>            <span class="hljs-type">byte</span>[] data = convertStringToBytes(message);<br><br>            <span class="hljs-comment">// 3. 数据打包: 创建 DatagramPacket，指定数据、长度、目标地址和端口 [cite: 362, 377]</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(data, data.length,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(receiverAddress, receiverPort));<br><br>            <span class="hljs-comment">// 4. 发送数据报 [cite: 361, 378]</span><br>            clientSocket.send(packet);<br>            System.out.println(<span class="hljs-string">"UDP 发送方已发送消息: '"</span> + message + <span class="hljs-string">"' 到 "</span> + receiverAddress + <span class="hljs-string">":"</span> + receiverPort);<br><br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"UDP 发送方发生 I/O 错误: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 5. 关闭 DatagramSocket，释放资源 [cite: 378]</span><br>            <span class="hljs-keyword">if</span> (clientSocket != <span class="hljs-literal">null</span>) clientSocket.close();<br>            System.out.println(<span class="hljs-string">"UDP 发送方已关闭。"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>Receiver:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream; <span class="hljs-comment">// 用于将字节数组转换为输入流</span><br><span class="hljs-keyword">import</span> java.io.DataInputStream;     <span class="hljs-comment">// 用于从字节流中读取数据</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;      <span class="hljs-comment">// UDP 数据报包 [cite: 362]</span><br><span class="hljs-keyword">import</span> java.net.DatagramSocket;      <span class="hljs-comment">// UDP 套接字 [cite: 361]</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleUDPReceiver</span> {<br><br>    <span class="hljs-comment">// 辅助方法：将字节数组转换为字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">convertBytesToString</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> IOException { [cite: <span class="hljs-number">374</span>]<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(data);<br>        <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bais);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> dis.readUTF(); <span class="hljs-comment">// 读取 UTF 字符串</span><br>        dis.close();<br>        <span class="hljs-keyword">return</span> str;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8086</span>; <span class="hljs-comment">// 接收方监听端口 </span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// UDP 套接字 </span><br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 1. 创建 DatagramSocket 对象，并绑定到指定端口 </span><br>            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(port);<br>            System.out.println(<span class="hljs-string">"UDP 接收方已启动，正在监听端口 "</span> + port + <span class="hljs-string">"..."</span>);<br><br>            <span class="hljs-comment">// 2. 准备容器（字节数组）用于接收数据 [cite: 372]</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><br>            <span class="hljs-comment">// 3. 打包容器：创建 DatagramPacket，用于接收数据报 [cite: 372]</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>            <span class="hljs-comment">// 4. 接收数据报，此方法会阻塞直到接收到数据 [cite: 372]</span><br>            serverSocket.receive(packet);<br>            System.out.println(<span class="hljs-string">"UDP 接收方收到数据报。"</span>);<br><br>            <span class="hljs-comment">// 5. 从包里取出数据 [cite: 373]</span><br>            <span class="hljs-type">byte</span>[] receivedData = packet.getData();<br>            <span class="hljs-comment">// 6. 转换数据为字符串 [cite: 373]</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> convertBytesToString(receivedData);<br><br>            System.out.println(<span class="hljs-string">"收到消息: '"</span> + message + <span class="hljs-string">"'"</span>);<br>            System.out.println(<span class="hljs-string">"来自发送方: "</span> + packet.getAddress().getHostAddress() + <span class="hljs-string">":"</span> + packet.getPort());<br><br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            System.err.println(<span class="hljs-string">"UDP 接收方发生 I/O 错误: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 7. 关闭 DatagramSocket，释放资源</span><br>            <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-literal">null</span>) serverSocket.close();<br>            System.out.println(<span class="hljs-string">"UDP 接收方已关闭。"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="SQL">SQL</h2><h3 id="增">增</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;     <span class="hljs-comment">// 数据库连接 [cite: 61]</span><br><span class="hljs-keyword">import</span> java.sql.DriverManager;  <span class="hljs-comment">// 驱动管理器 [cite: 61]</span><br><span class="hljs-keyword">import</span> java.sql.SQLException;   <span class="hljs-comment">// SQL 异常 [cite: 61]</span><br><span class="hljs-keyword">import</span> java.sql.Statement;      <span class="hljs-comment">// SQL 语句 [cite: 61]</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DerbyCreateInsertExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// Derby 嵌入式驱动类名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-string">"org.apache.derby.jdbc.EmbeddedDriver"</span>; [cite: <span class="hljs-number">82</span>]<br>        <span class="hljs-comment">// Derby 数据库 URL，如果不存在会自动创建</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jdbc:derby:helloDB;create=true"</span>; [cite: <span class="hljs-number">83</span>]<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"user"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"password"</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 数据库连接对象 [cite: 61]</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;   <span class="hljs-comment">// SQL 语句执行对象 [cite: 61]</span><br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 1. 加载 JDBC 驱动程序 [cite: 82]</span><br>            Class.forName(driver);<br>            System.out.println(<span class="hljs-string">"驱动加载成功。"</span>);<br><br>            <span class="hljs-comment">// 2. 建立与数据库的连接 [cite: 83]</span><br>            conn = DriverManager.getConnection(url, username, password);<br>            System.out.println(<span class="hljs-string">"成功连接到数据库 helloDB。"</span>);<br><br>            <span class="hljs-comment">// 3. 创建 Statement 对象 [cite: 84]</span><br>            stmt = conn.createStatement();<br><br>            <span class="hljs-comment">// 4. 定义并执行 SQL 语句 - 创建表 [cite: 85]</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">createTableSQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"CREATE TABLE students (id INT PRIMARY KEY, name VARCHAR(50), age INT)"</span>;<br>            stmt.execute(createTableSQL); <span class="hljs-comment">// execute() 用于 DDL 语句 [cite: 85]</span><br>            System.out.println(<span class="hljs-string">"表 'students' 创建成功。"</span>);<br><br>            <span class="hljs-comment">// 5. 定义并执行 SQL 语句 - 插入数据 [cite: 86]</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">insertSQL1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"INSERT INTO students VALUES (1, 'Alice', 20)"</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">insertSQL2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"INSERT INTO students VALUES (2, 'Bob', 22)"</span>;<br>            stmt.executeUpdate(insertSQL1); <span class="hljs-comment">// executeUpdate() 用于 INSERT/UPDATE/DELETE [cite: 86]</span><br>            stmt.executeUpdate(insertSQL2);<br>            System.out.println(<span class="hljs-string">"数据插入成功。"</span>);<br><br>        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {<br>            System.err.println(<span class="hljs-string">"未找到 JDBC 驱动类: "</span> + e.getMessage());<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            System.err.println(<span class="hljs-string">"数据库操作失败: "</span> + e.getMessage());<br>            <span class="hljs-comment">// Derby 错误码 X0Y32 表示表已存在，可以忽略</span><br>            <span class="hljs-keyword">if</span> (e.getSQLState().equals(<span class="hljs-string">"X0Y32"</span>)) {<br>                System.out.println(<span class="hljs-string">"注意: 表 'students' 可能已存在，跳过创建。"</span>);<br>            } <span class="hljs-keyword">else</span> {<br>                e.printStackTrace();<br>            }<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 6. 关闭连接和流 (使用 try-with-resources 更简洁，这里为了演示手动关闭) [cite: 88]</span><br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">if</span> (stmt != <span class="hljs-literal">null</span>) stmt.close();<br>                <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) conn.close();<br>                System.out.println(<span class="hljs-string">"资源已关闭。"</span>);<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                System.err.println(<span class="hljs-string">"关闭资源时发生错误: "</span> + e.getMessage());<br>            }<br>            <span class="hljs-comment">// 对于嵌入式 Derby，通常在程序结束时需要显式关闭数据库</span><br>            <span class="hljs-keyword">try</span> {<br>                DriverManager.getConnection(<span class="hljs-string">"jdbc:derby:;shutdown=true"</span>); <span class="hljs-comment">// [cite: 89]</span><br>                System.out.println(<span class="hljs-string">"Derby 数据库已正常关闭。"</span>); <span class="hljs-comment">// [cite: 90]</span><br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                <span class="hljs-comment">// SQLSTATE 08006 表示数据库已关闭，这是正常现象 [cite: 89]</span><br>                <span class="hljs-keyword">if</span> (!e.getSQLState().equals(<span class="hljs-string">"08006"</span>)) {<br>                    System.err.println(<span class="hljs-string">"关闭 Derby 数据库时发生错误: "</span> + e.getMessage());<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="查">查</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;      <span class="hljs-comment">// 结果集 [cite: 61]</span><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DerbyQueryExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-string">"org.apache.derby.jdbc.EmbeddedDriver"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jdbc:derby:helloDB"</span>; <span class="hljs-comment">// 注意：这里不再用 create=true</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"user"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"password"</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 结果集对象 [cite: 61]</span><br><br>        <span class="hljs-keyword">try</span> {<br>            Class.forName(driver);<br>            System.out.println(<span class="hljs-string">"驱动加载成功。"</span>);<br><br>            conn = DriverManager.getConnection(url, username, password);<br>            System.out.println(<span class="hljs-string">"成功连接到数据库 helloDB。"</span>);<br><br>            stmt = conn.createStatement();<br><br>            <span class="hljs-comment">// 1. 执行 SQL 查询语句 </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">selectSQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"SELECT id, name, age FROM students ORDER BY age DESC"</span>;<br>            rs = stmt.executeQuery(selectSQL); <span class="hljs-comment">// executeQuery() 用于 SELECT </span><br><br>            System.out.println(<span class="hljs-string">"\n查询结果:"</span>);<br>            System.out.println(<span class="hljs-string">"ID\t姓名\t年龄"</span>);<br>            <span class="hljs-comment">// 2. 处理结果集 </span><br>            <span class="hljs-keyword">while</span> (rs.next()) { <span class="hljs-comment">// 遍历结果集的每一行 [cite: 70, 87]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">"id"</span>);     <span class="hljs-comment">// 根据列名获取 int 类型数据 [cite: 72]</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">"name"</span>); <span class="hljs-comment">// 根据列名获取 String 类型数据 [cite: 72]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">"age"</span>);<br>                System.out.println(id + <span class="hljs-string">"\t"</span> + name + <span class="hljs-string">"\t"</span> + age);<br>            }<br><br>        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {<br>            System.err.println(<span class="hljs-string">"未找到 JDBC 驱动类: "</span> + e.getMessage());<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            System.err.println(<span class="hljs-string">"数据库操作失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) rs.close(); <span class="hljs-comment">// 关闭 ResultSet [cite: 88]</span><br>                <span class="hljs-keyword">if</span> (stmt != <span class="hljs-literal">null</span>) stmt.close();<br>                <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) conn.close();<br>                System.out.println(<span class="hljs-string">"资源已关闭。"</span>);<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                System.err.println(<span class="hljs-string">"关闭资源时发生错误: "</span> + e.getMessage());<br>            }<br>            <span class="hljs-comment">// 关闭 Derby 数据库</span><br>            <span class="hljs-keyword">try</span> {<br>                DriverManager.getConnection(<span class="hljs-string">"jdbc:derby:;shutdown=true"</span>);<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                <span class="hljs-keyword">if</span> (!e.getSQLState().equals(<span class="hljs-string">"08006"</span>)) {<br>                    System.err.println(<span class="hljs-string">"关闭 Derby 数据库时发生错误: "</span> + e.getMessage());<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="删改">删改</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DerbyUpdateDeleteExample</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-string">"org.apache.derby.jdbc.EmbeddedDriver"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jdbc:derby:helloDB"</span>; <span class="hljs-comment">// 注意：这里不再用 create=true</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"user"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"password"</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> {<br>            Class.forName(driver);<br>            System.out.println(<span class="hljs-string">"驱动加载成功。"</span>);<br><br>            conn = DriverManager.getConnection(url, username, password);<br>            System.out.println(<span class="hljs-string">"成功连接到数据库 helloDB。"</span>);<br><br>            stmt = conn.createStatement();<br><br>            <span class="hljs-comment">// 1. 更新数据 </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">updateSQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"UPDATE students SET age = 21 WHERE name = 'Alice'"</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">updatedRows</span> <span class="hljs-operator">=</span> stmt.executeUpdate(updateSQL); <span class="hljs-comment">// executeUpdate() 返回受影响行数 </span><br>            System.out.println(<span class="hljs-string">"更新成功，影响行数: "</span> + updatedRows);<br><br>            <span class="hljs-comment">// 2. 插入新数据以便稍后删除</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">insertSQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"INSERT INTO students VALUES (3, 'Charlie', 25)"</span>;<br>            stmt.executeUpdate(insertSQL);<br>            System.out.println(<span class="hljs-string">"插入 Charlie 成功。"</span>);<br><br>            <span class="hljs-comment">// 3. 删除数据 </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">deleteSQL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"DELETE FROM students WHERE name = 'Bob'"</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deletedRows</span> <span class="hljs-operator">=</span> stmt.executeUpdate(deleteSQL); <span class="hljs-comment">// executeUpdate() 返回受影响行数 </span><br>            System.out.println(<span class="hljs-string">"删除成功，影响行数: "</span> + deletedRows);<br><br>        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {<br>            System.err.println(<span class="hljs-string">"未找到 JDBC 驱动类: "</span> + e.getMessage());<br>        } <span class="hljs-keyword">catch</span> (SQLException e) {<br>            System.err.println(<span class="hljs-string">"数据库操作失败: "</span> + e.getMessage());<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">if</span> (stmt != <span class="hljs-literal">null</span>) stmt.close();<br>                <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) conn.close();<br>                System.out.println(<span class="hljs-string">"资源已关闭。"</span>);<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                System.err.println(<span class="hljs-string">"关闭资源时发生错误: "</span> + e.getMessage());<br>            }<br>            <span class="hljs-comment">// 关闭 Derby 数据库</span><br>            <span class="hljs-keyword">try</span> {<br>                DriverManager.getConnection(<span class="hljs-string">"jdbc:derby:;shutdown=true"</span>);<br>            } <span class="hljs-keyword">catch</span> (SQLException e) {<br>                <span class="hljs-keyword">if</span> (!e.getSQLState().equals(<span class="hljs-string">"08006"</span>)) {<br>                    System.err.println(<span class="hljs-string">"关闭 Derby 数据库时发生错误: "</span> + e.getMessage());<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="备考建议">备考建议</h2><ul><li>选择题</li><li>大题主要有<ul><li>OOP 继承多态</li><li>比较简单的容器使用</li><li>多线程互斥同步</li><li>SQL 或者通信应该会考一个</li></ul></li></ul><h2 id="参考和注解">参考和注解</h2><ul><li><a target="_blank" rel="noopener" href="https://learnxinyminutes.com/zh-cn/java/">Y分钟速成X 其中 X=Java</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>Java 程序设计</div><div>https://blog.kisechan.space/2025/notes-java/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kisechan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年6月24日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2025年6月26日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/site-gitea/" title="自部署 Gitea"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">自部署 Gitea</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/notes-ptms/" title="概率论与数理统计"><span class="hidden-mobile">概率论与数理统计</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",function(){var e=Object.assign({clientID:"Ov23liWYIiu2jxReIEhB",clientSecret:"d7b44817ae2553b2175fdecfde9718b582bdc653",repo:"Comment-Kisechan",owner:"Kisechan",admin:["Kisechan"],language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!0,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enabled:!0},{id:"283020abd4f0802c4c2e97bdd1fb4b83"});new Gitalk(e).render("gitalk-container")})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><div><span>Frame by <a href="https://hexo.io" target="_blank" rel="nofollow noopener">Hexo</a></span> <span>| Theme <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></span></div><div style="font-size:.85rem"><span><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></span><span><script async src="https://views.kisechan.space/views.js"></script><br><span id="my-site-view">本站总访问量：加载中...</span><br><br><span>&copy; 2024 - 2025 By <a href="https://github.com/Kisechan" target="_blank" rel="nofollow noopener"><strong>Kisechan</strong></a><br></span><span>今天也很喜欢你！</span><br><a href="https://icp.gov.moe/?keyword=20251453" target="_blank">萌ICP备20251453号</a></span></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/linkcard.js"></script><script src="/js/cursor.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script><script type="text/javascript">var originalTitle=document.title;window.onblur=function(){document.title="等你回来哦"},window.onfocus=function(){document.title=originalTitle}</script><div id="tooltip-rightmenu" class="tooltip-rightmenu">如果需要使用原始右键菜单请按下 <strong>Ctrl+右键</strong></div><div id="tooltip-clipboard" class="tooltip-rightmenu">链接复制成功！</div><div id="rightmenu-wrapper"><ul class="list-v rightmenu" id="rightmenu-content"><li class="navigation menuNavigation-Content"><a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa fa-arrow-left rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa fa-arrow-right rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa fa-refresh rightmenu-icon"></i></a> <a aria-label="TOP" href="#" role="button"><i class="fa fa-arrow-up rightmenu-icon"></i></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><span><i class="fa fa-search rightmenu-icon"></i> 站内搜索</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="toggleFullScreen()"><span><i class="fa fa-arrows-alt rightmenu-icon"></i> 切换全屏</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="copyPageUrl()"><span><i class="fa fa-clipboard rightmenu-icon"></i> 复制链接</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="scrollToComments()"><span><i class="fa fa-commenting rightmenu-icon"></i> 立即评论</span></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_blank" rel="noopener" href="https://www.kisechan.space/" data-group="link"><span><i class="fa fa-info-circle rightmenu-icon"></i> 关于本站</span></a></li></ul></div><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/css/custom_right_menu_icons.css" type="text/css" rel="stylesheet"><script src="/js/right_menu.js" type="text/javascript"></script><link href="/css/right_menu.css" type="text/css" rel="stylesheet"><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>