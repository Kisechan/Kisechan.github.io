<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><link rel="manifest" href="/manifest.json"><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://images.kisechan.space/apple-touch-icon.png"><link rel="icon" href="https://images.kisechan.space/icon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#004e66"><meta name="author" content="Kisechan"><meta name="keywords" content=""><meta name="description" content="▶Mermaid 代码                                  1234567891011121314151617181920212223242526272829303132333435363738394041mindmap  root((软件设计模式 SDP))    面向对象基础      课程概述      面向对象设计与"><meta property="og:type" content="article"><meta property="og:title" content="软件设计模式 课程笔记"><meta property="og:url" content="https://blog.kisechan.space/2025/notes-design-pattern/index.html"><meta property="og:site_name" content="Kisechan&#39;s Blog"><meta property="og:description" content="▶Mermaid 代码                                  1234567891011121314151617181920212223242526272829303132333435363738394041mindmap  root((软件设计模式 SDP))    面向对象基础      课程概述      面向对象设计与"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.kisechan.space/%E3%81%93%E3%81%A3%E3%81%9D%E3%82%8A%E3%83%81%E3%83%A7%E3%82%B3%E3%83%AC%E3%83%BC%E3%83%88_73129157.jpg"><meta property="article:published_time" content="2025-11-15T06:12:35.000Z"><meta property="article:modified_time" content="2025-11-19T13:50:24.850Z"><meta property="article:author" content="Kisechan"><meta property="article:tag" content="设计模式"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://images.kisechan.space/%E3%81%93%E3%81%A3%E3%81%9D%E3%82%8A%E3%83%81%E3%83%A7%E3%82%B3%E3%83%AC%E3%83%BC%E3%83%88_73129157.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><title>软件设计模式 课程笔记 - Kisechan&#39;s Blog</title><link rel="stylesheet" type="text/css" href="/css/loading.css"><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4890189_m2l1f174snq.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"blog.kisechan.space",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),n=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3837;break}}),i=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+6136;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="Kisechan's Blog" type="application/atom+xml"></head><body><div><div class="real_mask" style="background-color:rgba(0,0,0,.3);width:100%;height:100%;position:fixed;z-index:-777"></div><div id="banner_video_insert"></div><div id="vvd_banner_img"></div></div><div id="banner"></div><div id="loader-box"><div class="loader-wrapper"><div class="loader"></div><div class="loader-text"><div>L</div><div>O</div><div>A</div><div>D</div><div>I</div><div>N</div><div>G</div><div></div><div></div><div></div></div></div><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loader-box").remove()};window.addEventListener("load",endLoading)</script></div><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KISECHAN</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-Homehomepagemenu"></i> <span>博客</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-newstextarticle"></i> <span>文章</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-categories"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user"></i> <span>关于</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/about/" target="_self"><i class="iconfont icon-info-fill"></i> <span>关于</span> </a><a class="dropdown-item" href="/playlist/" target="_self"><i class="iconfont icon-music"></i> <span>歌单</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/Kisechan.github.io" target="_self"><i class="iconfont icon-git"></i> <span>仓库</span> </a><a class="dropdown-item" href="/atom.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS</span></a></div></li><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/tools/" target="_self"><i class="iconfont icon-tool-fill"></i> <span>工具</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link"></i> <span>友链</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.travellings.cn/go.html" target="_self"><i class="iconfont icon-train"></i> <span>开往</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://images.kisechan.space/202502042159748.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">软件设计模式 课程笔记</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kisechan </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-11-15 14:12" pubdate>2025年11月15日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div><script type="text/javascript" src="/vvd_js/jquery.js"></script><div class="banner" id="banner"><div class="full-bg-img"></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="课程笔记" id="heading-311a46cfdaa3afda544e9285644f70d7" role="tab" data-toggle="collapse" href="#collapse-311a46cfdaa3afda544e9285644f70d7" aria-expanded="true">课程笔记 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-311a46cfdaa3afda544e9285644f70d7" role="tabpanel" aria-labelledby="heading-311a46cfdaa3afda544e9285644f70d7"><div class="category-post-list"><a href="/2024/oop/" title="面向对象程序设计课程笔记" class="list-group-item list-group-item-action"><span class="category-post">面向对象程序设计课程笔记</span> </a><a href="/2024/linux-note/" title="Linux课程笔记" class="list-group-item list-group-item-action"><span class="category-post">Linux课程笔记</span> </a><a href="/2024/ds/" title="数据结构课程板子合集&amp;笔记" class="list-group-item list-group-item-action"><span class="category-post">数据结构课程板子合集&amp;笔记</span> </a><a href="/2025/notes-algorithm-analysis/" title="算法设计与分析 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">算法设计与分析 课程笔记</span> </a><a href="/2025/notes-database-1/" title="数据库原理 课程笔记 (1) 数据库、关系代数和 SQL" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (1) 数据库、关系代数和 SQL</span> </a><a href="/2025/notes-database-2/" title="数据库原理 课程笔记 (2) E-R 模型和关系模式" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (2) E-R 模型和关系模式</span> </a><a href="/2025/notes-database-3/" title="数据库原理 课程笔记 (3) 存储、索引、事务和并发" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (3) 存储、索引、事务和并发</span> </a><a href="/2025/notes-database-4/" title="数据库原理 课程笔记 (4) 杂项和题目整理" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (4) 杂项和题目整理</span> </a><a href="/2025/notes-os/" title="操作系统复习" class="list-group-item list-group-item-action"><span class="category-post">操作系统复习</span> </a><a href="/2025/notes-ptms/" title="概率论与数理统计" class="list-group-item list-group-item-action"><span class="category-post">概率论与数理统计</span> </a><a href="/2025/notes-java/" title="Java 程序设计" class="list-group-item list-group-item-action"><span class="category-post">Java 程序设计</span> </a><a href="/2025/notes-networks/" title="计算机网络课程笔记" class="list-group-item list-group-item-action"><span class="category-post">计算机网络课程笔记</span> </a><a href="/2025/notes-se-1/" title="软件工程课程笔记 (1)" class="list-group-item list-group-item-action"><span class="category-post">软件工程课程笔记 (1)</span> </a><a href="/2025/notes-design-pattern/" title="软件设计模式 课程笔记" class="list-group-item list-group-item-action active"><span class="category-post">软件设计模式 课程笔记</span> </a><a href="/2025/notes-machine-learning/" title="机器学习 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">机器学习 课程笔记</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">软件设计模式 课程笔记</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2025-11-19T21:50:24+08:00</p><div class="markdown-body"><p><img src="https://images.kisechan.space/20251115161935679.png" srcset="/img/loading.gif" lazyload alt="设计模式课程的主要内容"></p><div class="fold"><div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-65ad56e5" role="button" aria-expanded="false" aria-controls="collapse-65ad56e5"><div class="fold-arrow">▶</div>Mermaid 代码</div><div class="fold-collapse collapse" id="collapse-65ad56e5"><div class="fold-content"><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs text">mindmap<br>  root((软件设计模式 SDP))<br>    面向对象基础<br>      课程概述<br>      面向对象设计与复用<br>      类间关系与UML<br>      OO设计原则（SOLID等）<br>    设计模式概述<br>      模式的由来<br>      GoF 23模式<br>      模式的分类<br>      模式组成(意图、结构、优缺点、适用场景)<br>    创建型模式<br>      简单工厂<br>      工厂方法<br>      抽象工厂<br>      建造者<br>      原型<br>      单例<br>    结构型模式<br>      适配器<br>      桥接<br>      组合<br>      装饰<br>      外观<br>      享元<br>      代理<br>    行为型模式<br>      职责链<br>      命令<br>      迭代器<br>      中介者<br>      备忘录<br>      观察者<br>      状态<br>      策略<br>      模板方法<br>    总结<br>      设计模式的目的<br>      模式之间的对比<br>      如何在工程中运用模式<br></code></pre></td></tr></tbody></table></figure></div></div></div><h2 id="面向对象和设计模式">面向对象和设计模式</h2><h3 id="设计模式概论">设计模式概论</h3><p>设计模式面向对象技术发展到一定阶段后的产物。</p><ul><li>是<strong>被反复使用、众所周知并经过总结分类的面向对象设计经验</strong>。</li><li>对面向对象系统中的复杂问题提供通用解决方案。</li><li><strong>设计模式对面向对象开发的意义</strong>约等于<strong>数据结构对面向过程开发的意义</strong>。</li><li>设计模式能帮助开发者实现：<ul><li>可维护</li><li>可复用</li><li>可扩展</li><li>灵活性高</li></ul></li><li>能更快地成长为优秀的软件开发工程师。</li></ul><p>设计模式本质上是 <strong>对面向对象思想的深化与实践</strong>。学习设计模式能更深入理解 OO 概念与 OO 软件体系结构。</p><h3 id="面向对象（Object-Oriented）">面向对象（Object-Oriented）</h3><p>Coad 提出：<strong>面向对象 = 对象 + 类 + 继承 + 通信</strong>。</p><p>面向对象的特点是：</p><ul><li>既是一种 <strong>编程范式</strong>，也是一套 <strong>系统开发方法论</strong>。</li><li>是对现实世界的抽象：把相关的数据和方法组合为“对象”。</li><li>相对于面向过程，更符合自然事物建模方式。</li></ul><h4 id="OO-的目标">OO 的目标</h4><ul><li><strong>可维护</strong>：修改局部，不影响整体</li><li><strong>可复用</strong>：类和组件可多次使用</li><li><strong>可扩展</strong>：加新功能不破坏旧结构</li><li><strong>灵活性</strong>：结构可组合、可替换、可重组</li></ul><blockquote><p>比喻：活字印刷术中，可更换、重排的“字块”</p></blockquote><h4 id="面向对象编程语言">面向对象编程语言</h4><p>现代主流语言几乎全部支持或围绕 OOP 构建，如： Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP 等。</p><h4 id="面向对象开发方法">面向对象开发方法</h4><p>OO 方法贯穿开发方法的整个生命周期</p><ul><li>OOA：对象分析</li><li>OOD：对象设计</li><li>OOP：对象编程</li><li>OOT：对象测试</li><li>OOSM：对象维护</li></ul><p>面向对象不只是编程语言，更是一整套软件工程方法论。</p><h4 id="面向对象的发展与全貌">面向对象的发展与全貌</h4><h5 id="历史演进">历史演进</h5><ul><li><strong>Simula 67</strong>（1967，挪威）：首次引入类、继承、多态 → 第一门真正意义的 OOPL</li><li><strong>Smalltalk</strong>：确立 OO 思想</li><li>后续语言：C++、Objective-C、Java、C#、Ruby 等</li></ul><h5 id="形成的体系">形成的体系</h5><ul><li>OOPL：支持 OO 的语言</li><li>OOP：利用 OOPL 进行 OO 编程</li><li>类库 &amp; 框架：OOP 促进大规模可复用组件库出现</li><li>设计模式：在类库、框架设计过程中沉淀出的“可复用设计思想”</li></ul><h5 id="配套方法与工具">配套方法与工具</h5><ul><li><strong>UML（统一建模语言）</strong>：用图形表示 OO 软件结构</li><li>OO 建模方法、开发流程</li><li>OO 已成为覆盖整个开发流程的综合技术体系</li></ul><h5 id="目标">目标</h5><ul><li>利用前人经验（模式、框架、建模方法）</li><li>提高软件质量与开发效率</li><li>支持大规模复杂软件的管理与设计</li></ul><h3 id="面向对象设计">面向对象设计</h3><p>OO 设计是对“<strong>面向对象分析结果</strong>”的进一步整理，使其能够被直接用于面向对象编程。目标是<strong>把分析的对象、关系、职责，转化为可实现的类、方法、属性以及组件结构</strong>。</p><p>面向对象设计的三个层次：</p><ul><li>框架级设计</li><li>类设计</li><li>代码设计</li></ul><h4 id="框架级设计（Framework-Level）">框架级设计（Framework Level）</h4><p>框架是从一类特定软件中抽象出的<strong>可复用、协作的类群</strong>，定义了软件的体系结构。关注点：</p><ul><li>类如何分组 → 包（Package）</li><li>包之间如何协同</li><li>抽象层较高，强调复用与架构组织</li></ul><p>常见例子：三层逻辑架构（UI → 业务逻辑 → 数据库）</p><hr><h5 id="包（Package）与包结构原则">包（Package）与包结构原则</h5><p>包的六大原则分两类：</p><ul><li><p><strong>包的内聚性原则</strong>（决定类如何划分到包中）</p><ol><li><strong>重用发布等价原则 REP</strong><ul><li>复用的粒度 = 发布的粒度</li><li>复用的类应打包在一起，以便统一发布。</li></ul></li><li><strong>共同重用原则 CRP</strong><ul><li>经常一起变化的类应放在同一包中（高内聚）。</li><li>避免把不相关的类打包在一起。</li></ul></li><li><strong>共同封闭原则 CCP</strong><ul><li>对同一类变化原因负责的类，应放同一包中。</li><li>提升修改的局部性。</li></ul></li></ol></li><li><p><strong>包的耦合性原则</strong>（决定包与包之间如何连接）</p><ol start="4"><li><p><strong>无环依赖原则 ADP</strong></p><ul><li><p>包之间不能出现循环依赖。</p></li><li><p>保证架构清晰、可维护、可编译。</p></li></ul></li><li><p><strong>稳定依赖原则 SDP</strong></p><ul><li>不稳定的包应依赖稳定的包。</li><li>避免不稳定组件成为系统“根”。</li></ul></li><li><p><strong>稳定抽象原则 SAP</strong></p><ul><li><p>稳定的包应更抽象（用接口/抽象类）。</p></li><li><p>稳定 ≠ 僵化。</p></li></ul></li></ol></li></ul><h4 id="类设计（Class-Level）">类设计（Class Level）</h4><p>关注对象、类、属性、行为的抽象与组织方式。</p><ul><li>解决如何将现实世界对象转化为类结构，如何定义其行为和属性。</li><li>软件设计模式属于此层次（Factory、Singleton、Strategy 等）。</li></ul><hr><p><strong>类的定义</strong></p><ul><li>对象：问题域中的实体抽象</li><li>类：对象属性与行为的模板</li></ul><p>类设计要处理：</p><ul><li>类的组织与表示</li><li>行为（方法）的组织</li><li>属性的组织</li><li>类之间的关系（复用、耦合度）</li></ul><hr><ol><li><p><strong>类的组织与表示</strong>（从现实到抽象）</p><ul><li><p><strong>类的发现</strong>：从具体实例抽象，例如：苹果、香蕉 → 水果类</p></li><li><p><strong>聚类分析</strong>：找出对象集合的共同特征</p></li><li><p><strong>类的再抽象</strong>：进一步抽象成更通用概念，如“水果”或模板“List<t>”</t></p></li><li><p><strong>类的拆分</strong>：一个类中不属于核心领域的部分应拆出（如水果篮中的鲜花）</p></li><li><p><strong>类的可见性</strong>：区分公开、私有成员（对外接口 vs 内部实现）</p></li><li><p><strong>类的复用性（高内聚、低耦合）</strong></p></li></ul></li><li><p><strong>行为（方法）的组织与表示</strong></p><ul><li><p><strong>行为的参与者</strong>：行为涉及的对象（老鼠吃水果）</p></li><li><p><strong>行为分组与接口</strong>：例如吃香蕉 / 吃苹果 → 吃水果</p></li><li><p><strong>行为分解</strong>：抽象行为的内部步骤（剥皮 → 吃 → 吐核）</p></li><li><p><strong>行为的可见性</strong>：内部实现与外部接口区分</p></li><li><p><strong>行为的返回结果</strong>：吃水果返回成功/失败/数量</p></li><li><p><strong>行为的差异性</strong>：不同对象实现同一行为（多态）</p></li></ul></li><li><p><strong>属性的组织与表示</strong></p><ul><li><p>属性类型：内置、自定义</p></li><li><p>可访问性：只读、只写、读写</p></li><li><p>不变属性：不会随时间变化（身份证号）</p></li><li><p>类属性 vs 实例属性：如“扑克牌背面图案”是类属性</p></li><li><p>属性可见性：常隐藏，靠 getter/setter 暴露</p></li><li><p>属性设计依赖具体编程语言特性</p></li></ul></li></ol><hr><p><strong>变化</strong></p><p>这是类设计的核心难点。</p><ol><li><p><strong>职责的变化</strong>（接口变化）</p><ul><li><p>行为签名改变</p></li><li><p>新增功能</p></li><li><p>可访问性改变</p></li></ul></li><li><p><strong>实现的变化</strong>（内部变化）</p><ul><li><p>数据类型变化</p></li><li><p>数据结构变化</p></li><li><p>行为算法变化</p></li></ul></li></ol><p>示例分析：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//0. 新增函数 f1    （职责变化）</span><br>     <span class="hljs-comment">//1. f 参数表可能变化（职责变化）</span><br>     <span class="hljs-comment">//2. f 的具体实现变化（实现变化）</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">//3. 数据类型变化（实现变化）</span><br>     <span class="hljs-comment">//4. 数据结构变化（实现变化）</span><br>     <span class="hljs-type">int</span> nums[<span class="hljs-number">50</span>];<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>应对变化的两种方式</strong></p><ol><li><p><strong>修改既有代码</strong></p><ul><li><p>缺点：</p><ul><li><p>可能无法访问源码</p></li><li><p>修改已发布代码风险高</p></li><li><p>修改接口可能影响大量调用者</p></li></ul></li></ul></li><li><p><strong>扩展既有代码</strong>（OO 推荐方式）</p><ul><li><p>使用类关系扩展系统：</p><ul><li><p><strong>继承扩展</strong>（最常见但谨慎使用）</p></li><li><p><strong>依赖扩展</strong></p></li><li><p><strong>关联扩展</strong></p></li><li><p><strong>聚合扩展</strong></p></li><li><p><strong>组合扩展</strong></p></li></ul></li><li><p>目标：遵守开闭原则（对扩展开放，对修改关闭）。</p></li></ul></li></ol><h4 id="代码设计（Code-Level）">代码设计（Code Level）</h4><p>类的具体实现（物理级）：源代码、二进制代码、可执行代码。关注：</p><ul><li>性能</li><li>可部署性</li><li>可移植性</li><li>代码结构与文件组织方式</li></ul><h3 id="关系模型与设计模式的关联">关系模型与设计模式的关联</h3><h4 id="关系模型（类间关系）是复用的基础">关系模型（类间关系）是复用的基础</h4><p>类之间的关系是 OO 中复用的工具。</p><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">强度</th><th style="text-align:center">UML 表示</th><th style="text-align:center">关键语义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>依赖</strong>（Dependency）</td><td style="text-align:center">⭐</td><td style="text-align:center"><strong>虚线箭头</strong></td><td style="text-align:center">临时使用，弱关系</td></tr><tr><td style="text-align:center"><strong>关联</strong>（Association）</td><td style="text-align:center">⭐⭐</td><td style="text-align:center"><strong>实线箭头</strong></td><td style="text-align:center">长期使用，语义级关系</td></tr><tr><td style="text-align:center"><strong>聚合</strong>（Aggregation）</td><td style="text-align:center">⭐⭐⭐</td><td style="text-align:center"><strong>空心菱形 + 实线</strong></td><td style="text-align:center">整体-部分，可分离</td></tr><tr><td style="text-align:center"><strong>组合</strong>（Composition）</td><td style="text-align:center">⭐⭐⭐⭐</td><td style="text-align:center"><strong>实心菱形 + 实线</strong></td><td style="text-align:center">整体-部分，不可分离</td></tr><tr><td style="text-align:center"><strong>泛化</strong>（Generalization）</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center"><strong>空心三角实线</strong></td><td style="text-align:center">继承，有实现复用</td></tr><tr><td style="text-align:center"><strong>实现</strong>（Realization）</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center"><strong>空心三角虚线</strong></td><td style="text-align:center">实现接口，无实现继承</td></tr></tbody></table><h5 id="依赖（Dependency）">依赖（Dependency）</h5><ul><li>A <strong>使用到</strong> B，但这种关系 <strong>偶然、弱、短暂</strong></li><li>B 的变化会影响到 A，但二者并不是长期绑定</li></ul><p>典型代码表现有：</p><ul><li>方法参数</li><li>方法内部局部变量</li><li>调用对方静态方法</li><li>临时 <code>new</code>/<code>delete</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B* b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B&amp; b)</span></span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>UML 表示用虚线箭头，A → B 表示 “A 依赖 B”。</p><p>示例：</p><ul><li>老鼠吃苹果</li><li>人借车移动</li><li>警察抓小偷（也可设计为更复杂的双向依赖）</li><li>Screen（画布）依赖 Shape 的绘制接口</li><li>Mouse 依赖 Fruit（通过子类型适配多种水果变化）</li></ul><hr><p>关键思想：</p><p>依赖关系用于<strong>适应短期变化</strong>。</p><p>常见的使用方法：</p><ul><li>参数多态（<code>Fruit&amp;</code>）</li><li>子类型化适应扩展（<code>Cat</code>/<code>Dog</code> 类型化 <code>Monster</code>）</li></ul><h5 id="关联（Association）">关联（Association）</h5><ul><li>A 和 B <strong>长期存在语义关联</strong></li><li>强于依赖</li><li>双方地位平等（通常）</li></ul><p>UML 用实线箭头 A → B（单向）或实线无箭头（双向）表示</p><p>代码特征通常表现为 <strong>成员变量</strong>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CWife</span> {<br>    CHusband* husband;  <span class="hljs-comment">// 关联</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>关联分三大类：</p><ol><li><strong>单向关联</strong>：只有一方持有对方</li><li><strong>双向关联</strong>：双方互相持有</li><li><strong>自身关联</strong>：类内部引用自己（如链表 Node）</li></ol><p>示例：</p><ul><li>英雄（Hero）持有宝物（Goods）</li><li>学生（Student）拥有宿舍（Dorm）</li><li>丈夫 ↔ 妻子（双向）</li><li>链表 Node 自身关联 nextNode</li></ul><p>本质上，关联描述一种 <strong>更稳定的“使用关系”</strong>。 生命周期独立，但逻辑联系长期存在。</p><hr><h5 id="聚合（Aggregation）">聚合（Aggregation）</h5><ul><li>“整体–部分（has-a）”关系</li><li>部分 <strong>可以独立于整体存在</strong></li><li>关系 <strong>弱于组合</strong></li></ul><p>例如：</p><ul><li>自行车 — 轮胎；</li><li>学生 — 宿舍；</li><li>科研团队 — 科研人员。</li></ul><p>UML 用空心菱形 + 实线表示。</p><pre><code class="mermaid">classDiagram
    class A
    class B
    A o-- B
</code></pre><p>代码例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dorm</span> {<br>    Student** mStudents;  <span class="hljs-comment">// 但学生可独立存在</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>特性：</p><ul><li>整体与部分可分离</li><li>生命周期不绑定</li><li>常用于“容器拥有元素”</li></ul><p>示例扩展：</p><ul><li>果篮–水果</li><li>防盗门–锁</li><li>Grid 包含多个 Rect（绘图示例）</li></ul><h5 id="组合（Composition）">组合（Composition）</h5><p>强聚合（比聚合强），部分的生命周期 <strong>完全依赖整体</strong></p><p>例如：</p><ul><li>人和大脑</li><li>窗口和标题栏</li><li>公司和部门（生命周期绑定）</li></ul><p>UML 用实心菱形 + 实线表示</p><pre><code class="mermaid">classDiagram
    class Whole
    class Part
    Whole *-- Part
</code></pre><p>代码特征：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    B b;          <span class="hljs-comment">// 组合：整体负责部分的生命周期</span><br>};<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    B* b;<br>    <span class="hljs-built_in">A</span>() { b = <span class="hljs-keyword">new</span> B; }<br>    ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">delete</span> b; }<br>};<br></code></pre></td></tr></tbody></table></figure><p>特征：</p><ul><li>部分不能脱离整体生存</li><li>整体被析构 → 部分也被析构</li><li>表现更强的所有权</li></ul><h5 id="泛化（Generalization）">泛化（Generalization）</h5><ul><li>“一般–特殊”关系</li><li><strong>继承</strong></li><li>子类继承父类的<strong>属性和实现</strong></li></ul><p>UML 用空心三角形 + 实线表示子类 → 父类</p><pre><code class="mermaid">classDiagram
    Animal &lt;|-- Tiger
</code></pre><p>示例：</p><ul><li>Monster ← Cat</li><li>Monster ← Dog</li><li>Animal ← Tiger</li></ul><hr><h5 id="实现（Realization）">实现（Realization）</h5><p>类实现接口，类似 Java 的 <code>implements</code>。</p><p>和泛化的区别：</p><ul><li><strong>泛化</strong>：继承父类的实现（代码）</li><li><strong>实现</strong>：仅继承接口，无实现</li></ul><p>UML 用空心三角形 + 虚线表示：</p><pre><code class="mermaid">classDiagram
    IAnimal &lt;|.. Animal
</code></pre><h4 id="设计原则是行为准则">设计原则是行为准则</h4><p>面向对象从提出到成熟经历了大量实践，逐渐沉淀出 <strong>七大设计原则</strong>。<br>它们可分为两类：</p><ul><li><p><strong>设计目标</strong>（设计的“方向”），重点：让系统<strong>稳定</strong>、<strong>可扩展</strong>、<strong>可维护</strong></p><ol><li><strong>开闭原则</strong> OCP</li><li><strong>里氏替换原则</strong> LSP</li><li><strong>迪米特原则</strong> LoD（最少知道原则）</li></ol></li><li><p><strong>设计方法</strong>（如何“做到”），重点：实现<strong>高内聚</strong>、<strong>低耦合</strong></p><ol><li><strong>单一职责原则</strong> SRP</li><li><strong>接口分隔原则</strong> ISP</li><li><strong>依赖倒置原则</strong> DIP</li><li><strong>组合/聚合复用原则</strong> CARP</li></ol></li></ul><p>这七个原则不是孤立的，互相强化。</p><p><strong>OCP 是核心，其他六条都是帮助我们实现 OCP 的工具。</strong></p><table><thead><tr><th style="text-align:center">原则</th><th style="text-align:center">中文名</th><th style="text-align:center">作用</th><th style="text-align:center">与 OCP 的关系</th></tr></thead><tbody><tr><td style="text-align:center">OCP</td><td style="text-align:center">开闭原则</td><td style="text-align:center">最终目标：可扩展、可维护</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LSP</td><td style="text-align:center">里氏替换原则</td><td style="text-align:center">正确继承，确保扩展不会破坏原有功能</td><td style="text-align:center">OCP 的根基</td></tr><tr><td style="text-align:center">LoD</td><td style="text-align:center">迪米特原则</td><td style="text-align:center">减少耦合，间接提高可扩展性</td><td style="text-align:center">提供低耦合环境</td></tr><tr><td style="text-align:center">SRP</td><td style="text-align:center">单一职责原则</td><td style="text-align:center">单一职责，使扩展简单</td><td style="text-align:center">便于扩展、减少修改</td></tr><tr><td style="text-align:center">ISP</td><td style="text-align:center">接口分隔原则</td><td style="text-align:center">专门接口，提高灵活性</td><td style="text-align:center">避免修改胖接口</td></tr><tr><td style="text-align:center">DIP</td><td style="text-align:center">依赖倒置原则</td><td style="text-align:center">高层不依赖低层，实现可替换</td><td style="text-align:center">通过抽象实现 OCP</td></tr><tr><td style="text-align:center">CARP</td><td style="text-align:center">组合/聚合复用原则</td><td style="text-align:center">用组合支持扩展、减少继承修改</td><td style="text-align:center">扩展开放、修改关闭</td></tr></tbody></table><div class="note note-info"><p>面向对象七大原则的核心是“<strong>开闭原则</strong>”，它强调对扩展开放、对修改关闭。</p><ul><li><strong>里氏替换原则</strong>保证继承结构的正确性；</li><li><strong>迪米特原则</strong>降低耦合；</li><li><strong>单一职责原则</strong>和<strong>接口隔离原则</strong>控制了类与接口的粒度；</li><li><strong>依赖倒置原则</strong>通过抽象降低层间依赖；</li><li><strong>组合/聚合复用原则</strong>提供了一种比继承更稳定的复用机制。</li></ul><p>它们共同协作以提高软件的可扩展性、可维护性和稳定性。</p></div><h5 id="开闭原则（Open-Closed-Principle-OCP）">开闭原则（Open-Closed Principle, OCP）</h5><blockquote><p>软件实体应该<em>对扩展开放</em>，<em>对修改关闭</em>。</p></blockquote><p>即：添加功能<strong>不改旧代码，通过扩展类/接口实现新行为</strong>。</p><p>意义：</p><ul><li><strong>稳定性</strong>：减少修改旧模块引入 bug。</li><li><strong>扩展性</strong>：通过新类扩展系统能力。</li></ul><p>如何实现？</p><ul><li>找出系统中“变化点”，抽象为接口。</li><li>使用“面向接口编程”而不是面向实现。</li><li>新行为 = 新类 + 实现既有接口，而不是改旧类。</li></ul><p>典型反例：</p><blockquote><p>绘图程序中有 <code>Circle</code>、<code>Square</code>，错误设计用 <code>switch-case</code> 判断类型 → 违反 OCP。</p></blockquote><p>正确方法：</p><blockquote><p>给 <code>Shape</code> 定义抽象方法 <code>draw()</code>，每个图形类实现自己的 draw。</p></blockquote><hr><h5 id="里氏替换原则（LSP）">里氏替换原则（LSP）</h5><blockquote><p>任何父类出现的地方，子类必须能够透明替换，并保持程序正确性。</p></blockquote><p>一句话：<strong>子类必须完全遵守父类的行为契约</strong>。</p><p>违反的表现：</p><ul><li>用 <code>typeid</code>、<code>instanceof</code> 判断类型 → 明显违反 LSP。</li><li>子类重写方法后导致父类行为被破坏。</li></ul><p>经典反例：</p><blockquote><p><code>Square</code> 继承 <code>Rectangle</code></p><p><code>Rectangle</code> 有：</p><ul><li><code>setWidth</code></li><li><code>setHeight</code></li></ul><p><code>Square</code> 继承后无法保持矩形逻辑 → 损坏父类行为。</p><p>因此，这种继承是<strong>错误的继承</strong>。</p></blockquote><p>正确做法：</p><blockquote><p>建立更高层抽象，例如 <code>Quadrilateral</code>。</p></blockquote><p>本质：</p><ul><li>正确判断哪些类应该“继承”，哪些应该“关联”。</li><li>如果继承会破坏行为契约，则不应该继承。</li></ul><hr><h5 id="迪米特原则（LoD，最少知道原则）">迪米特原则（LoD，最少知道原则）</h5><blockquote><p>一个对象应该尽量少地了解其他对象，只与直接朋友通信。</p></blockquote><p>判断“朋友”：</p><ul><li><code>this</code></li><li>方法参数</li><li>成员变量</li><li>成员变量的元素（如列表内元素）</li><li>当前对象创建的对象</li></ul><p>其他都属于“陌生人”，不应该直接访问。</p><p>表现形式：</p><ul><li>不要“链式访问”：<code>a.getB().getC().doSomething()</code> → 违反 LoD</li><li>不要暴露太多 <code>public</code> 方法。</li></ul><p>示例：洗衣机</p><blockquote><p><code>Person</code> 调用 <code>WashingMachine</code> 的内部细节（<code>receiveClothes</code>、<code>wash</code>、<code>dry</code>） → 知道太多。</p></blockquote><p>调整为：</p><blockquote><p><code>WashingMachine</code> 提供 <code>automatic()</code>，内部自己组织流程。</p></blockquote><hr><h5 id="单一职责原则（SRP）">单一职责原则（SRP）</h5><blockquote><p>一个类应该只有一个引起它变化的原因。</p></blockquote><p>如果一个类承担多个职责：</p><ul><li>一个职责变化会影响另一个职责的用户</li><li>增加耦合性、降低可维护性</li></ul><p>例子：<code>Modem</code></p><blockquote><ul><li><p><code>dial</code>/<code>hangup</code> = 连接职责</p></li><li><p><code>send</code>/<code>receive</code> = 通讯职责</p></li><li><p>放一起 → 违反 SRP</p></li></ul><p>应该分成 <code>Connect</code> 接口 + <code>DataCommunicate</code> 接口。</p></blockquote><hr><h5 id="接口分隔原则（ISP）">接口分隔原则（ISP）</h5><blockquote><p>不要强迫用户依赖他们不需要的接口。</p><p>使用多个专用接口，而不是单一的胖接口。</p></blockquote><p>ISP 和 SRP 的区别：</p><ul><li><strong>SRP</strong>：关注“类/接口本身是否职责单一”</li><li><strong>ISP</strong>：从“调用者角度”，避免把不必要的方法塞给用户</li></ul><p>例子：</p><blockquote><p><code>Door</code> + <code>Alarm</code> 功能</p><ul><li>错误：<code>Door</code> 接口包含 <code>alarm()</code></li></ul><p>正确方案：</p><ul><li><code>Door</code> 接口：<code>lock</code>/<code>unlock</code></li><li><code>Alarm</code> 接口：<code>alarm</code></li><li><code>AlarmDoor</code> = <code>Door</code> + <code>Alarm</code></li></ul></blockquote><hr><h5 id="依赖倒置原则（DIP）">依赖倒置原则（DIP）</h5><blockquote><ul><li><p>高层模块不应依赖低层模块；二者都应依赖抽象</p></li><li><p>抽象不应该依赖细节；细节应该依赖抽象</p></li></ul></blockquote><p>本质：面向接口编程</p><p>例如：</p><blockquote><p><strong>反例</strong>（错误）</p><p>高层直接依赖 <code>FileLogger</code> / <code>DatabaseLogger</code> 等具体类</p><p><strong>正例</strong>（正确）</p><ul><li>定义 <code>Logger</code> 接口</li><li>高层依赖 <code>Logger</code></li><li>具体 <code>FileLogger</code>、<code>DbLogger</code> 实现 <code>Logger</code></li></ul><p>这样：</p><ul><li>新增 <code>RedisLogger</code> → 不改高层代码 → 符合 OCP</li><li>高层不依赖具体实现 → 松耦合</li></ul></blockquote><hr><h5 id="组合-聚合复用原则（CARP）">组合/聚合复用原则（CARP）</h5><blockquote><p>尽量使用“组合/聚合”来实现复用，而不是继承。</p></blockquote><p>继承的问题：</p><ul><li>父类变 → 子类全变（紧耦合）</li><li>强类型绑定，限制结构</li></ul><p>组合的优势：</p><ul><li>灵活替换（符合 OCP）</li><li>对象之间松耦合</li></ul><blockquote><p>例：<code>Player</code> 拥有 <code>Bike</code>（组合）<br>而不是 <code>class Player : private Bike</code> → <strong>继承不符合实际关系</strong>。</p></blockquote><h4 id="设计模式是对-OO-设计经验的提炼">设计模式是对 OO 设计经验的提炼</h4><ul><li>基于关系模型</li><li>遵循设计原则</li><li>解决反复出现的设计问题</li><li>是从大量复用实践中总结的通用解决方案</li></ul><div class="note note-info"><p>总结三者关系：</p><ul><li>关系模型 = 工具</li><li>设计原则 = 准则</li><li>设计模式 = 在工具与准则基础上总结出的经验</li></ul><pre><code class="mermaid">graph TD
    A[面向对象基础] --&gt; B[类间关系]
    A --&gt; C[设计原则]
    C --&gt; D[SOLID 原则]

    C --&gt; E[设计模式]
    B --&gt; E

    E --&gt; F[可复用/可扩展的软件结构]
</code></pre></div><h2 id="设计模式">设计模式</h2><p>设计模式并非起源于软件行业，而是起源于建筑学。</p><p>“模式之父” Christopher Alexander（加州大学环境结构中心 所长）在 1977 年出版了 <em>A Pattern Language</em>，总结了 <strong>253 个建筑与城市规划模式</strong>。Alexander 给出的模式定义：</p><blockquote><p>“每个模式描述了一个在环境中不断出现的问题，并提供解决该问题的核心方案，可反复使用。”</p><p><strong>A pattern is a solution to a problem in a context.</strong></p></blockquote><p>即：<strong>模式 = 在特定环境中解决某类问题的通用方案</strong></p><hr><p>1990 年代，软件工程界开始关注模式思想。</p><ul><li><strong>1991–1992 年</strong>：四人组（<strong>Gang of Four, GoF</strong>：Gamma、Helm、Johnson、Vlissides）把模式引入面向对象软件设计。</li><li><strong>1994 年</strong>：他们发表了著名的 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>，总结 <strong>23 个经典设计模式</strong>，奠定了软件设计模式的基础。</li></ul><p>此后，设计模式成为软件工程教育的标准内容，也广泛应用在 Java、.NET 等平台中。</p><h3 id="软件模式">软件模式</h3><p>软件模式是对软件开发中 <strong>重复出现的问题及其解决方案</strong> 的总结，包括：</p><ul><li>架构模式（如 MVC）</li><li>分析模式</li><li>设计模式（GoF）</li><li>过程模式（如敏捷模式）</li></ul><p>软件模式的结构一般包含四部分：</p><ol><li>问题描述</li><li>前提条件（环境或约束）</li><li>解决方案</li><li>效果（优缺点）</li></ol><h4 id="模式发现的“三次律”（Rule-of-Three）">模式发现的“三次律”（Rule of Three）</h4><p>一个方案必须至少在 <strong>三个不同系统</strong> 中成功使用，才有资格成为一个真正的模式。</p><h3 id="GoF-设计模式">GoF 设计模式</h3><p>GoF 在 1994 年总结了 <strong>23 种最经典的软件设计模式</strong>，用于解决软件设计中可复用性、扩展性、可维护性的问题。</p><p>设计模式帮助统一分析、设计、实现之间的沟通语言，使面向对象设计更加系统化与工程化。</p><h4 id="设计模式的基本要素">设计模式的基本要素</h4><p>每个设计模式一般包含如下关键结构：</p><ul><li><strong>模式名称</strong>（Pattern Name）：便于沟通的“专业词汇”</li><li><strong>问题</strong>（Problem）：该模式要解决的矛盾或场景</li><li><strong>解决方案</strong>（Solution）：类结构与交互方式</li><li><strong>效果</strong>（Consequences）：优点、缺点、对系统的影响</li></ul><blockquote><p>实际书中通常还包含示例代码、相关模式等内容。</p></blockquote><h4 id="设计模式的分类">设计模式的分类</h4><h5 id="按“目的”分类（WHAT-解决什么问题）">按“目的”分类（WHAT 解决什么问题）</h5><ol><li><strong>创建型（Creational）</strong><ul><li>用于对象的创建过程</li><li>如：工厂方法、单例、建造者、抽象工厂、原型</li></ul></li><li><strong>结构型（Structural）</strong><ul><li>如何组合类或对象形成更大的结构</li><li>如：适配器、代理、桥接、组合、装饰、享元、外观</li></ul></li><li><strong>行为型（Behavioral）</strong><ul><li>类或对象之间如何分配职责、如何通信</li><li>如：观察者、策略、命令、状态、迭代器、访问者等</li></ul></li></ol><h5 id="按“范围”分类（WHO-参与关系）">按“范围”分类（WHO 参与关系）</h5><ol start="4"><li><p><strong>类模式</strong></p><ul><li><p>处理类与子类之间的关系（通过继承，编译期确定）</p></li><li><p>静态结构</p></li></ul></li><li><p><strong>对象模式</strong></p><ul><li><p>处理对象之间的关系（运行期确定）</p></li><li><p>动态结构，更灵活，也更多出现</p></li></ul></li></ol><hr><table><thead><tr><th style="text-align:center">范围 \ 目的</th><th style="text-align:center">创建型模式</th><th style="text-align:center">结构型模式</th><th style="text-align:center">行为型模式</th></tr></thead><tbody><tr><td style="text-align:center"><strong>类模式</strong></td><td style="text-align:center">工厂方法</td><td style="text-align:center">类适配器</td><td style="text-align:center">解释器、模板方法</td></tr><tr><td style="text-align:center"><strong>对象模式</strong></td><td style="text-align:center">抽象工厂、建造者、原型、单例</td><td style="text-align:center">对象适配器、桥接、组合、装饰、外观、享元、代理</td><td style="text-align:center">职责链、命令、迭代器、中介者、备忘录、观察者、状态、策略、访问者</td></tr></tbody></table><h3 id="设计模式的优点">设计模式的优点</h3><ol><li><p><strong>提供通用语言</strong>（便于沟通），设计模式为开发者提供标准术语，使讨论系统结构更清晰。例如：</p><ul><li><p>“这里使用观察者模式通知 UI”</p></li><li><p>“把数据库访问层抽象成工厂模式”<br>这些话大家都能理解。</p></li></ul></li><li><p><strong>提高代码复用性、可维护性</strong>，设计模式总结了成熟的设计方案，避免：</p><ul><li><p>重新发明轮子</p></li><li><p>重复犯常见设计错误</p></li></ul></li><li><p><strong>让系统更加灵活且易扩展</strong>：许多模式（如策略、装饰）让系统结构更具可扩展性，符合开闭原则。</p></li><li><p><strong>提升软件质量与开发效率</strong>：设计模式经过验证，是构建高可靠软件的重要技术。</p></li><li><p><strong>帮助初学者理解面向对象思想</strong>：设计模式是学习 OO 思维的最佳教材：</p><ul><li><p>抽象</p></li><li><p>封装</p></li><li><p>多态</p></li><li><p>组合优于继承</p></li></ul></li></ol><h2 id="创建型设计模式">创建型设计模式</h2><p>创建型模式（Creational Patterns）的核心思想：</p><blockquote><p><strong>把“创建对象”这件事独立出来，让使用对象的代码不再关心创建过程。</strong></p></blockquote><p>换句话说：平时我们总是在写 <code>new XXX()</code>，但一旦类多、构建复杂、依赖变化，<code>new</code> 会成为巨大的负担，创建型模式就是帮助你：<strong>不要乱用 <code>new</code></strong>。</p><p>它的两个关键特征：</p><ol><li><strong>客户不知道对象的具体类是什么</strong>（解耦，隐藏细节）</li><li><strong>隐藏对象实例的创建与组织过程</strong>（你只“要”，不“造”）</li></ol><p>只要想写出：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">SomeObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeObject</span>();  <span class="hljs-comment">// ← 看到 new 就要想：能不能用工厂？</span><br></code></pre></td></tr></tbody></table></figure><p>就可以考虑创建型模式。</p><p>创建型模式包括：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>建造者模式</li><li>原型模式</li><li>单例模式</li></ul><h3 id="简单工厂模式">简单工厂模式</h3><p>比如 UI 中有三种按钮：</p><ul><li>圆形按钮</li><li>矩形按钮</li><li>菱形按钮</li></ul><p>不想写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundButton</span>();<br></code></pre></td></tr></tbody></table></figure><p>而希望：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ButtonFactory.getButton(<span class="hljs-string">"round"</span>);<br></code></pre></td></tr></tbody></table></figure><p>你只需要知道一个“<strong>类型参数</strong>”，不需要知道类名，不需要知道构造过程。</p><hr><p>简单工厂 又叫 <strong>静态工厂方法</strong> Static Factory Method，即：</p><blockquote><p>定义一个专门的工厂类，根据传入参数，返回某个父类（抽象产品）下的具体子类（具体产品）。</p></blockquote><p>因此角色有：</p><ul><li><strong>Factory 工厂角色</strong>：负责创建对象（通常是 static 方法）</li><li><strong>Product 抽象产品角色</strong>：父类/接口</li><li><strong>ConcreteProduct 具体产品角色</strong>：各种实际产品的实现类</li></ul><pre><code class="mermaid">classDiagram
    class Product {
        &lt;&lt;interface&gt;&gt;
        +operation()
    }

    class ConcreteProductA {
        +operation()
    }

    class ConcreteProductB {
        +operation()
    }

    class Factory {
        +createProduct(type): Product
    }

    Product &lt;|.. ConcreteProductA
    Product &lt;|.. ConcreteProductB
    Factory --&gt; Product
</code></pre><hr><p>示例：未使用工厂，代码臃肿难维护：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String type)</span> {<br>    <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">"cash"</span>)) {<br>        ...<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">"creditcard"</span>)) {<br>        ...<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">"voucher"</span>)) {<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>所有支付逻辑写在一起，增加新的支付方式 → 必须改这个函数。<strong>违反开闭原则</strong> OCP。</p><hr><p><strong>使用简单工厂</strong>：</p><ol><li><strong>抽象产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>具体产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> { <span class="hljs-comment">/* 现金支付 */</span> }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>工厂类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayMethodFactory</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractPay <span class="hljs-title function_">getPayMethod</span><span class="hljs-params">(String type)</span> {<br>        <span class="hljs-keyword">if</span>(type.equalsIgnoreCase(<span class="hljs-string">"cash"</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashPay</span>();<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equalsIgnoreCase(<span class="hljs-string">"creditcard"</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreditcardPay</span>();<br>        }<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AbstractPay</span> <span class="hljs-variable">pay</span> <span class="hljs-operator">=</span> PayMethodFactory.getPayMethod(<span class="hljs-string">"cash"</span>);<br>pay.pay();<br></code></pre></td></tr></tbody></table></figure><p><strong>对象的创建完全被封装</strong>，业务逻辑更清晰。</p><hr><p><strong>优点</strong>：</p><ol><li><strong>工厂类集中管理对象创建</strong>，客户端不需要知道具体类名。</li><li><strong>客户端与具体类解耦</strong>，只需传入一个参数。</li><li>可以将参数放到 <strong>配置文件 / 数据库</strong> 中，实现“无需修改代码即可替换产品”。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>工厂类承担所有对象创建职责，过于臃肿</strong>，一个工厂要知道所有产品，非常不灵活。</li><li><strong>不符合开闭原则</strong>，添加新产品就必须修改工厂类的判断逻辑。</li><li><strong>工厂方法是静态的</strong>，无法通过继承扩展工厂（这是和工厂方法模式的区别）。</li></ol><p>如果产品越来越多，应该升级到 <strong>工厂方法模式</strong> 或 <strong>抽象工厂模式</strong>。</p><hr><p><strong>模式适用场景</strong></p><p>适用于：</p><ul><li>产品数量 <strong>较少</strong>；</li><li>客户端只有一个“类型参数”，不关心如何创建对象；</li><li>希望集中管理对象创建逻辑；</li><li>创建逻辑简单，不需要复杂构建流程；</li></ul><p>典型场景：</p><ul><li>JDK 的工具类</li><li>加密算法（Cipher）</li><li>日期格式化（DateFormat）</li></ul><hr><p>JDK 经典例子：<code>DateFormat</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateFormat</span> <span class="hljs-variable">df1</span> <span class="hljs-operator">=</span> DateFormat.getDateInstance();<br><span class="hljs-type">DateFormat</span> <span class="hljs-variable">df2</span> <span class="hljs-operator">=</span> DateFormat.getDateInstance(DateFormat.FULL);<br><span class="hljs-type">DateFormat</span> <span class="hljs-variable">df3</span> <span class="hljs-operator">=</span> DateFormat.getDateInstance(DateFormat.FULL, Locale.US);<br></code></pre></td></tr></tbody></table></figure><p>这就是一个典型的 <strong>多个静态工厂方法</strong>。</p><hr><p>Java 加密 API 示例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">KeyGenerator</span> <span class="hljs-variable">keyGen</span> <span class="hljs-operator">=</span> KeyGenerator.getInstance(<span class="hljs-string">"DESede"</span>);<br><span class="hljs-type">Cipher</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"DESede"</span>);<br></code></pre></td></tr></tbody></table></figure><p><code>getInstance</code> 就是简单工厂。</p><h4 id="模式扩展：把工厂放到产品类中">模式扩展：把工厂放到产品类中</h4><p>可以将工厂方法直接写进抽象产品中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title function_">create</span><span class="hljs-params">(String type)</span> { ... }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>优点：减少类数量。</li><li>缺点：产品类职责增加，不够纯粹。</li></ul><p>下面我继续为你<strong>归纳 + 系统化讲解工厂方法模式（Factory Method Pattern）</strong>，内容结构与上一部分保持一致，并会适当插入 <strong>Mermaid UML 图代码</strong>，你可以直接放进 slides 使用。</p><h3 id="工厂方法模式">工厂方法模式</h3><p>简单工厂模式的问题：</p><ul><li>工厂类只有一个，负责所有产品实例化 → <strong>职责过重</strong></li><li>增加新产品必须修改工厂类 → <strong>违反开闭原则</strong></li><li>产品越多，判断逻辑越复杂 → <strong>不利维护与扩展</strong></li></ul><p>工厂方法模式的目标就是解决这些问题：<strong>把创建对象的选择延迟到子类，由子类决定创建哪种产品。</strong></p><hr><p><strong>问题</strong>：如何“扩展”一个产品，而不修改已有工厂？</p><p>例：按钮系统 → 圆形按钮、矩形按钮、菱形按钮……如果想增加 “椭圆形按钮”，简单工厂必须修改 <code>if</code>…<code>else</code>。</p><p><strong>解决</strong>：把“创建哪个按钮”的决定交给子类</p><ul><li>定义一个抽象工厂：<code>ButtonFactory</code></li><li>每种按钮对应一个工厂子类：<code>CircleButtonFactory</code>、<code>RectButtonFactory</code>…</li><li>子类负责实例化具体按钮</li></ul><p>优点：不改旧代码，<strong>直接增加新工厂即可</strong> → <strong>完全符合开闭原则</strong>！</p><hr><blockquote><p><strong>工厂方法模式：定义一个创建对象的接口（工厂方法），让子类决定实例化哪一个类。</strong></p><p>工厂方法让一个类的实例化延迟到其子类完成。</p></blockquote><p><strong>角色说明</strong>：</p><ul><li><strong>Product</strong>（抽象产品）：所有产品的父接口</li><li><strong>ConcreteProduct</strong>（具体产品）：具体产品实现</li><li><strong>Factory</strong>（抽象工厂）：声明工厂方法</li><li><strong>ConcreteFactory</strong>（具体工厂）：真正生产对应的具体产品</li></ul><pre><code class="mermaid">classDiagram
    class Product {
        &lt;&lt;interface&gt;&gt;
    }
    class ConcreteProductA
    class ConcreteProductB

    Product &lt;|.. ConcreteProductA
    Product &lt;|.. ConcreteProductB

    class Factory {
        &lt;&lt;abstract&gt;&gt;
        +createProduct() Product
    }

    class ConcreteFactoryA {
        +createProduct() Product
    }
    class ConcreteFactoryB {
        +createProduct() Product
    }

    Factory &lt;|-- ConcreteFactoryA
    Factory &lt;|-- ConcreteFactoryB
    ConcreteFactoryA --&gt; ConcreteProductA
    ConcreteFactoryB --&gt; ConcreteProductB
</code></pre><hr><p>典型实例：</p><ol><li><strong>抽象产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>具体产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 现金支付处理</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>抽象工厂</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayMethodFactory</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractPay <span class="hljs-title function_">createPayMethod</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>具体工厂</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPayFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PayMethodFactory</span> {<br>    <span class="hljs-keyword">public</span> AbstractPay <span class="hljs-title function_">createPayMethod</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashPay</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li><strong>客户端</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PayMethodFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashPayFactory</span>();<br><span class="hljs-type">AbstractPay</span> <span class="hljs-variable">pay</span> <span class="hljs-operator">=</span> factory.createPayMethod();<br>pay.pay();<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>优点</strong>：</p><table><thead><tr><th style="text-align:center">简单工厂</th><th style="text-align:center">工厂方法</th></tr></thead><tbody><tr><td style="text-align:center">新产品 → 修改工厂</td><td style="text-align:center">新产品 → 创建新工厂</td></tr><tr><td style="text-align:center">不符合开闭原则</td><td style="text-align:center"><strong>完全符合开闭原则</strong></td></tr><tr><td style="text-align:center">工厂逻辑复杂</td><td style="text-align:center">工厂类单一职责</td></tr><tr><td style="text-align:center">静态方法不可扩展</td><td style="text-align:center">多态，可以动态加载</td></tr></tbody></table><p><strong>工厂方法利用多态，通过子类决定“创建什么产品”，实现耦合解散。</strong></p><hr><p><strong>反射 + 配置文件</strong>（高级使用）</p><p>实际开发中可以不用 <code>new</code>：</p><p>XML：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">className</span>&gt;</span>CashPayFactory<span class="hljs-tag">&lt;/<span class="hljs-name">className</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Java：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(className);<br><span class="hljs-type">PayMethodFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> (PayMethodFactory) c.newInstance();<br></code></pre></td></tr></tbody></table></figure><p>优点：<strong>新增产品完全零修改客户端代码</strong></p><hr><p><strong>适用场景</strong>：</p><p>工厂方法非常适用于：</p><ol><li><strong>类不知道需要创建何种类的实例</strong></li><li><strong>系统需要在运行时决定创建哪个产品</strong></li><li><strong>想做到真正的开闭原则</strong></li></ol><p>典型使用地方：</p><ul><li>JDBC</li><li>JNDI</li><li>JMS</li><li>Spring BeanFactory（底层思想）</li></ul><h3 id="抽象工厂模式">抽象工厂模式</h3><p>工厂方法模式一个工厂只负责一个产品等级结构。但开发中经常出现：</p><ul><li>一个工厂要生产<strong>多个相互关联的产品对象</strong></li><li>这些产品分属于不同的“产品等级结构”（类的继承体系）</li><li>这些产品必须来自同一个“产品族”（例如海尔电视 + 海尔冰箱）</li></ul><blockquote><p>工厂方法模式无法同时创建多个产品族内的不同产品，因此需要抽象工厂模式。</p></blockquote><p><strong>两个关键概念</strong>：</p><table><thead><tr><th style="text-align:center">概念</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>产品等级结构</strong>（Product Hierarchy）</td><td style="text-align:center">指一个抽象产品及其所有具体子类，构成一个继承体系</td></tr><tr><td style="text-align:center"><strong>产品族</strong>（Product Family）</td><td style="text-align:center">指同一工厂生产的、属于不同等级结构的一组产品（一起使用）</td></tr></tbody></table><p>例如：</p><ul><li>产品等级结构1：电视（抽象电视 → 海尔电视、TCL电视…）</li><li>产品等级结构2：冰箱（抽象冰箱 → 海尔冰箱、TCL冰箱…）</li></ul><p>“海尔”是一个产品族，“TCL”也是产品族。</p><ul><li>当需要“同时创建同一个品牌的电视 + 冰箱”等一组产品时，使用抽象工厂。</li></ul><hr><blockquote><p><strong>抽象工厂模式（Abstract Factory）</strong>：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</p></blockquote><p>又叫 <strong>Kit 模式</strong>。</p><p><strong>模式结构</strong></p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>AbstractFactory（抽象工厂）</strong></td><td style="text-align:center">声明“每个产品族”中产品的创建方法</td></tr><tr><td style="text-align:center"><strong>ConcreteFactory（具体工厂）</strong></td><td style="text-align:center">实现抽象工厂，创建某个产品族中的所有产品</td></tr><tr><td style="text-align:center"><strong>AbstractProduct（抽象产品）</strong></td><td style="text-align:center">每个产品等级结构的抽象父类</td></tr><tr><td style="text-align:center"><strong>Product（具体产品）</strong></td><td style="text-align:center">具体工厂创建的产品类</td></tr></tbody></table><pre><code class="mermaid">classDiagram
    class AbstractFactory {
        +createTV() AbstractTV
        +createFridge() AbstractFridge
    }

    class HaierFactory {
        +createTV() HaierTV
        +createFridge() HaierFridge
    }

    class TCLFactory {
        +createTV() TCLTV
        +createFridge() TCLFridge
    }

    AbstractFactory &lt;|-- HaierFactory
    AbstractFactory &lt;|-- TCLFactory

    class AbstractTV
    class HaierTV
    class TCLTV
    AbstractTV &lt;|.. HaierTV
    AbstractTV &lt;|.. TCLTV
    HaierFactory --&gt; HaierTV
    TCLFactory --&gt; TCLTV

    class AbstractFridge
    class HaierFridge
    class TCLFridge
    AbstractFridge &lt;|.. HaierFridge
    AbstractFridge &lt;|.. TCLFridge
    HaierFactory --&gt; HaierFridge
    TCLFactory --&gt; TCLFridge
</code></pre><hr><p><strong>优点</strong>：</p><ol><li><p><strong>隔离具体类</strong>，客户端完全不知道产品具体类名称 → 松耦合。</p></li><li><p><strong>保证产品族的一致性</strong>，创建出的产品一定属于同一族（如海尔电视 + 海尔冰箱）。</p></li><li><p><strong>增加产品族方便</strong>（扩展性强），新增一个品牌 → 增加一个新的 ConcreteFactory 即可。</p></li></ol><p><strong>缺点</strong>：</p><ol><li><strong>难以增加新的产品等级结构</strong>（非常重要）</li></ol><p>例如：</p><ul><li>原来只有电视 + 冰箱</li><li>想增加“洗衣机”</li></ul><p>❗需要修改：</p><ul><li>抽象工厂接口</li><li>所有具体工厂类</li></ul><p>违背开闭原则 → <strong>开闭原则的倾斜性</strong></p><ol start="2"><li><strong>类数量多，结构复杂</strong></li></ol><hr><p>抽象工厂模式适用于：</p><ul><li>系统需要与环境绑定（如 GUI 主题、OS UI）</li><li>程序需同时创建某一产品族中的多个对象</li><li>一个产品族中的多个对象必须一起使用</li><li>系统提供产品接口库，隐藏实现细节</li></ul><p>典型例子：</p><ul><li>Java AWT：不同操作系统生成不同外观组件</li><li>GUI 主题切换：按钮 + 输入框 + 背景成套变化</li></ul><hr><p><strong>模式扩展</strong></p><p>开闭原则的倾斜性（<strong>非常关键</strong>）：</p><table><thead><tr><th style="text-align:center">扩展内容</th><th style="text-align:center">难度</th></tr></thead><tbody><tr><td style="text-align:center"><strong>增加新的产品族</strong></td><td style="text-align:center">简单（新增 ConcreteFactory）</td></tr><tr><td style="text-align:center"><strong>增加新的产品等级结构</strong></td><td style="text-align:center">困难（必须改抽象工厂 + 所有具体工厂）</td></tr></tbody></table><h4 id="抽象工厂方法的退化链条">抽象工厂方法的退化链条</h4><table><thead><tr><th>情况</th><th>退化成</th></tr></thead><tbody><tr><td>抽象工厂中每个具体工厂只有一个工厂方法</td><td>工厂方法模式</td></tr><tr><td>工厂方法中的抽象工厂和具体工厂合并，且方法改为 static</td><td>简单工厂模式</td></tr></tbody></table><p>它们三个其实是一个“进阶链”。</p><hr><blockquote><p><strong>抽象工厂模式的本质是 —— 选择整个产品族的实现。</strong></p></blockquote><p>工厂方法选择“一个产品”，</p><p>抽象工厂选择“一系列相关产品（产品族）”。</p><hr><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">简单工厂</th><th style="text-align:center">工厂方法</th><th style="text-align:center">抽象工厂</th></tr></thead><tbody><tr><td style="text-align:center"><strong>创建什么</strong></td><td style="text-align:center">一个产品</td><td style="text-align:center">一个产品等级结构</td><td style="text-align:center">一个产品族（多产品等级结构）</td></tr><tr><td style="text-align:center"><strong>如何创建</strong></td><td style="text-align:center">静态方法 + 分支判断</td><td style="text-align:center">多态：子类决定创建哪种产品</td><td style="text-align:center">多态：子类一次创建多个相关产品</td></tr><tr><td style="text-align:center"><strong>扩展新产品是否修改旧代码？</strong></td><td style="text-align:center"><strong>必须修改工厂类</strong></td><td style="text-align:center"><strong>新建工厂即可</strong></td><td style="text-align:center"><strong>新建工厂即可</strong>（仅限产品族）</td></tr><tr><td style="text-align:center"><strong>对开闭原则的支持</strong></td><td style="text-align:center">差</td><td style="text-align:center">好</td><td style="text-align:center">倾斜：对产品族好，对产品等级结构差</td></tr><tr><td style="text-align:center"><strong>适用场景</strong></td><td style="text-align:center">产品简单</td><td style="text-align:center">产品等级结构扩展</td><td style="text-align:center">多产品族、整体替换主题/平台</td></tr><tr><td style="text-align:center"><strong>示例</strong></td><td style="text-align:center"><code>DateFormat.parse()</code></td><td style="text-align:center">JDBC <code>DriverManager</code></td><td style="text-align:center">GUI 主题、AWT Toolkit</td></tr><tr><td style="text-align:center"><strong>复杂度</strong></td><td style="text-align:center">最简单</td><td style="text-align:center">中等</td><td style="text-align:center">最高</td></tr></tbody></table><h3 id="建造者模式">建造者模式</h3><p>在现实世界与软件系统中，有些对象结构复杂，需要多个步骤才能完成。例如：</p><ul><li>车 = 轮胎 + 发动机 + 座椅 + 方向盘</li><li>游戏中的地图 = 天空 + 背景 + 地面</li><li>邮件对象 = 发送者 + 接收者 + 标题 + 内容 + 日期…</li></ul><p><strong>复杂对象 = 多个组件 + 有顺序的组装步骤</strong></p><p>关键问题：</p><ul><li>用户 <strong>不需要</strong> 明确知道这些组件如何组合</li><li>产品内部构造很复杂</li><li>构建步骤通常必须按顺序</li><li>不同建造者可以产生不同版本的产品（如不同风格的 UI、不同配置的电脑）</li></ul><p>解决方案：<strong>将构建过程与产品组成分离，封装到 <code>Builder</code> 中，由 <code>Director</code> 指挥组装。</strong></p><hr><blockquote><p><strong>建造者模式（Builder Pattern）</strong>： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>也就是<strong>把“怎么构建”与“构建出的对象长什么样”分开。</strong></p><p><strong>模式结构</strong>：</p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Builder（抽象建造者）</strong></td><td style="text-align:center">定义构建产品部件的接口</td></tr><tr><td style="text-align:center"><strong>ConcreteBuilder（具体建造者）</strong></td><td style="text-align:center">实现具体部件的构造与装配</td></tr><tr><td style="text-align:center"><strong>Director（指挥者）</strong></td><td style="text-align:center">控制构建顺序，调用 Builder 的方法</td></tr><tr><td style="text-align:center"><strong>Product（产品）</strong></td><td style="text-align:center">最终生成的复杂对象</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251119145606655.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>优点</strong>：</p><ul><li><strong>分离构建与表示</strong>（符合单一职责原则）</li><li><strong>相同构建过程可以生成不同产品</strong></li><li><strong>更精细控制构建步骤</strong></li><li><strong>增加新的建造者容易</strong>（符合开闭原则）</li><li><strong>隐藏复杂构建逻辑，客户端无需知晓内部细节</strong></li></ul><p><strong>缺点</strong>：</p><ul><li>产品结构相似，才能使用，否则 <code>Builder</code> 太多</li><li>产品内部变化复杂时 <code>Builder</code> 也会变复杂</li></ul><hr><p><strong>适用场景</strong>：</p><ul><li>产品内部结构 <strong>复杂</strong>（多属性、多子对象）</li><li>产品构建需要 <strong>特定顺序</strong></li><li>创建产品过程需要 <strong>独立于产品类</strong></li><li>同样的构建步骤要生产 <strong>不同风格的产品</strong></li></ul><hr><p><strong>经典应用</strong>：</p><ol><li><p>JavaMail 邮件构建流程（邮件内容多，构建步骤多 → 非常适合 Builder）</p></li><li><p>游戏中的“地图/人物建造器”</p></li><li><p>GUI 界面搭建（如 Swing/AWT）</p></li><li><p>SQL 构造器（MyBatis、Hibernate）</p></li></ol><hr><p><strong>模式扩展</strong>：</p><p><strong>可简化版本</strong></p><ul><li><p><strong>去掉 <code>AbstractBuilder</code></strong></p></li><li><p><strong>去掉 <code>Director</code></strong></p></li><li><p>甚至两者合并</p></li></ul><p>适合产品结构简单、只有一个 <code>Builder</code> 时。</p><hr><table><thead><tr><th style="text-align:center">比较项</th><th style="text-align:center">Builder</th><th style="text-align:center">Abstract Factory</th></tr></thead><tbody><tr><td style="text-align:center">返回对象</td><td style="text-align:center">完整产品</td><td style="text-align:center">产品家族（多个产品）</td></tr><tr><td style="text-align:center">核心思想</td><td style="text-align:center">关注构建步骤</td><td style="text-align:center">关注对象分类</td></tr><tr><td style="text-align:center">适用场景</td><td style="text-align:center">复杂对象，步骤明确</td><td style="text-align:center">多产品族</td></tr></tbody></table><p>比喻：</p><ul><li><strong>抽象工厂</strong> = 汽车配件工厂（轮胎、发动机）</li><li><strong>建造者模式</strong> = 汽车总装厂（组装一辆整车）</li></ul><h3 id="原型模式">原型模式</h3><p>问题场景：</p><ul><li>创建对象成本很高（构造复杂、消耗资源）</li><li>有时需要频繁创建类似对象</li><li>构造函数复杂但对象大部分状态相同</li></ul><p>解决方案：<strong>用原型对象克隆得到新对象，而不是重新 <code>new</code>。</strong></p><p>类比：</p><ul><li>拉一份文档模板再修改</li><li>复印机复制信件</li><li>复制 UI 组件后再修改</li></ul><hr><blockquote><p><strong>原型模式（Prototype Pattern）</strong>：通过复制现有实例来创建新的对象，而无需知道创建的细节。</p></blockquote><p>简化理解：<strong>不用 <code>new</code>，直接 <code>clone</code>。</strong></p><p><strong>模式结构</strong>：</p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Prototype（抽象原型）</strong></td><td style="text-align:center">定义 <code>clone</code> 方法</td></tr><tr><td style="text-align:center"><strong>ConcretePrototype（具体原型）</strong></td><td style="text-align:center">实现 <code>clone</code> 方法</td></tr><tr><td style="text-align:center"><strong>Client（客户端）</strong></td><td style="text-align:center">使用原型对象生成新对象</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251119145530992.png" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="深拷贝-浅拷贝">深拷贝 &amp; 浅拷贝</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">基本类型</th><th style="text-align:center">引用类型</th></tr></thead><tbody><tr><td style="text-align:center"><strong>浅拷贝</strong></td><td style="text-align:center">复制值</td><td style="text-align:center">仅复制引用地址</td></tr><tr><td style="text-align:center"><strong>深拷贝</strong></td><td style="text-align:center">复制值</td><td style="text-align:center">复制对象本身（递归克隆）</td></tr></tbody></table><p>Java 默认 <code>Object.clone()</code> 是 <strong>浅克隆</strong>。</p><p>深克隆可以通过：</p><ul><li>手动克隆每个引用对象</li><li>序列化（最常见）</li></ul><hr><p>示例：Java <code>clone()</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypeDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> {<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone(); <span class="hljs-comment">// 浅克隆</span><br>        } <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) {<br>            System.err.println(<span class="hljs-string">"Not support cloneable"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>使用场景</strong></p><p>适合：</p><ul><li>创建对象开销大（IO、数据库、复杂计算）</li><li>对象大量相似，只需少量属性不同</li><li>系统需要保存对象不同历史状态（可与备忘录模式结合）</li><li>需要避免庞大的工厂类层级结构</li></ul><hr><p><strong>优点</strong>：</p><ul><li><strong>效率高</strong>（避免复杂构造）</li><li><strong>减少类层次结构</strong></li><li><strong>动态扩展容易</strong>（新增原型不影响现有代码）</li><li><strong>可配合深克隆保存对象状态</strong></li></ul><p><strong>缺点</strong>：</p><ul><li>每个类都必须实现 <code>clone</code>（违反开闭原则）</li><li>深克隆代码复杂</li><li>存在多层嵌套对象时容易出错</li></ul><h4 id="带原型管理器">带原型管理器</h4><p>等价于一个“对象工厂”，内部存放多个原型对象。</p><pre><code class="mermaid">classDiagram
direction LR

class PrototypeManager {
    -registry : Map&lt;String, Prototype&gt;
    +add(name, prototype)
    +get(name) Prototype
}

PrototypeManager --&gt; Prototype
</code></pre><p>作用：</p><ul><li>管理多个原型</li><li>通过 key 复制对应对象</li></ul><hr><table><thead><tr><th style="text-align:center">设计模式</th><th style="text-align:center">本质</th></tr></thead><tbody><tr><td style="text-align:center"><strong>建造者模式</strong></td><td style="text-align:center">分离：构建算法 与 部件构造</td></tr><tr><td style="text-align:center"><strong>原型模式</strong></td><td style="text-align:center">克隆生成对象，避免重复构建</td></tr></tbody></table><h3 id="单例模式">单例模式</h3><p>在某些场景中，系统只需要某个类的一个实例，例如：</p><ul><li>文件系统</li><li>任务管理器</li><li>打印池 <code>Print Spooler</code></li><li>全局配置、日志记录器</li><li>序列号生成器</li></ul><p>传统方式（如全局变量）无法防止对象被重复实例化，因此需要一种机制——<strong>让类自己管理唯一实例，并提供全局访问点</strong>。</p><hr><blockquote><p><strong>保证一个类只有一个实例</strong>，并提供一个可访问它的<strong>全局访问点</strong>。</p></blockquote><p>要点：</p><ol><li>类只能有一个实例</li><li>类负责自行创建这个实例</li><li>类提供全局访问该实例的静态方法</li></ol><p><img src="https://images.kisechan.space/20251119151757573.png" srcset="/img/loading.gif" lazyload alt="image-20251119151757504"></p><hr><p>一个标准的单例类必须满足：</p><ul><li><strong>构造函数私有化</strong>（禁止外部 <code>new</code>）</li><li><strong>包含静态私有实例变量</strong></li><li><strong>提供静态公共工厂方法返回唯一实例</strong></li></ul><p>Java 实现示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}   <span class="hljs-comment">// 私有构造函数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) {<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 第一次访问时创建实例</span><br>        }<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p>示例 1：<strong>身份证号码</strong></p><pre><code class="mermaid">classDiagram
    class IDCard {
        - static instance : IDCard
        - idNumber : String
        - IDCard()
        + static getInstance() IDCard
        + getIdNumber() String
    }
   IDCard o--&gt; IDCard
</code></pre><p>居民身份证号唯一，一个人补办身份证时仍使用同一号码。</p><hr><p>示例 2：<strong>打印池</strong> <code>Print Spooler</code></p><pre><code class="mermaid">classDiagram
    class PrintSpooler {
        - static instance : PrintSpooler
        - PrintSpooler()
        + static getInstance() PrintSpooler
        + submitJob()
        + cancelJob()
    }
   
   PrintSpooler o--&gt; PrintSpooler
</code></pre><p>系统中只能有一个打印池程序，否则可能导致打印任务管理混乱。</p><p><strong>优点</strong>：</p><ul><li><strong>受控访问唯一实例</strong>，单例类通过自身封装严格控制实例创建。</li><li><strong>节约系统资源</strong>，频繁创建/销毁对象将增加开销，单例可以减少开销。</li><li><strong>允许扩展为“可控数量的实例”</strong>，可扩展为多例模式（Multiton），控制实例数目。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不易扩展</strong>：因为没有抽象层，很难继承和扩展</li><li><strong>职责过重</strong>：既负责创建实例又负责自身业务逻辑</li><li><strong>容易被滥用</strong>：可能导致对象共享过多，造成安全或资源问题（如把数据库连接池设计为单例导致连接耗尽）</li></ul><hr><p>适合使用单例模式的情况：</p><ul><li>系统中只需要一个实例（如日志记录器、配置管理器）</li><li>实例需要通过唯一的全局访问点访问</li><li>实例创建成本高、或需要在整个运行周期维持的对象</li></ul><p><strong>系统中的实际应用</strong></p><ol><li>Java Runtime（经典单例）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    }<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> {}<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>Spring 默认 <code>Bean Scope = Singleton</code></li></ol><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.Date"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"singleton"</span>/&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Spring 默认管理的 Bean 是单例级别（应用范围内共享）。</p><h4 id="单例模式的扩展">单例模式的扩展</h4><ol><li><strong>饿汉式</strong>（<strong>类加载时就创建对象</strong>）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>优点：</strong> 线程安全、实现简单</p><p><strong>缺点：</strong> 可能占用不必要的资源（类加载时就创建）</p><pre><code class="mermaid">classDiagram
    class Singleton {
        - static instance : Singleton = new Singleton()
        - Singleton()
        + static getInstance() Singleton
    }
</code></pre><ol start="2"><li><strong>懒汉式</strong>（第一次使用时才创建）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span><br></code></pre></td></tr></tbody></table></figure><p><strong>优点：</strong> 节省资源</p><p><strong>缺点：</strong> 在多线程环境下需要同步，性能较低</p><pre><code class="mermaid">classDiagram
    class Singleton {
        - static instance : Singleton
        - Singleton()
        + static getInstance() Singleton  &lt;&lt;synchronized&gt;&gt;
    }
</code></pre><hr><p>单例模式的本质是：<strong>控制实例数量</strong>。</p><p>不仅可以控制为 1 个，也可以控制为 2 个、3 个或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 个 → 形成 <strong>多例模式</strong>（Multiton）。</p><h2 id="结构型设计模式">结构型设计模式</h2><p>结构型模式主要解决 —— <strong>如何把类或对象组合成更强大、更复杂的结构</strong>。</p><p>就像：</p><ul><li>积木组合 → 建筑</li><li>代码组件组合 → 模块化软件系统</li></ul><p>结构型模式分为两类：</p><ol><li><p><strong>类结构型模式</strong>（以继承关系为主）</p><ul><li><p>通过类与类之间的继承、实现关系组成更大结构</p></li><li><p>特点：编译期静态绑定，灵活性较低</p></li></ul></li><li><p><strong>对象结构型模式</strong>（以组合、聚合为主）</p><ul><li><p>对象组合：一个对象持有另一个对象，实现更灵活的结构</p></li><li><p>更符合“合成复用原则”（优先使用组合而不是继承）</p></li><li><p>大多数结构型模式属于对象结构型模式</p></li></ul></li></ol><p><strong>常见的结构型设计模式</strong>：</p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>适配器模式</strong> Adapter</td><td style="text-align:center">接口转换，使不兼容对象协同工作</td></tr><tr><td style="text-align:center"><strong>桥接模式</strong> Bridge</td><td style="text-align:center">将抽象与实现分离，两者独立变化</td></tr><tr><td style="text-align:center"><strong>组合模式</strong> Composite</td><td style="text-align:center">树形结构，统一处理单个与组合对象</td></tr><tr><td style="text-align:center"><strong>装饰模式</strong> Decorator</td><td style="text-align:center">动态为对象添加额外职责</td></tr><tr><td style="text-align:center"><strong>外观模式</strong> Facade</td><td style="text-align:center">为复杂子系统提供统一简化接口</td></tr><tr><td style="text-align:center"><strong>享元模式</strong> Flyweight</td><td style="text-align:center">共享对象，减少内存消耗</td></tr><tr><td style="text-align:center"><strong>代理模式</strong> Proxy</td><td style="text-align:center">控制访问对象，附加额外功能</td></tr></tbody></table><h3 id="适配器模式">适配器模式</h3><p>当“已有类”能满足需求但<strong>接口不兼容</strong>时，会出现以下问题：</p><ul><li>方法名不同</li><li>参数格式不同</li><li>类不方便修改（黑盒库、第三方库）</li></ul><p>类似我们日常使用的“电源适配器”：</p><ul><li>插头不匹配 → 使用 <code>adapter</code> 来转换接口</li></ul><p>适配器模式的目的：<strong>把一个接口转换成客户期望的接口，使得现有类可以复用。</strong></p><hr><p><strong>适配器模式</strong>（Adapter Pattern）：</p><blockquote><p>将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作。</p></blockquote><p>又称为：<strong>包装器</strong>（Wrapper）</p><p>适配器模式分两类：</p><ol><li><strong>类适配器</strong>（<strong>使用继承</strong>）</li><li><strong>对象适配器</strong>（<strong>使用组合</strong>）</li></ol><hr><h4 id="对象适配器">对象适配器</h4><p>对象适配器使用组合，更加常用。</p><p><img src="https://images.kisechan.space/20251119173802423.png" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> {<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> {<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> {<br>        adaptee.specificRequest();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>特点：</p><ul><li><strong>更灵活</strong>，可适配多个适配者类</li><li>强烈符合“合成复用原则”</li></ul><hr><p>对象适配器的优点：</p><ul><li>一个适配器可以对应多个适配者实例</li><li>可以适配适配者及其子类</li><li>灵活性更高 → 使用更多</li></ul><p>缺点：</p><ul><li>不易重写适配者方法（除非再写子类）</li></ul><h4 id="类适配器">类适配器</h4><p>使用继承。</p><p><img src="https://images.kisechan.space/20251119173726029.png" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> {<br>        specificRequest(); <span class="hljs-comment">// 调用父类方法</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>特点：</p><ul><li>使用 <strong>多重继承（类继承 + 接口实现）</strong></li><li>Java/C# 不支持多重继承 → 只能继承一个 Adaptee</li></ul><p>类适配器的优点：</p><ul><li>由于使用继承，可以覆盖适配者的方法（更灵活）</li></ul><p>缺点：</p><ul><li><strong>不能适配多个适配者类</strong>（继承限制）</li><li>目标必须是接口或抽象类（否则不能继承）</li></ul><hr><p><strong>适配器模式的优点</strong>：</p><ul><li><strong>解耦</strong>：目标类与适配者类解耦</li><li><strong>复用性强</strong>：可以复用已有类（不用改源代码）</li><li><strong>符合开闭原则</strong>：可以随时添加新的适配器</li><li><strong>对象适配器支持适配多个类及其子类</strong></li></ul><hr><p><strong>适配器模式适用环境</strong></p><ul><li>系统需要使用某个类，但其接口不兼容</li><li>希望复用一些“功能相似但接口不同”的类</li><li>想为未来可能增加的新类（适配者）准备好扩展点</li></ul><hr><p><strong>应用实例</strong></p><ol><li><p><strong>JDBC 驱动</strong>（典型应用）</p><ul><li>JDBC → 抽象的 Target</li><li>数据库驱动 → Adapter</li><li>底层数据库 API → Adaptee</li><li>每种数据库都有自己的适配器。</li></ul></li><li><p><strong>JDK 的 <code>InputStreamAdapter</code></strong></p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> {<br>    ImageInputStream stream;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamAdapter</span><span class="hljs-params">(ImageInputStream stream)</span> {<br>        <span class="hljs-built_in">this</span>.stream = stream;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-keyword">return</span> stream.read();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-keyword">return</span> stream.read(b, off, len);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>模式扩展</strong></p><ol><li><strong>默认适配器模式</strong>（接口适配器）</li></ol><p>当一个接口方法很多，但我们只需要一部分时：</p><ul><li>定义一个 <strong>默认适配器类（提供空方法）</strong></li><li>子类只需覆盖需要的方法</li></ul><p><img src="https://images.kisechan.space/20251119174411026.png" srcset="/img/loading.gif" lazyload alt=""></p><p>常见于 Java AWT：</p><ul><li><code>WindowAdapter</code></li><li><code>KeyAdapter</code></li><li><code>MouseAdapter</code></li></ul><ol start="2"><li><strong>双向适配器</strong></li></ol><p>可以同时转换：</p><ul><li>Target → Adaptee</li><li>Adaptee → Target</li></ul><p><img src="https://images.kisechan.space/20251119174346497.png" srcset="/img/loading.gif" lazyload alt="image-20251119174346420"></p><ol start="3"><li><strong>智能适配器</strong></li></ol><p>在调用前后加入附加处理，例如：</p><ul><li>日志</li><li>校验</li><li>缓存</li><li>自动选择不同的适配者（策略化）</li></ul><hr><blockquote><p>适配器模式的本质：<strong>转换匹配 + 复用功能</strong></p></blockquote><p>核心理念：</p><ul><li>不修改旧代码</li><li>把旧接口“包装”为新接口</li><li>让不兼容的类可以协作</li></ul><p>结构型模式的核心是：<strong>通过组合/继承构建更强大结构</strong>，适配器模式正是其中最典型的“接口转换器”。</p><h3 id="桥接模式">桥接模式</h3><p>蜡笔具有两个变化维度：</p><ul><li>颜色（12 种）</li><li>型号（大、中、小）</li></ul><p>它们被“绑定在同一类中”：</p><blockquote><p>型号 + 颜色 → 一个具体类</p></blockquote><p>所以：</p><ul><li>增加一种型号 → 多 12 个类</li><li>增加一种颜色 → 多 3 个类</li></ul><p>最终膨胀为 36 个类。</p><p>原因：<strong>两个变化维度没有分离（耦合大）</strong>。</p><hr><p>而毛笔分为：</p><ul><li>型号 → 3 种笔（抽象维度）</li><li>颜色 → 12 种颜料（实现维度）</li></ul><p>组合后仍然可以实现 3×12 的组合，但只需 <strong>3 + 12 = 15 类对象</strong>。</p><p>图形学中的“形状 Shape + 颜色 Color”也是同样的问题。</p><p>此类问题的本质：</p><blockquote><p><strong>某个类存在两个（或多个）独立变化的维度</strong>，但如果写死在一个类中，扩展必然爆炸。</p></blockquote><hr><p><strong>桥接模式</strong>：</p><blockquote><p><strong>将抽象部分与实现部分分离</strong>，使它们都可以独立地变化。</p></blockquote><p>关键词：</p><ul><li>独立变化的维度（如“形状”和“颜色”）</li><li>抽象部分（Abstraction）</li><li>实现部分（Implementor）</li><li>用“对象组合”代替“继承耦合”</li><li>是对象结构型模式</li></ul><p>经常也被叫做：</p><ul><li>Handle and Body</li><li>Interface</li></ul><p><img src="https://images.kisechan.space/20251119211900832.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li><strong>实现接口</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Implementor</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationImpl</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>抽象部分</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> {<br>    <span class="hljs-keyword">protected</span> Implementor impl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImpl</span><span class="hljs-params">(Implementor impl)</span> {<br>        <span class="hljs-built_in">this</span>.impl = impl;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>扩展抽象部分</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 先做抽象类的操作</span><br>        impl.operationImpl();  <span class="hljs-comment">// 调用实现层的方法</span><br>        <span class="hljs-comment">// 再做子类扩展操作</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="桥接模式实例：模拟毛笔">桥接模式实例：模拟毛笔</h4><p>根据课件：3 种型号 × 5 种颜色。</p><ol><li><strong>颜色的维度（Implementor）</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Color</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(String penType, String name)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>不同颜色实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Color</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(String penType, String name)</span> {<br>        System.out.println(penType + <span class="hljs-string">" red "</span> + name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>型号的维度（Abstraction）</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pen</span> {<br>    <span class="hljs-keyword">protected</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(Color color)</span> {<br>        <span class="hljs-built_in">this</span>.color = color;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String name)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>型号的子类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigPen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pen</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String name)</span> {<br>        color.paint(<span class="hljs-string">"Big pen"</span>, name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>使用示例</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pen</span> <span class="hljs-variable">pen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigPen</span>();<br>pen.setColor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Red</span>());<br>pen.draw(<span class="hljs-string">"Flower"</span>);<br></code></pre></td></tr></tbody></table></figure><p><strong>桥接模式的优点</strong>：</p><table><thead><tr><th style="text-align:left">优点</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. 分离抽象与实现</strong>（最核心）</td><td>两个维度可独立变化</td></tr><tr><td style="text-align:left"><strong>2. 替代多重继承</strong></td><td>避免继承层次爆炸</td></tr><tr><td style="text-align:left"><strong>3. 组合优于继承</strong></td><td>更灵活、更可扩展</td></tr><tr><td style="text-align:left"><strong>4. 任意维度扩展不影响对方</strong></td><td>符合开闭原则</td></tr><tr><td style="text-align:left"><strong>5. 运行期动态切换实现</strong></td><td>更灵活</td></tr></tbody></table><p><strong>缺点</strong></p><ul><li>增加设计复杂度</li><li>需要识别“独立变化的维度”，需要经验</li></ul><hr><p><strong>适用场景</strong></p><ul><li>当一个类有 <strong>两个或多个独立变化维度</strong></li><li>不希望使用继承来绑定多个维度</li><li>想要在运行时动态切换某一个维度</li><li>系统要支持组合爆炸（如 3×5）但不能真的写那么多个类</li></ul><hr><blockquote><p>桥接模式的本质是：<strong>分离抽象和实现，让它们可以独立变化。</strong></p></blockquote><p>其余优点（动态切换、减少子类个数等）都是这一点带来的必然结果。</p><hr><h4 id="桥接-适配器模式">桥接 + 适配器模式</h4><p>两种模式的区别：</p><table><thead><tr><th style="text-align:center">点</th><th style="text-align:center">桥接模式</th><th style="text-align:center">适配器模式</th></tr></thead><tbody><tr><td style="text-align:center">目的</td><td style="text-align:center">解耦“抽象与实现”两个独立变化维度</td><td style="text-align:center">兼容已有接口，使旧代码能用</td></tr><tr><td style="text-align:center">用在</td><td style="text-align:center">系统设计初期</td><td style="text-align:center">系统已经成型后，为兼容旧代码/第三方库</td></tr><tr><td style="text-align:center">改代码</td><td style="text-align:center">需要设计两个层次结构</td><td style="text-align:center">不需要改原有类（黑盒）</td></tr><tr><td style="text-align:center">本质</td><td style="text-align:center">组合两个维度</td><td style="text-align:center">转换接口</td></tr><tr><td style="text-align:center">解决问题</td><td style="text-align:center">扩展性和解耦</td><td style="text-align:center">可复用性和兼容性</td></tr></tbody></table><p>一句话总结：</p><blockquote><ul><li>桥接：<strong>设计好的解耦结构</strong></li><li>适配器：<strong>后期发现接口不兼容时的补丁</strong></li></ul></blockquote><hr><p><strong>联用场景</strong>：报表显示 × 数据源读取</p><p>需求：</p><ul><li>报表有多种显示方式（PDF / HTML …）</li><li>数据源有多种读取方式（txt / DB / Excel …）</li></ul><p>→ 报表（抽象维度）<br>→ 数据源（实现维度）</p><p>但 Excel API 由第三方提供，需要：</p><ul><li><code>ExcelDataReaderAdapter</code>（适配器）转为系统可用格式</li><li><code>DataReader</code> 是 bridge 的实现层</li></ul><p>结构示意：</p><p><img src="https://images.kisechan.space/20251119212646602.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p>问：<strong>为什么要桥接 + 适配</strong>？</p><p>因为：</p><ul><li><strong>桥接</strong>解决“报表显示方式 × 数据读取方式”的多维扩展</li><li><strong>适配器</strong>解决“Excel API 与系统接口不兼容”</li></ul><p>进一步总结：</p><table><thead><tr><th>模式</th><th>在此场景中作用</th></tr></thead><tbody><tr><td><strong>桥接</strong></td><td>报表和数据源是两个维度，需灵活组合</td></tr><tr><td><strong>适配器</strong></td><td>Excel API 接口与 <code>DataReader</code> 不兼容</td></tr></tbody></table><p>这一组合在实际系统中极其常见：</p><ul><li>多媒体播放器（视频编码 × 播放方式）</li><li>数据可视化（图表类型 × 数据供应器）</li><li>跨平台 GUI（控件 × 渲染接口）</li></ul><h3 id="组合模式">组合模式</h3><p>现实中大量结构是 <strong>树形结构</strong>，例如：</p><ul><li>文件系统：文件夹里有文件和子文件夹</li><li>公司组织：部门 &gt; 小组 &gt; 员工</li><li>GUI 系统：窗口 &gt; 面板 &gt; 控件</li></ul><p><strong>问题：</strong><br>容器节点（<code>Folder</code>）和叶子节点（<code>File</code>）功能不一样，如果客户端要遍历它们，就必须区分处理：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">if (node is folder) {<br>    traverse children<br>} else if (node is file) {<br>    open file<br>}<br></code></pre></td></tr></tbody></table></figure><p>这会让客户端代码复杂、难以维护。</p><p><strong>组合模式的目标：</strong>“让客户端对叶子对象和容器对象一视同仁（统一处理）。”</p><hr><p><strong>组合模式</strong>：</p><blockquote><p>通过把对象组合成树形结构，让客户端对 <em>整体</em> 和 <em>部分</em> 的使用保持一致。</p></blockquote><ul><li>叶子对象（Leaf）：没有子节点</li><li>容器对象（Composite）：含有子节点（叶子或容器）</li><li>抽象组件（Component）：对两者统一建模并提供相同接口</li><li>客户端（Client）：只依赖 Component，不关心是叶子还是组合</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">    Component<br>   /         \<br>Leaf      Composite<br>               |<br>            children[]<br></code></pre></td></tr></tbody></table></figure><p>Component 中会出现的典型结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">add(c)<br>remove(c)<br>getChild(i)<br>operation()<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>抽象组件</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); }<br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>叶子组件</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"Leaf operation"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>容器组件</strong>（重点：<strong>递归</strong>）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    List&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> { children.add(c); }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> { children.remove(c); }<br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> { <span class="hljs-keyword">return</span> children.get(i); }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">for</span> (Component c : children) {<br>            c.operation();   <span class="hljs-comment">// 递归</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://images.kisechan.space/20251119214330094.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p>实例：<strong>水果盘</strong>（Plate）</p><ul><li>Leaf：Apple, Banana</li><li>Composite：Plate（含若干水果或子盘子）</li><li>调用 <code>operation()</code> → 遍历整个结构并吃掉水果</li></ul><p><img src="https://images.kisechan.space/20251119214246123.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>优点</strong>：</p><ol><li><strong>统一叶子与容器接口</strong> —— 客户端不必区分</li><li><strong>容易扩展</strong> —— 添加新的 Leaf 或 Composite 不影响原有代码</li><li><strong>天然适配树结构</strong> —— 遍历用递归即可</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>难以限制容器的子类型</strong>（可能放入非法类型组件）</li><li><strong>管理子节点操作可能导致叶子类出现无意义方法</strong>（透明模式）</li></ol><h4 id="透明组合模式">透明组合模式</h4><p>较为常见</p><p><code>Component</code> 中包含 <code>add</code>/<code>remove</code>/<code>getChild()</code><br>→ 客户端统一处理<br>→ <strong><code>Leaf</code> 中这些方法无意义，但必须实现（抛异常）</strong></p><h4 id="安全组合模式">安全组合模式</h4><p><code>Component</code> 不包含 <code>add</code>/<code>remove</code>/<code>getChild</code>，<code>Composite</code> 中才有 <code>add</code>/<code>remove</code><br>→ 安全，但客户端必须区分 <code>Composite</code>/<code>Leaf</code></p><hr><blockquote><p>组合模式的本质：<strong>统一叶子对象和组合对象</strong>。</p></blockquote><p>客户端只面对 Component，不管是整体还是部分都一样使用。</p><h3 id="装饰模式">装饰模式</h3><p>给对象<strong>动态添加功能</strong>有几种方式：</p><ol><li><strong>继承</strong>（缺点：静态、组合爆炸）</li></ol><p>想给 Car 添加各种功能：</p><ul><li>会说话</li><li>会飞</li><li>会射击</li><li>会游泳</li></ul><p>如果用继承：</p><blockquote><p><code>FlyingTalkingSwimmingShootingCar</code></p></blockquote><p>类爆炸，扩展困难。</p><ol start="2"><li><strong>关联</strong>（装饰模式思想）</li></ol><blockquote><p><code>Car</code> -&gt; 装饰器(飞) -&gt; 装饰器(说话) -&gt; 装饰器(泳)</p></blockquote><p><strong>动态组合、随装随改、可多次叠加。</strong></p><hr><p>装饰模式通过创建一个“<strong>装饰器对象</strong>”包裹原对象，在原方法执行的前后增强行为，实现功能的动态叠加。</p><p>别名：Wrapper（包装器）</p><blockquote><p>装饰模式的核心：<strong>动态组合，而不是继承</strong>。</p></blockquote><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">         Component<br>      /              \<br>ConcreteComponent  Decorator<br>                      |<br>             ConcreteDecoratorA<br>             ConcreteDecoratorB<br></code></pre></td></tr></tbody></table></figure><p><img src="https://images.kisechan.space/20251119214859977.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>抽象组件</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体组件</strong>（被装饰对象）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"基础功能"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>抽象装饰类</strong>（关键）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">protected</span> Component component;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component c)</span> {<br>        <span class="hljs-built_in">this</span>.component = c;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        component.operation();   <span class="hljs-comment">// 默认先调用原功能</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体装饰器</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecoratorA</span><span class="hljs-params">(Component c)</span> { <span class="hljs-built_in">super</span>(c); }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        <span class="hljs-built_in">super</span>.operation();<br>        System.out.println(<span class="hljs-string">"附加功能A"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p>实例：<strong>变形金刚</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Car <span class="hljs-comment">(基础)</span><br>  ↓ 装饰为 Robot<br>Robot <br>  ↓ 再装饰为 飞机<br>RobotFly<br></code></pre></td></tr></tbody></table></figure><p>客户端：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Component</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RobotDecorator</span>(c);   <span class="hljs-comment">// 变成机器人</span><br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirplaneDecorator</span>(c); <span class="hljs-comment">// 加飞行能力</span><br>c.operation();<br></code></pre></td></tr></tbody></table></figure><p><strong>优点</strong>：</p><ol><li><strong>比继承更灵活（组合 &gt; 继承）</strong></li><li><strong>功能小而单一，易复用</strong></li><li><strong>动态：运行时自由叠加</strong></li></ol><p><strong>缺点</strong>：</p><ol><li><strong>类数变多</strong>（每一种功能一个装饰器）</li><li><strong>排查问题（多层嵌套）较困难</strong></li></ol><hr><p><strong>适用场景</strong></p><ul><li>不改原有类结构，但想给对象添加功能</li><li>许多独立功能需要自由组合</li><li>类不能继承（例如 <code>final class</code>）</li></ul><p>特别常见于：</p><ul><li><strong>Java I/O 体系（最典型）</strong></li><li><strong>Swing/<code>JScrollPane</code> 装饰 <code>JList</code></strong></li><li><strong>流式 API 中增强行为</strong></li></ul><h4 id="透明装饰模式">透明装饰模式</h4><p>所有东西都用 <code>Component</code> 类型接收：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Component</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvancedDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>()));<br></code></pre></td></tr></tbody></table></figure><h4 id="半透明装饰模式">半透明装饰模式</h4><p>更常见。</p><p>允许访问具体装饰器的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Robot</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Robot</span>(car);<br>r.say();  <span class="hljs-comment">// 特有功能</span><br></code></pre></td></tr></tbody></table></figure><hr><blockquote><p>装饰模式的本质是“<strong>动态组合对象行为</strong>”。</p></blockquote><ul><li>动态（运行时）</li><li>组合（不是继承）</li><li>通过叠加装饰器来增强功能</li></ul><h2 id="参考和注解">参考和注解</h2><ul><li>这个学长的笔记：<a target="_blank" rel="noopener" href="https://blog.chencs.online/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/">https://blog.chencs.online/posts/设计模式应试笔记/</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="print-no-link">#设计模式</a></div></div><div class="license-box my-3"><div class="license-title"><div>软件设计模式 课程笔记</div><div>https://blog.kisechan.space/2025/notes-design-pattern/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kisechan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年11月15日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2025年11月19日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/notes-machine-learning/" title="机器学习 课程笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">机器学习 课程笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/db-engine-2/" title="设计一个数据库引擎 (2) 索引"><span class="hidden-mobile">设计一个数据库引擎 (2) 索引</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",function(){var e=Object.assign({clientID:"Ov23liWYIiu2jxReIEhB",clientSecret:"d7b44817ae2553b2175fdecfde9718b582bdc653",repo:"Comment-Kisechan",owner:"Kisechan",admin:["Kisechan"],language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!0,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enabled:!0},{id:"b46cbace8fa64af2c1ae854a18cd6771"});new Gitalk(e).render("gitalk-container")})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded(function(){Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})})</script><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><div><span>Frame by <a href="https://hexo.io" target="_blank" rel="nofollow noopener">Hexo</a></span> <span>| Theme <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></span></div><div style="font-size:.85rem"><span><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></span><span><script async src="https://views.kisechan.space/views.js"></script><br><span id="my-site-view">本站总访问量：加载中...</span><br><br><span>&copy; 2024 - 2025 By <a href="https://github.com/Kisechan" target="_blank" rel="nofollow noopener"><strong>Kisechan</strong></a><br></span><span>今天也很喜欢你！</span><br><a href="https://icp.gov.moe/?keyword=20251453" target="_blank">萌ICP备20251453号</a></span></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/linkcard.js"></script><script src="/js/cursor.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script><script type="text/javascript">var originalTitle=document.title;window.onblur=function(){document.title="等你回来哦"},window.onfocus=function(){document.title=originalTitle}</script><div id="tooltip-rightmenu" class="tooltip-rightmenu">如果需要使用原始右键菜单请按下 <strong>Ctrl+右键</strong></div><div id="tooltip-clipboard" class="tooltip-rightmenu">链接复制成功！</div><div id="rightmenu-wrapper"><ul class="list-v rightmenu" id="rightmenu-content"><li class="navigation menuNavigation-Content"><a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa fa-arrow-left rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa fa-arrow-right rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa fa-refresh rightmenu-icon"></i></a> <a aria-label="TOP" href="#" role="button"><i class="fa fa-arrow-up rightmenu-icon"></i></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><span><i class="fa fa-search rightmenu-icon"></i> 站内搜索</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="toggleFullScreen()"><span><i class="fa fa-arrows-alt rightmenu-icon"></i> 切换全屏</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="copyPageUrl()"><span><i class="fa fa-clipboard rightmenu-icon"></i> 复制链接</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="scrollToComments()"><span><i class="fa fa-commenting rightmenu-icon"></i> 立即评论</span></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_blank" rel="noopener" href="https://www.kisechan.space/" data-group="link"><span><i class="fa fa-info-circle rightmenu-icon"></i> 关于本站</span></a></li></ul></div><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/css/custom_right_menu_icons.css" type="text/css" rel="stylesheet"><script src="/js/right_menu.js" type="text/javascript"></script><link href="/css/right_menu.css" type="text/css" rel="stylesheet"><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>