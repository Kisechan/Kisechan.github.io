<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><link rel=manifest href=/manifest.json><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://images.kisechan.space/apple-touch-icon.png"><link rel="icon" href="https://images.kisechan.space/icon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#004e66"><meta name="author" content="Kisechan"><meta name="keywords" content=""><meta name="description" content="▶Mermaid 代码                                  1234567891011121314151617181920212223242526272829303132333435363738394041mindmap  root((软件设计模式 SDP))    面向对象基础      课程概述      面向对象设计与"><meta property="og:type" content="article"><meta property="og:title" content="软件设计模式 课程笔记"><meta property="og:url" content="https://blog.kisechan.space/2025/notes-design-pattern/index.html"><meta property="og:site_name" content="Kisechan&#39;s Blog"><meta property="og:description" content="▶Mermaid 代码                                  1234567891011121314151617181920212223242526272829303132333435363738394041mindmap  root((软件设计模式 SDP))    面向对象基础      课程概述      面向对象设计与"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.kisechan.space/%E3%81%93%E3%81%A3%E3%81%9D%E3%82%8A%E3%83%81%E3%83%A7%E3%82%B3%E3%83%AC%E3%83%BC%E3%83%88_73129157.jpg"><meta property="article:published_time" content="2025-11-15T06:12:35.000Z"><meta property="article:modified_time" content="2025-11-15T08:51:12.107Z"><meta property="article:author" content="Kisechan"><meta property="article:tag" content="设计模式"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://images.kisechan.space/%E3%81%93%E3%81%A3%E3%81%9D%E3%82%8A%E3%83%81%E3%83%A7%E3%82%B3%E3%83%AC%E3%83%BC%E3%83%88_73129157.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><title>软件设计模式 课程笔记 - Kisechan&#39;s Blog</title><link rel="stylesheet" type="text/css" href="/css/loading.css"><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4890189_m2l1f174snq.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"blog.kisechan.space",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),n=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3837;break}}),i=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+6136;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="Kisechan's Blog" type="application/atom+xml">
</head><body><div><div class="real_mask" style="background-color:rgba(0,0,0,.3);width:100%;height:100%;position:fixed;z-index:-777"></div><div id="banner_video_insert"></div><div id="vvd_banner_img"></div></div><div id="banner"></div><div id="loader-box"><div class="loader-wrapper"><div class="loader"></div><div class="loader-text"><div>L</div><div>O</div><div>A</div><div>D</div><div>I</div><div>N</div><div>G</div><div></div><div></div><div></div></div></div><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loader-box").remove()};window.addEventListener("load",endLoading)</script></div><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KISECHAN</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-Homehomepagemenu"></i> <span>博客</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-newstextarticle"></i> <span>文章</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-categories"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user"></i> <span>关于</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/about/" target="_self"><i class="iconfont icon-info-fill"></i> <span>关于</span> </a><a class="dropdown-item" href="/playlist/" target="_self"><i class="iconfont icon-music"></i> <span>歌单</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/Kisechan.github.io" target="_self"><i class="iconfont icon-git"></i> <span>仓库</span> </a><a class="dropdown-item" href="/atom.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS</span></a></div></li><li class="nav-item"><a class="nav-link" href="https://www.kisechan.space/tools/" target="_self"><i class="iconfont icon-tool-fill"></i> <span>工具</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link"></i> <span>友链</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.travellings.cn/go.html" target="_self"><i class="iconfont icon-train"></i> <span>开往</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://images.kisechan.space/202502042159748.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">软件设计模式 课程笔记</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kisechan </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-11-15 14:12" pubdate>2025年11月15日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.5k 字 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div><script type="text/javascript" src="/vvd_js/jquery.js"></script><div class="banner" id="banner"><div class="full-bg-img"></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="课程笔记" id="heading-311a46cfdaa3afda544e9285644f70d7" role="tab" data-toggle="collapse" href="#collapse-311a46cfdaa3afda544e9285644f70d7" aria-expanded="true">课程笔记 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-311a46cfdaa3afda544e9285644f70d7" role="tabpanel" aria-labelledby="heading-311a46cfdaa3afda544e9285644f70d7"><div class="category-post-list"><a href="/2024/oop/" title="面向对象程序设计课程笔记" class="list-group-item list-group-item-action"><span class="category-post">面向对象程序设计课程笔记</span> </a><a href="/2024/linux-note/" title="Linux课程笔记" class="list-group-item list-group-item-action"><span class="category-post">Linux课程笔记</span> </a><a href="/2024/ds/" title="数据结构课程板子合集&amp;笔记" class="list-group-item list-group-item-action"><span class="category-post">数据结构课程板子合集&amp;笔记</span> </a><a href="/2025/notes-algorithm-analysis/" title="算法设计与分析 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">算法设计与分析 课程笔记</span> </a><a href="/2025/notes-database-1/" title="数据库原理 课程笔记 (1) 数据库、关系代数和 SQL" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (1) 数据库、关系代数和 SQL</span> </a><a href="/2025/notes-database-2/" title="数据库原理 课程笔记 (2) E-R 模型和关系模式" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (2) E-R 模型和关系模式</span> </a><a href="/2025/notes-database-3/" title="数据库原理 课程笔记 (3) 存储、索引、事务和并发" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (3) 存储、索引、事务和并发</span> </a><a href="/2025/notes-database-4/" title="数据库原理 课程笔记 (4) 杂项和题目整理" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (4) 杂项和题目整理</span> </a><a href="/2025/notes-os/" title="操作系统复习" class="list-group-item list-group-item-action"><span class="category-post">操作系统复习</span> </a><a href="/2025/notes-ptms/" title="概率论与数理统计" class="list-group-item list-group-item-action"><span class="category-post">概率论与数理统计</span> </a><a href="/2025/notes-java/" title="Java 程序设计" class="list-group-item list-group-item-action"><span class="category-post">Java 程序设计</span> </a><a href="/2025/notes-networks/" title="计算机网络课程笔记" class="list-group-item list-group-item-action"><span class="category-post">计算机网络课程笔记</span> </a><a href="/2025/notes-se-1/" title="软件工程课程笔记 (1)" class="list-group-item list-group-item-action"><span class="category-post">软件工程课程笔记 (1)</span> </a><a href="/2025/notes-design-pattern/" title="软件设计模式 课程笔记" class="list-group-item list-group-item-action active"><span class="category-post">软件设计模式 课程笔记</span> </a><a href="/2025/notes-machine-learning/" title="机器学习 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">机器学习 课程笔记</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">软件设计模式 课程笔记</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2025-11-15T16:51:12+08:00</p><div class="markdown-body"><p><img src="https://images.kisechan.space/20251115161935679.png" srcset="/img/loading.gif" lazyload alt="设计模式课程的主要内容"></p><div class="fold"><div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-65ad56e5" role="button" aria-expanded="false" aria-controls="collapse-65ad56e5"><div class="fold-arrow">▶</div>Mermaid 代码</div><div class="fold-collapse collapse" id="collapse-65ad56e5"><div class="fold-content"><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs text">mindmap<br>  root((软件设计模式 SDP))<br>    面向对象基础<br>      课程概述<br>      面向对象设计与复用<br>      类间关系与UML<br>      OO设计原则（SOLID等）<br>    设计模式概述<br>      模式的由来<br>      GoF 23模式<br>      模式的分类<br>      模式组成(意图、结构、优缺点、适用场景)<br>    创建型模式<br>      简单工厂<br>      工厂方法<br>      抽象工厂<br>      建造者<br>      原型<br>      单例<br>    结构型模式<br>      适配器<br>      桥接<br>      组合<br>      装饰<br>      外观<br>      享元<br>      代理<br>    行为型模式<br>      职责链<br>      命令<br>      迭代器<br>      中介者<br>      备忘录<br>      观察者<br>      状态<br>      策略<br>      模板方法<br>    总结<br>      设计模式的目的<br>      模式之间的对比<br>      如何在工程中运用模式<br></code></pre></td></tr></tbody></table></figure></div></div></div><h2 id="面向对象和设计模式">面向对象和设计模式</h2><h3 id="设计模式概论">设计模式概论</h3><p>设计模式面向对象技术发展到一定阶段后的产物。</p><ul><li>是<strong>被反复使用、众所周知并经过总结分类的面向对象设计经验</strong>。</li><li>对面向对象系统中的复杂问题提供通用解决方案。</li><li><strong>设计模式对面向对象开发的意义</strong>约等于<strong>数据结构对面向过程开发的意义</strong>。</li><li>设计模式能帮助开发者实现：<ul><li>可维护</li><li>可复用</li><li>可扩展</li><li>灵活性高</li></ul></li><li>能更快地成长为优秀的软件开发工程师。</li></ul><p>设计模式本质上是 <strong>对面向对象思想的深化与实践</strong>。学习设计模式能更深入理解 OO 概念与 OO 软件体系结构。</p><h3 id="面向对象（Object-Oriented）">面向对象（Object-Oriented）</h3><p>Coad 提出：<strong>面向对象 = 对象 + 类 + 继承 + 通信</strong>。</p><p>面向对象的特点是：</p><ul><li>既是一种 <strong>编程范式</strong>，也是一套 <strong>系统开发方法论</strong>。</li><li>是对现实世界的抽象：把相关的数据和方法组合为“对象”。</li><li>相对于面向过程，更符合自然事物建模方式。</li></ul><h4 id="OO-的目标">OO 的目标</h4><ul><li><strong>可维护</strong>：修改局部，不影响整体</li><li><strong>可复用</strong>：类和组件可多次使用</li><li><strong>可扩展</strong>：加新功能不破坏旧结构</li><li><strong>灵活性</strong>：结构可组合、可替换、可重组</li></ul><blockquote><p>比喻：活字印刷术中，可更换、重排的“字块”</p></blockquote><h4 id="面向对象编程语言">面向对象编程语言</h4><p>现代主流语言几乎全部支持或围绕 OOP 构建，如： Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP 等。</p><h4 id="面向对象开发方法">面向对象开发方法</h4><p>OO 方法贯穿开发方法的整个生命周期</p><ul><li>OOA：对象分析</li><li>OOD：对象设计</li><li>OOP：对象编程</li><li>OOT：对象测试</li><li>OOSM：对象维护</li></ul><p>面向对象不只是编程语言，更是一整套软件工程方法论。</p><h4 id="面向对象的发展与全貌">面向对象的发展与全貌</h4><h5 id="历史演进">历史演进</h5><ul><li><strong>Simula 67</strong>（1967，挪威）：首次引入类、继承、多态 → 第一门真正意义的 OOPL</li><li><strong>Smalltalk</strong>：确立 OO 思想</li><li>后续语言：C++、Objective-C、Java、C#、Ruby 等</li></ul><h5 id="形成的体系">形成的体系</h5><ul><li>OOPL：支持 OO 的语言</li><li>OOP：利用 OOPL 进行 OO 编程</li><li>类库 &amp; 框架：OOP 促进大规模可复用组件库出现</li><li>设计模式：在类库、框架设计过程中沉淀出的“可复用设计思想”</li></ul><h5 id="配套方法与工具">配套方法与工具</h5><ul><li><strong>UML（统一建模语言）</strong>：用图形表示 OO 软件结构</li><li>OO 建模方法、开发流程</li><li>OO 已成为覆盖整个开发流程的综合技术体系</li></ul><h5 id="目标">目标</h5><ul><li>利用前人经验（模式、框架、建模方法）</li><li>提高软件质量与开发效率</li><li>支持大规模复杂软件的管理与设计</li></ul><h3 id="面向对象设计">面向对象设计</h3><p>OO 设计是对“<strong>面向对象分析结果</strong>”的进一步整理，使其能够被直接用于面向对象编程。目标是<strong>把分析的对象、关系、职责，转化为可实现的类、方法、属性以及组件结构</strong>。</p><p>面向对象设计的三个层次：</p><ul><li>框架级设计</li><li>类设计</li><li>代码设计</li></ul><h4 id="框架级设计（Framework-Level）">框架级设计（Framework Level）</h4><p>框架是从一类特定软件中抽象出的<strong>可复用、协作的类群</strong>，定义了软件的体系结构。关注点：</p><ul><li>类如何分组 → 包（Package）</li><li>包之间如何协同</li><li>抽象层较高，强调复用与架构组织</li></ul><p>常见例子：三层逻辑架构（UI → 业务逻辑 → 数据库）</p><hr><h5 id="包（Package）与包结构原则">包（Package）与包结构原则</h5><p>包的六大原则分两类：</p><ul><li><p><strong>包的内聚性原则</strong>（决定类如何划分到包中）</p><ol><li><strong>重用发布等价原则 REP</strong><ul><li>复用的粒度 = 发布的粒度</li><li>复用的类应打包在一起，以便统一发布。</li></ul></li><li><strong>共同重用原则 CRP</strong><ul><li>经常一起变化的类应放在同一包中（高内聚）。</li><li>避免把不相关的类打包在一起。</li></ul></li><li><strong>共同封闭原则 CCP</strong><ul><li>对同一类变化原因负责的类，应放同一包中。</li><li>提升修改的局部性。</li></ul></li></ol></li><li><p><strong>包的耦合性原则</strong>（决定包与包之间如何连接）</p><ol start="4"><li><p><strong>无环依赖原则 ADP</strong></p><ul><li><p>包之间不能出现循环依赖。</p></li><li><p>保证架构清晰、可维护、可编译。</p></li></ul></li><li><p><strong>稳定依赖原则 SDP</strong></p><ul><li>不稳定的包应依赖稳定的包。</li><li>避免不稳定组件成为系统“根”。</li></ul></li><li><p><strong>稳定抽象原则 SAP</strong></p><ul><li><p>稳定的包应更抽象（用接口/抽象类）。</p></li><li><p>稳定 ≠ 僵化。</p></li></ul></li></ol></li></ul><h4 id="类设计（Class-Level）">类设计（Class Level）</h4><p>关注对象、类、属性、行为的抽象与组织方式。</p><ul><li>解决如何将现实世界对象转化为类结构，如何定义其行为和属性。</li><li>软件设计模式属于此层次（Factory、Singleton、Strategy 等）。</li></ul><hr><h5 id="类的定义">类的定义</h5><ul><li>对象：问题域中的实体抽象</li><li>类：对象属性与行为的模板</li></ul><p>类设计要处理：</p><ul><li>类的组织与表示</li><li>行为（方法）的组织</li><li>属性的组织</li><li>类之间的关系（复用、耦合度）</li></ul><h5 id="类的组织与表示（从现实到抽象）">类的组织与表示（从现实到抽象）</h5><ul><li><strong>类的发现</strong>：从具体实例抽象，例如：苹果、香蕉 → 水果类</li><li><strong>聚类分析</strong>：找出对象集合的共同特征</li><li><strong>类的再抽象</strong>：进一步抽象成更通用概念，如“水果”或模板“List<t>”</t></li><li><strong>类的拆分</strong>：一个类中不属于核心领域的部分应拆出（如水果篮中的鲜花）</li><li><strong>类的可见性</strong>：区分公开、私有成员（对外接口 vs 内部实现）</li><li><strong>类的复用性（高内聚、低耦合）</strong></li></ul><h5 id="行为（方法）的组织与表示">行为（方法）的组织与表示</h5><ul><li><strong>行为的参与者</strong>：行为涉及的对象（老鼠吃水果）</li><li><strong>行为分组与接口</strong>：例如吃香蕉 / 吃苹果 → 吃水果</li><li><strong>行为分解</strong>：抽象行为的内部步骤（剥皮 → 吃 → 吐核）</li><li><strong>行为的可见性</strong>：内部实现与外部接口区分</li><li><strong>行为的返回结果</strong>：吃水果返回成功/失败/数量</li><li><strong>行为的差异性</strong>：不同对象实现同一行为（多态）</li></ul><h5 id="属性的组织与表示">属性的组织与表示</h5><ul><li>属性类型：内置、自定义</li><li>可访问性：只读、只写、读写</li><li>不变属性：不会随时间变化（身份证号）</li><li>类属性 vs 实例属性：如“扑克牌背面图案”是类属性</li><li>属性可见性：常隐藏，靠 getter/setter 暴露</li><li>属性设计依赖具体编程语言特性</li></ul><hr><h5 id="变化">变化</h5><p>这是类设计的核心难点。</p><h6 id="职责的变化（接口变化）">职责的变化（接口变化）</h6><ul><li>行为签名改变</li><li>新增功能</li><li>可访问性改变</li></ul><h6 id="实现的变化（内部变化）">实现的变化（内部变化）</h6><ul><li>数据类型变化</li><li>数据结构变化</li><li>行为算法变化</li></ul><p>示例分析：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//0. 新增函数 f1    （职责变化）</span><br>     <span class="hljs-comment">//1. f 参数表可能变化（职责变化）</span><br>     <span class="hljs-comment">//2. f 的具体实现变化（实现变化）</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">//3. 数据类型变化（实现变化）</span><br>     <span class="hljs-comment">//4. 数据结构变化（实现变化）</span><br>     <span class="hljs-type">int</span> nums[<span class="hljs-number">50</span>];<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h6 id="应对变化的两种方式">应对变化的两种方式</h6><ol><li><p><strong>修改既有代码</strong></p><ul><li><p>缺点：</p><ul><li><p>可能无法访问源码</p></li><li><p>修改已发布代码风险高</p></li><li><p>修改接口可能影响大量调用者</p></li></ul></li></ul></li><li><p><strong>扩展既有代码</strong>（OO 推荐方式）</p><ul><li><p>使用类关系扩展系统：</p><ul><li><p><strong>继承扩展</strong>（最常见但谨慎使用）</p></li><li><p><strong>依赖扩展</strong></p></li><li><p><strong>关联扩展</strong></p></li><li><p><strong>聚合扩展</strong></p></li><li><p><strong>组合扩展</strong></p></li></ul></li><li><p>目标：遵守开闭原则（对扩展开放，对修改关闭）。</p></li></ul></li></ol><h4 id="代码设计（Code-Level）">代码设计（Code Level）</h4><p>类的具体实现（物理级）：源代码、二进制代码、可执行代码。关注：</p><ul><li>性能</li><li>可部署性</li><li>可移植性</li><li>代码结构与文件组织方式</li></ul><h3 id="关系模型与设计模式的关联">关系模型与设计模式的关联</h3><h4 id="关系模型（类间关系）是复用的基础">关系模型（类间关系）是复用的基础</h4><p>类之间的关系是 OO 中复用的工具。</p><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">强度</th><th style="text-align:center">UML 表示</th><th style="text-align:center">关键语义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>依赖</strong>（Dependency）</td><td style="text-align:center">⭐</td><td style="text-align:center"><strong>虚线箭头</strong></td><td style="text-align:center">临时使用，弱关系</td></tr><tr><td style="text-align:center"><strong>关联</strong>（Association）</td><td style="text-align:center">⭐⭐</td><td style="text-align:center"><strong>实线箭头</strong></td><td style="text-align:center">长期使用，语义级关系</td></tr><tr><td style="text-align:center"><strong>聚合</strong>（Aggregation）</td><td style="text-align:center">⭐⭐⭐</td><td style="text-align:center"><strong>空心菱形 + 实线</strong></td><td style="text-align:center">整体-部分，可分离</td></tr><tr><td style="text-align:center"><strong>组合</strong>（Composition）</td><td style="text-align:center">⭐⭐⭐⭐</td><td style="text-align:center"><strong>实心菱形 + 实线</strong></td><td style="text-align:center">整体-部分，不可分离</td></tr><tr><td style="text-align:center"><strong>泛化</strong>（Generalization）</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center"><strong>空心三角实线</strong></td><td style="text-align:center">继承，有实现复用</td></tr><tr><td style="text-align:center"><strong>实现</strong>（Realization）</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center"><strong>空心三角虚线</strong></td><td style="text-align:center">实现接口，无实现继承</td></tr></tbody></table><h5 id="依赖（Dependency）">依赖（Dependency）</h5><ul><li>A <strong>使用到</strong> B，但这种关系 <strong>偶然、弱、短暂</strong></li><li>B 的变化会影响到 A，但二者并不是长期绑定</li></ul><p>典型代码表现有：</p><ul><li>方法参数</li><li>方法内部局部变量</li><li>调用对方静态方法</li><li>临时 <code>new</code>/<code>delete</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B* b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B&amp; b)</span></span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>UML 表示用虚线箭头，A → B 表示 “A 依赖 B”。</p><p>示例：</p><ul><li>老鼠吃苹果</li><li>人借车移动</li><li>警察抓小偷（也可设计为更复杂的双向依赖）</li><li>Screen（画布）依赖 Shape 的绘制接口</li><li>Mouse 依赖 Fruit（通过子类型适配多种水果变化）</li></ul><hr><p>关键思想：</p><p>依赖关系用于<strong>适应短期变化</strong>。</p><p>常见的使用方法：</p><ul><li>参数多态（<code>Fruit&amp;</code>）</li><li>子类型化适应扩展（<code>Cat</code>/<code>Dog</code> 类型化 <code>Monster</code>）</li></ul><h5 id="关联（Association）">关联（Association）</h5><ul><li>A 和 B <strong>长期存在语义关联</strong></li><li>强于依赖</li><li>双方地位平等（通常）</li></ul><p>UML 用实线箭头 A → B（单向）或实线无箭头（双向）表示</p><p>代码特征通常表现为 <strong>成员变量</strong>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CWife</span> {<br>    CHusband* husband;  <span class="hljs-comment">// 关联</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>关联分三大类：</p><ol><li><strong>单向关联</strong>：只有一方持有对方</li><li><strong>双向关联</strong>：双方互相持有</li><li><strong>自身关联</strong>：类内部引用自己（如链表 Node）</li></ol><p>示例：</p><ul><li>英雄（Hero）持有宝物（Goods）</li><li>学生（Student）拥有宿舍（Dorm）</li><li>丈夫 ↔ 妻子（双向）</li><li>链表 Node 自身关联 nextNode</li></ul><p>本质上，关联描述一种 <strong>更稳定的“使用关系”</strong>。 生命周期独立，但逻辑联系长期存在。</p><hr><h5 id="聚合（Aggregation）">聚合（Aggregation）</h5><ul><li>“整体–部分（has-a）”关系</li><li>部分 <strong>可以独立于整体存在</strong></li><li>关系 <strong>弱于组合</strong></li></ul><p>例如：</p><ul><li>自行车 — 轮胎；</li><li>学生 — 宿舍；</li><li>科研团队 — 科研人员。</li></ul><p>UML 用空心菱形 + 实线表示。</p><pre><code class="mermaid">classDiagram
    class A
    class B
    A o-- B
</code></pre><p>代码例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dorm</span> {<br>    Student** mStudents;  <span class="hljs-comment">// 但学生可独立存在</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>特性：</p><ul><li>整体与部分可分离</li><li>生命周期不绑定</li><li>常用于“容器拥有元素”</li></ul><p>示例扩展：</p><ul><li>果篮–水果</li><li>防盗门–锁</li><li>Grid 包含多个 Rect（绘图示例）</li></ul><h5 id="组合（Composition）">组合（Composition）</h5><p>强聚合（比聚合强），部分的生命周期 <strong>完全依赖整体</strong></p><p>例如：</p><ul><li>人和大脑</li><li>窗口和标题栏</li><li>公司和部门（生命周期绑定）</li></ul><p>UML 用实心菱形 + 实线表示</p><pre><code class="mermaid">classDiagram
    class Whole
    class Part
    Whole *-- Part
</code></pre><p>代码特征：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    B b;          <span class="hljs-comment">// 组合：整体负责部分的生命周期</span><br>};<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    B* b;<br>    <span class="hljs-built_in">A</span>() { b = <span class="hljs-keyword">new</span> B; }<br>    ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">delete</span> b; }<br>};<br></code></pre></td></tr></tbody></table></figure><p>特征：</p><ul><li>部分不能脱离整体生存</li><li>整体被析构 → 部分也被析构</li><li>表现更强的所有权</li></ul><h5 id="泛化（Generalization）">泛化（Generalization）</h5><ul><li>“一般–特殊”关系</li><li><strong>继承</strong></li><li>子类继承父类的<strong>属性和实现</strong></li></ul><p>UML 用空心三角形 + 实线表示子类 → 父类</p><pre><code class="mermaid">classDiagram
    Animal &lt;|-- Tiger
</code></pre><p>示例：</p><ul><li>Monster ← Cat</li><li>Monster ← Dog</li><li>Animal ← Tiger</li></ul><hr><h5 id="实现（Realization）">实现（Realization）</h5><p>类实现接口，类似 Java 的 <code>implements</code>。</p><p>和泛化的区别：</p><ul><li><strong>泛化</strong>：继承父类的实现（代码）</li><li><strong>实现</strong>：仅继承接口，无实现</li></ul><p>UML 用空心三角形 + 虚线表示：</p><pre><code class="mermaid">classDiagram
    IAnimal &lt;|.. Animal
</code></pre><h4 id="设计原则是行为准则">设计原则是行为准则</h4><p>面向对象从提出到成熟经历了大量实践，逐渐沉淀出 <strong>七大设计原则</strong>。<br>它们可分为两类：</p><ul><li><p><strong>设计目标</strong>（设计的“方向”），重点：让系统<strong>稳定</strong>、<strong>可扩展</strong>、<strong>可维护</strong></p><ol><li><strong>开闭原则</strong> OCP</li><li><strong>里氏替换原则</strong> LSP</li><li><strong>迪米特原则</strong> LoD（最少知道原则）</li></ol></li><li><p><strong>设计方法</strong>（如何“做到”），重点：实现<strong>高内聚</strong>、<strong>低耦合</strong></p><ol><li><strong>单一职责原则</strong> SRP</li><li><strong>接口分隔原则</strong> ISP</li><li><strong>依赖倒置原则</strong> DIP</li><li><strong>组合/聚合复用原则</strong> CARP</li></ol></li></ul><p>这七个原则不是孤立的，互相强化。</p><p><strong>OCP 是核心，其他六条都是帮助我们实现 OCP 的工具。</strong></p><table><thead><tr><th style="text-align:center">原则</th><th style="text-align:center">中文名</th><th style="text-align:center">作用</th><th style="text-align:center">与 OCP 的关系</th></tr></thead><tbody><tr><td style="text-align:center">OCP</td><td style="text-align:center">开闭原则</td><td style="text-align:center">最终目标：可扩展、可维护</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LSP</td><td style="text-align:center">里氏替换原则</td><td style="text-align:center">正确继承，确保扩展不会破坏原有功能</td><td style="text-align:center">OCP 的根基</td></tr><tr><td style="text-align:center">LoD</td><td style="text-align:center">迪米特原则</td><td style="text-align:center">减少耦合，间接提高可扩展性</td><td style="text-align:center">提供低耦合环境</td></tr><tr><td style="text-align:center">SRP</td><td style="text-align:center">单一职责原则</td><td style="text-align:center">单一职责，使扩展简单</td><td style="text-align:center">便于扩展、减少修改</td></tr><tr><td style="text-align:center">ISP</td><td style="text-align:center">接口分隔原则</td><td style="text-align:center">专门接口，提高灵活性</td><td style="text-align:center">避免修改胖接口</td></tr><tr><td style="text-align:center">DIP</td><td style="text-align:center">依赖倒置原则</td><td style="text-align:center">高层不依赖低层，实现可替换</td><td style="text-align:center">通过抽象实现 OCP</td></tr><tr><td style="text-align:center">CARP</td><td style="text-align:center">组合/聚合复用原则</td><td style="text-align:center">用组合支持扩展、减少继承修改</td><td style="text-align:center">扩展开放、修改关闭</td></tr></tbody></table><div class="note note-info"><p>面向对象七大原则的核心是“开闭原则”，它强调对扩展开放、对修改关闭。</p><p>里氏替换原则保证继承结构的正确性；迪米特原则降低耦合；单一职责原则和接口隔离原则控制了类与接口的粒度；依赖倒置原则通过抽象降低层间依赖；组合/聚合复用原则提供了一种比继承更稳定的复用机制。</p><p>它们共同协作以提高软件的可扩展性、可维护性和稳定性。</p></div><h5 id="开闭原则（Open-Closed-Principle-OCP）">开闭原则（Open-Closed Principle, OCP）</h5><blockquote><p>软件实体应该<em>对扩展开放</em>，<em>对修改关闭</em>。</p></blockquote><p>即：添加功能<strong>不改旧代码，通过扩展类/接口实现新行为</strong>。</p><p>意义：</p><ul><li><strong>稳定性</strong>：减少修改旧模块引入 bug。</li><li><strong>扩展性</strong>：通过新类扩展系统能力。</li></ul><p>如何实现？</p><ul><li>找出系统中“变化点”，抽象为接口。</li><li>使用“面向接口编程”而不是面向实现。</li><li>新行为 = 新类 + 实现既有接口，而不是改旧类。</li></ul><p>典型反例：</p><blockquote><p>绘图程序中有 <code>Circle</code>、<code>Square</code>，错误设计用 <code>switch-case</code> 判断类型 → 违反 OCP。</p></blockquote><p>正确方法：</p><blockquote><p>给 <code>Shape</code> 定义抽象方法 <code>draw()</code>，每个图形类实现自己的 draw。</p></blockquote><hr><h5 id="里氏替换原则（LSP）">里氏替换原则（LSP）</h5><blockquote><p>任何父类出现的地方，子类必须能够透明替换，并保持程序正确性。</p></blockquote><p>一句话：<strong>子类必须完全遵守父类的行为契约</strong>。</p><p>违反的表现：</p><ul><li>用 <code>typeid</code>、<code>instanceof</code> 判断类型 → 明显违反 LSP。</li><li>子类重写方法后导致父类行为被破坏。</li></ul><p>经典反例：</p><blockquote><p><code>Square</code> 继承 <code>Rectangle</code></p><p><code>Rectangle</code> 有：</p><ul><li><code>setWidth</code></li><li><code>setHeight</code></li></ul><p><code>Square</code> 继承后无法保持矩形逻辑 → 损坏父类行为。</p><p>因此，这种继承是<strong>错误的继承</strong>。</p></blockquote><p>正确做法：</p><blockquote><p>建立更高层抽象，例如 <code>Quadrilateral</code>。</p></blockquote><p>本质：</p><ul><li>正确判断哪些类应该“继承”，哪些应该“关联”。</li><li>如果继承会破坏行为契约，则不应该继承。</li></ul><hr><h5 id="迪米特原则（LoD，最少知道原则）">迪米特原则（LoD，最少知道原则）</h5><blockquote><p>一个对象应该尽量少地了解其他对象，只与直接朋友通信。</p></blockquote><p>判断“朋友”：</p><ul><li><code>this</code></li><li>方法参数</li><li>成员变量</li><li>成员变量的元素（如列表内元素）</li><li>当前对象创建的对象</li></ul><p>其他都属于“陌生人”，不应该直接访问。</p><p>表现形式：</p><ul><li>不要“链式访问”：<code>a.getB().getC().doSomething()</code> → 违反 LoD</li><li>不要暴露太多 <code>public</code> 方法。</li></ul><p>示例：洗衣机</p><blockquote><p><code>Person</code> 调用 <code>WashingMachine</code> 的内部细节（<code>receiveClothes</code>、<code>wash</code>、<code>dry</code>） → 知道太多。</p></blockquote><p>调整为：</p><blockquote><p><code>WashingMachine</code> 提供 <code>automatic()</code>，内部自己组织流程。</p></blockquote><hr><h5 id="单一职责原则（SRP）">单一职责原则（SRP）</h5><blockquote><p>一个类应该只有一个引起它变化的原因。</p></blockquote><p>如果一个类承担多个职责：</p><ul><li>一个职责变化会影响另一个职责的用户</li><li>增加耦合性、降低可维护性</li></ul><p>例子：<code>Modem</code></p><blockquote><ul><li><p><code>dial</code>/<code>hangup</code> = 连接职责</p></li><li><p><code>send</code>/<code>receive</code> = 通讯职责</p></li><li><p>放一起 → 违反 SRP</p></li></ul><p>应该分成 <code>Connect</code> 接口 + <code>DataCommunicate</code> 接口。</p></blockquote><hr><h5 id="接口分隔原则（ISP）">接口分隔原则（ISP）</h5><blockquote><p>不要强迫用户依赖他们不需要的接口。</p><p>使用多个专用接口，而不是单一的胖接口。</p></blockquote><p>ISP 和 SRP 的区别：</p><ul><li><strong>SRP</strong>：关注“类/接口本身是否职责单一”</li><li><strong>ISP</strong>：从“调用者角度”，避免把不必要的方法塞给用户</li></ul><p>例子：</p><blockquote><p><code>Door</code> + <code>Alarm</code> 功能</p><ul><li>错误：<code>Door</code> 接口包含 <code>alarm()</code></li></ul><p>正确方案：</p><ul><li><code>Door</code> 接口：<code>lock</code>/<code>unlock</code></li><li><code>Alarm</code> 接口：<code>alarm</code></li><li><code>AlarmDoor</code> = <code>Door</code> + <code>Alarm</code></li></ul></blockquote><hr><h5 id="依赖倒置原则（DIP）">依赖倒置原则（DIP）</h5><blockquote><ul><li><p>高层模块不应依赖低层模块；二者都应依赖抽象</p></li><li><p>抽象不应该依赖细节；细节应该依赖抽象</p></li></ul></blockquote><p>本质：面向接口编程</p><p>例如：</p><blockquote><p><strong>反例</strong>（错误）</p><p>高层直接依赖 <code>FileLogger</code> / <code>DatabaseLogger</code> 等具体类</p><p><strong>正例</strong>（正确）</p><ul><li>定义 <code>Logger</code> 接口</li><li>高层依赖 <code>Logger</code></li><li>具体 <code>FileLogger</code>、<code>DbLogger</code> 实现 <code>Logger</code></li></ul><p>这样：</p><ul><li>新增 <code>RedisLogger</code> → 不改高层代码 → 符合 OCP</li><li>高层不依赖具体实现 → 松耦合</li></ul></blockquote><hr><h5 id="组合-聚合复用原则（CARP）">组合/聚合复用原则（CARP）</h5><blockquote><p>尽量使用“组合/聚合”来实现复用，而不是继承。</p></blockquote><p>继承的问题：</p><ul><li>父类变 → 子类全变（紧耦合）</li><li>强类型绑定，限制结构</li></ul><p>组合的优势：</p><ul><li>灵活替换（符合 OCP）</li><li>对象之间松耦合</li></ul><blockquote><p>例：<code>Player</code> 拥有 <code>Bike</code>（组合）<br>而不是 <code>class Player : private Bike</code> → <strong>继承不符合实际关系</strong>。</p></blockquote><h4 id="设计模式是对-OO-设计经验的提炼">设计模式是对 OO 设计经验的提炼</h4><ul><li>基于关系模型</li><li>遵循设计原则</li><li>解决反复出现的设计问题</li><li>是从大量复用实践中总结的通用解决方案</li></ul><div class="note note-info"><p>总结三者关系：</p><ul><li>关系模型 = 工具</li><li>设计原则 = 准则</li><li>设计模式 = 在工具与准则基础上总结出的经验</li></ul><pre><code class="mermaid">graph TD
    A[面向对象基础] --&gt; B[类间关系]
    A --&gt; C[设计原则]
    C --&gt; D[SOLID 原则]

    C --&gt; E[设计模式]
    B --&gt; E

    E --&gt; F[可复用/可扩展的软件结构]
</code></pre></div><h2 id="设计模式概述">设计模式概述</h2><h3 id="设计模式的诞生与发展">设计模式的诞生与发展</h3><p>设计模式并非起源于软件行业，而是起源于建筑学。</p><p>“模式之父” Christopher Alexander（加州大学环境结构中心 所长）在 1977 年出版了 <strong>《A Pattern Language》</strong>，总结了 <strong>253 个建筑与城市规划模式</strong>。</p><p>Alexander 给出的模式定义：</p><blockquote><p>“每个模式描述了一个在环境中不断出现的问题，并提供解决该问题的核心方案，可反复使用。”<strong>A pattern is a solution to a problem in a context.</strong></p></blockquote><p>即：<strong>模式 = 在特定环境中解决某类问题的通用方案</strong></p><p>1990 年代，软件工程界开始关注模式思想。</p><ul><li><strong>1991–1992 年</strong>：四人组（<strong>Gang of Four, GoF</strong>：Gamma、Helm、Johnson、Vlissides）把模式引入面向对象软件设计。</li><li><strong>1994 年</strong>：他们发表了著名的 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>，总结 <strong>23 个经典设计模式</strong>，奠定了软件设计模式的基础。</li></ul><p>此后，设计模式成为软件工程教育的标准内容，也广泛应用在 Java、.NET 等平台中。</p><h3 id="软件模式">软件模式</h3><p>软件模式是对软件开发中 <strong>重复出现的问题及其解决方案</strong> 的总结，包括：</p><ul><li>架构模式（如 MVC）</li><li>分析模式</li><li>设计模式（GoF）</li><li>过程模式（如敏捷模式）</li></ul><p>软件模式的结构一般包含四部分：</p><ol><li>问题描述</li><li>前提条件（环境或约束）</li><li>解决方案</li><li>效果（优缺点）</li></ol><h4 id="模式发现的“三次律”（Rule-of-Three）">模式发现的“三次律”（Rule of Three）</h4><p>一个方案必须至少在 <strong>三个不同系统</strong> 中成功使用，才有资格成为一个真正的模式。</p><h3 id="GoF-设计模式简介">GoF 设计模式简介</h3><p>GoF 在 1994 年总结了 <strong>23 种最经典的软件设计模式</strong>，用于解决软件设计中可复用性、扩展性、可维护性的问题。</p><p>设计模式帮助统一分析、设计、实现之间的沟通语言，使面向对象设计更加系统化与工程化。</p><h4 id="设计模式的基本要素">设计模式的基本要素</h4><p>每个设计模式一般包含如下关键结构：</p><ul><li><strong>模式名称</strong>（Pattern Name）：便于沟通的“专业词汇”</li><li><strong>问题</strong>（Problem）：该模式要解决的矛盾或场景</li><li><strong>解决方案</strong>（Solution）：类结构与交互方式</li><li><strong>效果</strong>（Consequences）：优点、缺点、对系统的影响</li></ul><blockquote><p>实际书中通常还包含示例代码、相关模式等内容。</p></blockquote><h4 id="设计模式的分类">设计模式的分类</h4><h5 id="按“目的”分类（WHAT-解决什么问题）">按“目的”分类（WHAT 解决什么问题）</h5><ol><li><strong>创建型（Creational）</strong><ul><li>用于对象的创建过程</li><li>如：工厂方法、单例、建造者、抽象工厂、原型</li></ul></li><li><strong>结构型（Structural）</strong><ul><li>如何组合类或对象形成更大的结构</li><li>如：适配器、代理、桥接、组合、装饰、享元、外观</li></ul></li><li><strong>行为型（Behavioral）</strong><ul><li>类或对象之间如何分配职责、如何通信</li><li>如：观察者、策略、命令、状态、迭代器、访问者等</li></ul></li></ol><h5 id="按“范围”分类（WHO-参与关系）">按“范围”分类（WHO 参与关系）</h5><ol><li><strong>类模式</strong><ul><li>处理类与子类之间的关系（通过继承，编译期确定）</li><li>静态结构</li></ul></li><li><strong>对象模式</strong><ul><li>处理对象之间的关系（运行期确定）</li><li>动态结构，更灵活，也更多出现</li></ul></li></ol><hr><table><thead><tr><th style="text-align:center">范围 \ 目的</th><th style="text-align:center">创建型模式</th><th style="text-align:center">结构型模式</th><th style="text-align:center">行为型模式</th></tr></thead><tbody><tr><td style="text-align:center"><strong>类模式</strong></td><td style="text-align:center">工厂方法</td><td style="text-align:center">类适配器</td><td style="text-align:center">解释器、模板方法</td></tr><tr><td style="text-align:center"><strong>对象模式</strong></td><td style="text-align:center">抽象工厂、建造者、原型、单例</td><td style="text-align:center">对象适配器、桥接、组合、装饰、外观、享元、代理</td><td style="text-align:center">职责链、命令、迭代器、中介者、备忘录、观察者、状态、策略、访问者</td></tr></tbody></table><h3 id="设计模式的优点">设计模式的优点</h3><ol><li><p><strong>提供通用语言</strong>（便于沟通），设计模式为开发者提供标准术语，使讨论系统结构更清晰。例如：</p><ul><li><p>“这里使用观察者模式通知 UI”</p></li><li><p>“把数据库访问层抽象成工厂模式”<br>这些话大家都能理解。</p></li></ul></li><li><p><strong>提高代码复用性、可维护性</strong>，设计模式总结了成熟的设计方案，避免：</p><ul><li><p>重新发明轮子</p></li><li><p>重复犯常见设计错误</p></li></ul></li><li><p><strong>让系统更加灵活且易扩展</strong>：许多模式（如策略、装饰）让系统结构更具可扩展性，符合开闭原则。</p></li><li><p><strong>提升软件质量与开发效率</strong>：设计模式经过验证，是构建高可靠软件的重要技术。</p></li><li><p><strong>帮助初学者理解面向对象思想</strong>：设计模式是学习 OO 思维的最佳教材：</p><ul><li><p>抽象</p></li><li><p>封装</p></li><li><p>多态</p></li><li><p>组合优于继承</p></li></ul></li></ol><h2 id="参考和注解">参考和注解</h2></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="print-no-link">#设计模式</a></div></div><div class="license-box my-3"><div class="license-title"><div>软件设计模式 课程笔记</div><div>https://blog.kisechan.space/2025/notes-design-pattern/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kisechan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年11月15日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2025年11月15日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/notes-machine-learning/" title="机器学习 课程笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">机器学习 课程笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/db-engine-2/" title="设计一个数据库引擎 (2) 索引"><span class="hidden-mobile">设计一个数据库引擎 (2) 索引</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",function(){var e=Object.assign({clientID:"Ov23liWYIiu2jxReIEhB",clientSecret:"d7b44817ae2553b2175fdecfde9718b582bdc653",repo:"Comment-Kisechan",owner:"Kisechan",admin:["Kisechan"],language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!0,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enabled:!0},{id:"b46cbace8fa64af2c1ae854a18cd6771"});new Gitalk(e).render("gitalk-container")})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded(function(){Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})})</script><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><div><span>Frame by <a href="https://hexo.io" target="_blank" rel="nofollow noopener">Hexo</a></span> <span>| Theme <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></span></div><div style="font-size:.85rem"><span><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></span><span><script async src="https://views.kisechan.space/views.js"></script><br><span id="my-site-view">本站总访问量：加载中...</span><br><br><span>&copy; 2024 - 2025 By <a href="https://github.com/Kisechan" target="_blank" rel="nofollow noopener"><strong>Kisechan</strong></a><br></span><span>今天也很喜欢你！</span><br><a href="https://icp.gov.moe/?keyword=20251453" target="_blank">萌ICP备20251453号</a></span></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/linkcard.js"></script><script src="/js/cursor.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script><script type="text/javascript">var originalTitle=document.title;window.onblur=function(){document.title="等你回来哦"},window.onfocus=function(){document.title=originalTitle}</script><div id="tooltip-rightmenu" class="tooltip-rightmenu">如果需要使用原始右键菜单请按下 <strong>Ctrl+右键</strong></div><div id="tooltip-clipboard" class="tooltip-rightmenu">链接复制成功！</div><div id="rightmenu-wrapper"><ul class="list-v rightmenu" id="rightmenu-content"><li class="navigation menuNavigation-Content"><a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa fa-arrow-left rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa fa-arrow-right rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa fa-refresh rightmenu-icon"></i></a> <a aria-label="TOP" href="#" role="button"><i class="fa fa-arrow-up rightmenu-icon"></i></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><span><i class="fa fa-search rightmenu-icon"></i> 站内搜索</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="toggleFullScreen()"><span><i class="fa fa-arrows-alt rightmenu-icon"></i> 切换全屏</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="copyPageUrl()"><span><i class="fa fa-clipboard rightmenu-icon"></i> 复制链接</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="scrollToComments()"><span><i class="fa fa-commenting rightmenu-icon"></i> 立即评论</span></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_blank" rel="noopener" href="https://www.kisechan.space/" data-group="link"><span><i class="fa fa-info-circle rightmenu-icon"></i> 关于本站</span></a></li></ul></div><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/css/custom_right_menu_icons.css" type="text/css" rel="stylesheet"><script src="/js/right_menu.js" type="text/javascript"></script><link href="/css/right_menu.css" type="text/css" rel="stylesheet"><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>