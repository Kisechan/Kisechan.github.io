<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><link rel=manifest href=/manifest.json><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://images.kisechan.space/apple-touch-icon.png"><link rel="icon" href="https://images.kisechan.space/icon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#004e66"><meta name="author" content="Kisechan"><meta name="keywords" content=""><meta name="description" content="面向对象和设计模式 设计模式概论 设计模式面向对象技术发展到一定阶段后的产物。  是被反复使用、众所周知并经过总结分类的面向对象设计经验。 对面向对象系统中的复杂问题提供通用解决方案。 设计模式对面向对象开发的意义约等于数据结构对面向过程开发的意义。 设计模式能帮助开发者实现：  可维护 可复用 可扩展 灵活性高   能更快地成长为优秀的软件开发工程师。  设计模式本质上是 对面向对象思想的深化"><meta property="og:type" content="article"><meta property="og:title" content="软件设计模式 课程笔记"><meta property="og:url" content="https://blog.kisechan.space/2025/notes-design-pattern/index.html"><meta property="og:site_name" content="Kisechan&#39;s Blog"><meta property="og:description" content="面向对象和设计模式 设计模式概论 设计模式面向对象技术发展到一定阶段后的产物。  是被反复使用、众所周知并经过总结分类的面向对象设计经验。 对面向对象系统中的复杂问题提供通用解决方案。 设计模式对面向对象开发的意义约等于数据结构对面向过程开发的意义。 设计模式能帮助开发者实现：  可维护 可复用 可扩展 灵活性高   能更快地成长为优秀的软件开发工程师。  设计模式本质上是 对面向对象思想的深化"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.kisechan.space/%E3%81%93%E3%81%A3%E3%81%9D%E3%82%8A%E3%83%81%E3%83%A7%E3%82%B3%E3%83%AC%E3%83%BC%E3%83%88_73129157.jpg"><meta property="article:published_time" content="2025-11-15T06:12:35.000Z"><meta property="article:modified_time" content="2025-12-10T12:23:55.503Z"><meta property="article:author" content="Kisechan"><meta property="article:tag" content="设计模式"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://images.kisechan.space/%E3%81%93%E3%81%A3%E3%81%9D%E3%82%8A%E3%83%81%E3%83%A7%E3%82%B3%E3%83%AC%E3%83%BC%E3%83%88_73129157.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><title>软件设计模式 课程笔记 - Kisechan&#39;s Blog</title><link rel="stylesheet" type="text/css" href="/css/loading.css"><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4890189_i2w7s0cduba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"blog.kisechan.space",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),n=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3837;break}}),i=new MutationObserver(e=>{for(let t of e)if("childList"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+6136;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Kisechan's Blog" type="application/atom+xml"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><style>:root{--link-card-bg:#F3F4F4;--link-card-title:#1a202c;--link-card-desc:#708090}html[data-user-color-scheme=dark]{--link-card-bg:#303744;--link-card-title:#C0C0C0;--link-card-desc:#a7a9ad}@media(prefers-color-scheme:dark){html:not([data-user-color-scheme=light]){--link-card-bg:#303744;--link-card-title:#C0C0C0;--link-card-desc:#a7a9ad}}</style></head><body><div><div class="real_mask" style="background-color:rgba(0,0,0,.3);width:100%;height:100%;position:fixed;z-index:-777"></div><div id="banner_video_insert"></div><div id="vvd_banner_img"></div></div><div id="banner"></div><div id="loader-box"><div class="loader-wrapper"><div class="loader"></div><div class="loader-text"><div>L</div><div>O</div><div>A</div><div>D</div><div>I</div><div>N</div><div>G</div><div></div><div></div><div></div></div></div><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loader-box").remove()};window.addEventListener("load",endLoading)</script></div><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>KISECHAN</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-Homehomepagemenu"></i> <span>博客</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-newstextarticle"></i> <span>文章</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-categories"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" target="_self"><i class="iconfont icon-5"></i> <span>笔记</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user"></i> <span>关于</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/about/" target="_self"><i class="iconfont icon-info-fill"></i> <span>关于</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/Kisechan.github.io" target="_self"><i class="iconfont icon-git"></i> <span>仓库</span> </a><a class="dropdown-item" href="/atom.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-Chemistry"></i> <span>项目</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/playlist/" target="_self"><i class="iconfont icon-music"></i> <span>歌单</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/botzone-crawer" target="_self"><i class="iconfont icon-bug-fill"></i> <span>Botzone 数据集批量下载</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/tetris2" target="_self"><i class="iconfont icon-tetris_app"></i> <span>Tetris2 游戏 AI</span> </a><a class="dropdown-item" href="https://github.com/Kisechan/db-engine" target="_self"><i class="iconfont icon-database"></i> <span>手搓关系型数据库引擎</span> </a><a class="dropdown-item" href="https://kashi.kisechan.space/" target="_self"><i class="iconfont icon-music1"></i> <span>歌词 Emoji 化工具</span> </a><a class="dropdown-item" href="/map/" target="_self"><i class="iconfont icon-map-filling"></i> <span>访问地图</span> </a><a class="dropdown-item" href="/homo/" target="_self"><i class="iconfont icon-animal"></i> <span>数字恶臭化工具</span></a></div></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link"></i> <span>友链</span></a></li><li class="nav-item"><a class="nav-link" href="https://github.com/Kisechan" target="_self"><i class="iconfont icon-github-fill"></i> <span>GitHub</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.travellings.cn/go.html" target="_self"><i class="iconfont icon-train"></i> <span>开往</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://images.kisechan.space/202502042159748.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">软件设计模式 课程笔记</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kisechan </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-11-15 14:12" pubdate>2025年11月15日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 25k 字 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div><script type="text/javascript" src="/vvd_js/jquery.js"></script><div class="banner" id="banner"><div class="full-bg-img"></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="课程笔记" id="heading-311a46cfdaa3afda544e9285644f70d7" role="tab" data-toggle="collapse" href="#collapse-311a46cfdaa3afda544e9285644f70d7" aria-expanded="true">课程笔记 <span class="list-group-count">(16)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-311a46cfdaa3afda544e9285644f70d7" role="tabpanel" aria-labelledby="heading-311a46cfdaa3afda544e9285644f70d7"><div class="category-post-list"><a href="/2024/oop/" title="面向对象程序设计课程笔记" class="list-group-item list-group-item-action"><span class="category-post">面向对象程序设计课程笔记</span> </a><a href="/2024/linux-note/" title="Linux课程笔记" class="list-group-item list-group-item-action"><span class="category-post">Linux课程笔记</span> </a><a href="/2024/ds/" title="数据结构课程板子合集 with 笔记" class="list-group-item list-group-item-action"><span class="category-post">数据结构课程板子合集 with 笔记</span> </a><a href="/2025/notes-algorithm-analysis/" title="算法设计与分析 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">算法设计与分析 课程笔记</span> </a><a href="/2025/notes-database-1/" title="数据库原理 课程笔记 (1) 数据库、关系代数和 SQL" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (1) 数据库、关系代数和 SQL</span> </a><a href="/2025/notes-database-2/" title="数据库原理 课程笔记 (2) E-R 模型和关系模式" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (2) E-R 模型和关系模式</span> </a><a href="/2025/notes-database-3/" title="数据库原理 课程笔记 (3) 存储、索引、事务和并发" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (3) 存储、索引、事务和并发</span> </a><a href="/2025/notes-database-4/" title="数据库原理 课程笔记 (4) 杂项和题目整理" class="list-group-item list-group-item-action"><span class="category-post">数据库原理 课程笔记 (4) 杂项和题目整理</span> </a><a href="/2025/notes-os/" title="操作系统复习" class="list-group-item list-group-item-action"><span class="category-post">操作系统复习</span> </a><a href="/2025/notes-ptms/" title="概率论与数理统计" class="list-group-item list-group-item-action"><span class="category-post">概率论与数理统计</span> </a><a href="/2025/notes-java/" title="Java 程序设计" class="list-group-item list-group-item-action"><span class="category-post">Java 程序设计</span> </a><a href="/2025/notes-networks/" title="计算机网络课程笔记" class="list-group-item list-group-item-action"><span class="category-post">计算机网络课程笔记</span> </a><a href="/2025/notes-design-pattern/" title="软件设计模式 课程笔记" class="list-group-item list-group-item-action active"><span class="category-post">软件设计模式 课程笔记</span> </a><a href="/2025/notes-machine-learning/" title="机器学习 课程笔记" class="list-group-item list-group-item-action"><span class="category-post">机器学习 课程笔记</span> </a><a href="/2025/notes-software-engineering-summary/" title="软件工程课程部分内容归纳" class="list-group-item list-group-item-action"><span class="category-post">软件工程课程部分内容归纳</span> </a><a href="/2025/notes-networks-summary/" title="计算机网络总结归纳" class="list-group-item list-group-item-action"><span class="category-post">计算机网络总结归纳</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">软件设计模式 课程笔记</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2025-12-10T20:23:55+08:00</p><div class="markdown-body"><p><img src="https://images.kisechan.space/20251115161935679.png" srcset="/img/loading.gif" lazyload alt="设计模式课程的主要内容"></p><h2 id="面向对象和设计模式">面向对象和设计模式</h2><h3 id="设计模式概论">设计模式概论</h3><p>设计模式面向对象技术发展到一定阶段后的产物。</p><ul><li>是<strong>被反复使用、众所周知并经过总结分类的面向对象设计经验</strong>。</li><li>对面向对象系统中的复杂问题提供通用解决方案。</li><li><strong>设计模式对面向对象开发的意义</strong>约等于<strong>数据结构对面向过程开发的意义</strong>。</li><li>设计模式能帮助开发者实现：<ul><li>可维护</li><li>可复用</li><li>可扩展</li><li>灵活性高</li></ul></li><li>能更快地成长为优秀的软件开发工程师。</li></ul><p>设计模式本质上是 <strong>对面向对象思想的深化与实践</strong>。学习设计模式能更深入理解 OO 概念与 OO 软件体系结构。</p><h3 id="面向对象（Object-Oriented）">面向对象（Object-Oriented）</h3><p>Coad 提出：<strong>面向对象 = 对象 + 类 + 继承 + 通信</strong>。</p><p>面向对象的特点是：</p><ul><li>既是一种 <strong>编程范式</strong>，也是一套 <strong>系统开发方法论</strong>。</li><li>是对现实世界的抽象：把相关的数据和方法组合为“对象”。</li><li>相对于面向过程，更符合自然事物建模方式。</li></ul><h4 id="OO-的目标">OO 的目标</h4><ul><li><strong>可维护</strong>：修改局部，不影响整体</li><li><strong>可复用</strong>：类和组件可多次使用</li><li><strong>可扩展</strong>：加新功能不破坏旧结构</li><li><strong>灵活性</strong>：结构可组合、可替换、可重组</li></ul><blockquote><p>比喻：活字印刷术中，可更换、重排的“字块”</p></blockquote><h4 id="面向对象编程语言">面向对象编程语言</h4><p>现代主流语言几乎全部支持或围绕 OOP 构建，如： Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP 等。</p><h4 id="面向对象开发方法">面向对象开发方法</h4><p>OO 方法贯穿开发方法的整个生命周期</p><ul><li>OOA：对象分析</li><li>OOD：对象设计</li><li>OOP：对象编程</li><li>OOT：对象测试</li><li>OOSM：对象维护</li></ul><p>面向对象不只是编程语言，更是一整套软件工程方法论。</p><h4 id="面向对象的发展与全貌">面向对象的发展与全貌</h4><h5 id="历史演进">历史演进</h5><ul><li><strong>Simula 67</strong>（1967，挪威）：首次引入类、继承、多态 → 第一门真正意义的 OOPL</li><li><strong>Smalltalk</strong>：确立 OO 思想</li><li>后续语言：C++、Objective-C、Java、C#、Ruby 等</li></ul><h5 id="形成的体系">形成的体系</h5><ul><li>OOPL：支持 OO 的语言</li><li>OOP：利用 OOPL 进行 OO 编程</li><li>类库 &amp; 框架：OOP 促进大规模可复用组件库出现</li><li>设计模式：在类库、框架设计过程中沉淀出的“可复用设计思想”</li></ul><h5 id="配套方法与工具">配套方法与工具</h5><ul><li><strong>UML（统一建模语言）</strong>：用图形表示 OO 软件结构</li><li>OO 建模方法、开发流程</li><li>OO 已成为覆盖整个开发流程的综合技术体系</li></ul><h5 id="目标">目标</h5><ul><li>利用前人经验（模式、框架、建模方法）</li><li>提高软件质量与开发效率</li><li>支持大规模复杂软件的管理与设计</li></ul><h3 id="面向对象设计">面向对象设计</h3><p>OO 设计是对“<strong>面向对象分析结果</strong>”的进一步整理，使其能够被直接用于面向对象编程。目标是<strong>把分析的对象、关系、职责，转化为可实现的类、方法、属性以及组件结构</strong>。</p><p>面向对象设计的三个层次：</p><ul><li>框架级设计</li><li>类设计</li><li>代码设计</li></ul><h4 id="框架级设计（Framework-Level）">框架级设计（Framework Level）</h4><p>框架是从一类特定软件中抽象出的<strong>可复用、协作的类群</strong>，定义了软件的体系结构。关注点：</p><ul><li>类如何分组 → 包（Package）</li><li>包之间如何协同</li><li>抽象层较高，强调复用与架构组织</li></ul><p>常见例子：三层逻辑架构（UI → 业务逻辑 → 数据库）</p><hr><h5 id="包（Package）与包结构原则">包（Package）与包结构原则</h5><p>包的六大原则分两类：</p><ul><li><p><strong>包的内聚性原则</strong>（决定类如何划分到包中）</p><ol><li><strong>重用发布等价原则 REP</strong><ul><li>复用的粒度 = 发布的粒度</li><li>复用的类应打包在一起，以便统一发布。</li></ul></li><li><strong>共同重用原则 CRP</strong><ul><li>经常一起变化的类应放在同一包中（高内聚）。</li><li>避免把不相关的类打包在一起。</li></ul></li><li><strong>共同封闭原则 CCP</strong><ul><li>对同一类变化原因负责的类，应放同一包中。</li><li>提升修改的局部性。</li></ul></li></ol></li><li><p><strong>包的耦合性原则</strong>（决定包与包之间如何连接）</p><ol start="4"><li><p><strong>无环依赖原则 ADP</strong></p><ul><li><p>包之间不能出现循环依赖。</p></li><li><p>保证架构清晰、可维护、可编译。</p></li></ul></li><li><p><strong>稳定依赖原则 SDP</strong></p><ul><li>不稳定的包应依赖稳定的包。</li><li>避免不稳定组件成为系统“根”。</li></ul></li><li><p><strong>稳定抽象原则 SAP</strong></p><ul><li><p>稳定的包应更抽象（用接口/抽象类）。</p></li><li><p>稳定 ≠ 僵化。</p></li></ul></li></ol></li></ul><h4 id="类设计（Class-Level）">类设计（Class Level）</h4><p>关注对象、类、属性、行为的抽象与组织方式。</p><ul><li>解决如何将现实世界对象转化为类结构，如何定义其行为和属性。</li><li>软件设计模式属于此层次（Factory、Singleton、Strategy 等）。</li></ul><hr><p><strong>类的定义</strong></p><ul><li>对象：问题域中的实体抽象</li><li>类：对象属性与行为的模板</li></ul><p>类设计要处理：</p><ul><li>类的组织与表示</li><li>行为（方法）的组织</li><li>属性的组织</li><li>类之间的关系（复用、耦合度）</li></ul><hr><ol><li><p><strong>类的组织与表示</strong>（从现实到抽象）</p><ul><li><p><strong>类的发现</strong>：从具体实例抽象，例如：苹果、香蕉 → 水果类</p></li><li><p><strong>聚类分析</strong>：找出对象集合的共同特征</p></li><li><p><strong>类的再抽象</strong>：进一步抽象成更通用概念，如“水果”或模板“List<t>”</t></p></li><li><p><strong>类的拆分</strong>：一个类中不属于核心领域的部分应拆出（如水果篮中的鲜花）</p></li><li><p><strong>类的可见性</strong>：区分公开、私有成员（对外接口 vs 内部实现）</p></li><li><p><strong>类的复用性（高内聚、低耦合）</strong></p></li></ul></li><li><p><strong>行为（方法）的组织与表示</strong></p><ul><li><p><strong>行为的参与者</strong>：行为涉及的对象（老鼠吃水果）</p></li><li><p><strong>行为分组与接口</strong>：例如吃香蕉 / 吃苹果 → 吃水果</p></li><li><p><strong>行为分解</strong>：抽象行为的内部步骤（剥皮 → 吃 → 吐核）</p></li><li><p><strong>行为的可见性</strong>：内部实现与外部接口区分</p></li><li><p><strong>行为的返回结果</strong>：吃水果返回成功/失败/数量</p></li><li><p><strong>行为的差异性</strong>：不同对象实现同一行为（多态）</p></li></ul></li><li><p><strong>属性的组织与表示</strong></p><ul><li><p>属性类型：内置、自定义</p></li><li><p>可访问性：只读、只写、读写</p></li><li><p>不变属性：不会随时间变化（身份证号）</p></li><li><p>类属性 vs 实例属性：如“扑克牌背面图案”是类属性</p></li><li><p>属性可见性：常隐藏，靠 getter/setter 暴露</p></li><li><p>属性设计依赖具体编程语言特性</p></li></ul></li></ol><hr><p><strong>变化</strong></p><p>这是类设计的核心难点。</p><ol><li><p><strong>职责的变化</strong>（接口变化）</p><ul><li><p>行为签名改变</p></li><li><p>新增功能</p></li><li><p>可访问性改变</p></li></ul></li><li><p><strong>实现的变化</strong>（内部变化）</p><ul><li><p>数据类型变化</p></li><li><p>数据结构变化</p></li><li><p>行为算法变化</p></li></ul></li></ol><p>示例分析：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//0. 新增函数 f1    （职责变化）</span><br>     <span class="hljs-comment">//1. f 参数表可能变化（职责变化）</span><br>     <span class="hljs-comment">//2. f 的具体实现变化（实现变化）</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">//3. 数据类型变化（实现变化）</span><br>     <span class="hljs-comment">//4. 数据结构变化（实现变化）</span><br>     <span class="hljs-type">int</span> nums[<span class="hljs-number">50</span>];<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>应对变化的两种方式</strong></p><ol><li><p><strong>修改既有代码</strong></p><ul><li><p>缺点：</p><ul><li><p>可能无法访问源码</p></li><li><p>修改已发布代码风险高</p></li><li><p>修改接口可能影响大量调用者</p></li></ul></li></ul></li><li><p><strong>扩展既有代码</strong>（OO 推荐方式）</p><ul><li><p>使用类关系扩展系统：</p><ul><li><p><strong>继承扩展</strong>（最常见但谨慎使用）</p></li><li><p><strong>依赖扩展</strong></p></li><li><p><strong>关联扩展</strong></p></li><li><p><strong>聚合扩展</strong></p></li><li><p><strong>组合扩展</strong></p></li></ul></li><li><p>目标：遵守开闭原则（对扩展开放，对修改关闭）。</p></li></ul></li></ol><h4 id="代码设计（Code-Level）">代码设计（Code Level）</h4><p>类的具体实现（物理级）：源代码、二进制代码、可执行代码。关注：</p><ul><li>性能</li><li>可部署性</li><li>可移植性</li><li>代码结构与文件组织方式</li></ul><h3 id="关系模型与设计模式的关联">关系模型与设计模式的关联</h3><h4 id="关系模型（类间关系）是复用的基础">关系模型（类间关系）是复用的基础</h4><p><img src="https://images.kisechan.space/20251122202516535.png" srcset="/img/loading.gif" lazyload alt="类间关系与 UML 绘制"></p><p>类之间的关系是 OO 中复用的工具。</p><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">强度</th><th style="text-align:center">UML 表示</th><th style="text-align:center">关键语义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>依赖</strong>（Dependency）</td><td style="text-align:center">⭐</td><td style="text-align:center"><strong>虚线箭头</strong></td><td style="text-align:center">临时使用，弱关系</td></tr><tr><td style="text-align:center"><strong>关联</strong>（Association）</td><td style="text-align:center">⭐⭐</td><td style="text-align:center"><strong>实线箭头</strong></td><td style="text-align:center">长期使用，语义级关系</td></tr><tr><td style="text-align:center"><strong>聚合</strong>（Aggregation）</td><td style="text-align:center">⭐⭐⭐</td><td style="text-align:center"><strong>空心菱形 + 实线</strong></td><td style="text-align:center">整体-部分，可分离</td></tr><tr><td style="text-align:center"><strong>组合</strong>（Composition）</td><td style="text-align:center">⭐⭐⭐⭐</td><td style="text-align:center"><strong>实心菱形 + 实线</strong></td><td style="text-align:center">整体-部分，不可分离</td></tr><tr><td style="text-align:center"><strong>泛化</strong>（Generalization）</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center"><strong>空心三角实线</strong></td><td style="text-align:center">继承，有实现复用</td></tr><tr><td style="text-align:center"><strong>实现</strong>（Realization）</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center"><strong>空心三角虚线</strong></td><td style="text-align:center">实现接口，无实现继承</td></tr></tbody></table><h5 id="依赖（Dependency）">依赖（Dependency）</h5><ul><li>A <strong>使用到</strong> B，但这种关系 <strong>偶然、弱、短暂</strong></li><li>B 的变化会影响到 A，但二者并不是长期绑定</li></ul><p>典型代码表现有：</p><ul><li>方法参数</li><li>方法内部局部变量</li><li>调用对方静态方法</li><li>临时 <code>new</code>/<code>delete</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B* b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B&amp; b)</span></span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>UML 表示用虚线箭头，A → B 表示 “A 依赖 B”。</p><p>示例：</p><ul><li>老鼠吃苹果</li><li>人借车移动</li><li>警察抓小偷（也可设计为更复杂的双向依赖）</li><li>Screen（画布）依赖 Shape 的绘制接口</li><li>Mouse 依赖 Fruit（通过子类型适配多种水果变化）</li></ul><hr><p>关键思想：</p><p>依赖关系用于<strong>适应短期变化</strong>。</p><p>常见的使用方法：</p><ul><li>参数多态（<code>Fruit&amp;</code>）</li><li>子类型化适应扩展（<code>Cat</code>/<code>Dog</code> 类型化 <code>Monster</code>）</li></ul><h5 id="关联（Association）">关联（Association）</h5><ul><li>A 和 B <strong>长期存在语义关联</strong></li><li>强于依赖</li><li>双方地位平等（通常）</li></ul><p>UML 用实线箭头 A → B（单向）或实线无箭头（双向）表示</p><p>代码特征通常表现为 <strong>成员变量</strong>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CWife</span> {<br>    CHusband* husband;  <span class="hljs-comment">// 关联</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>关联分三大类：</p><ol><li><strong>单向关联</strong>：只有一方持有对方</li><li><strong>双向关联</strong>：双方互相持有</li><li><strong>自身关联</strong>：类内部引用自己（如链表 Node）</li></ol><p>示例：</p><ul><li>英雄（Hero）持有宝物（Goods）</li><li>学生（Student）拥有宿舍（Dorm）</li><li>丈夫 ↔ 妻子（双向）</li><li>链表 Node 自身关联 nextNode</li></ul><p>本质上，关联描述一种 <strong>更稳定的“使用关系”</strong>。 生命周期独立，但逻辑联系长期存在。</p><hr><h5 id="聚合（Aggregation）">聚合（Aggregation）</h5><ul><li>“整体–部分（has-a）”关系</li><li>部分 <strong>可以独立于整体存在</strong></li><li>关系 <strong>弱于组合</strong></li></ul><p>例如：</p><ul><li>自行车 — 轮胎；</li><li>学生 — 宿舍；</li><li>科研团队 — 科研人员。</li></ul><p>UML 用空心菱形 + 实线表示。</p><pre><code class="mermaid">classDiagram
    class A
    class B
    A o-- B
</code></pre><p>代码例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dorm</span> {<br>    Student** mStudents;  <span class="hljs-comment">// 但学生可独立存在</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>特性：</p><ul><li>整体与部分可分离</li><li>生命周期不绑定</li><li>常用于“容器拥有元素”</li></ul><p>示例扩展：</p><ul><li>果篮–水果</li><li>防盗门–锁</li><li>Grid 包含多个 Rect（绘图示例）</li></ul><h5 id="组合（Composition）">组合（Composition）</h5><p>强聚合（比聚合强），部分的生命周期 <strong>完全依赖整体</strong></p><p>例如：</p><ul><li>人和大脑</li><li>窗口和标题栏</li><li>公司和部门（生命周期绑定）</li></ul><p>UML 用实心菱形 + 实线表示</p><pre><code class="mermaid">classDiagram
    class Whole
    class Part
    Whole *-- Part
</code></pre><p>代码特征：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    B b;          <span class="hljs-comment">// 组合：整体负责部分的生命周期</span><br>};<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    B* b;<br>    <span class="hljs-built_in">A</span>() { b = <span class="hljs-keyword">new</span> B; }<br>    ~<span class="hljs-built_in">A</span>() { <span class="hljs-keyword">delete</span> b; }<br>};<br></code></pre></td></tr></tbody></table></figure><p>特征：</p><ul><li>部分不能脱离整体生存</li><li>整体被析构 → 部分也被析构</li><li>表现更强的所有权</li></ul><h5 id="泛化（Generalization）">泛化（Generalization）</h5><ul><li>“一般–特殊”关系</li><li><strong>继承</strong></li><li>子类继承父类的<strong>属性和实现</strong></li></ul><p>UML 用空心三角形 + 实线表示子类 → 父类</p><pre><code class="mermaid">classDiagram
    Animal &lt;|-- Tiger
</code></pre><p>示例：</p><ul><li>Monster ← Cat</li><li>Monster ← Dog</li><li>Animal ← Tiger</li></ul><hr><h5 id="实现（Realization）">实现（Realization）</h5><p>类实现接口，类似 Java 的 <code>implements</code>。</p><p>和泛化的区别：</p><ul><li><strong>泛化</strong>：继承父类的实现（代码）</li><li><strong>实现</strong>：仅继承接口，无实现</li></ul><p>UML 用空心三角形 + 虚线表示：</p><pre><code class="mermaid">classDiagram
    IAnimal &lt;|.. Animal
</code></pre><h4 id="设计原则是行为准则">设计原则是行为准则</h4><p>面向对象从提出到成熟经历了大量实践，逐渐沉淀出 <strong>七大设计原则</strong>。<br>它们可分为两类：</p><ul><li><p><strong>设计目标</strong>（设计的“方向”），重点：让系统<strong>稳定</strong>、<strong>可扩展</strong>、<strong>可维护</strong></p><ol><li><strong>开闭原则</strong> OCP</li><li><strong>里氏替换原则</strong> LSP</li><li><strong>迪米特原则</strong> LoD（最少知道原则）</li></ol></li><li><p><strong>设计方法</strong>（如何“做到”），重点：实现<strong>高内聚</strong>、<strong>低耦合</strong></p><ol><li><strong>单一职责原则</strong> SRP</li><li><strong>接口分隔原则</strong> ISP</li><li><strong>依赖倒置原则</strong> DIP</li><li><strong>组合/聚合复用原则</strong> CARP</li></ol></li></ul><p>这七个原则不是孤立的，互相强化。</p><p><strong>OCP 是核心，其他六条都是帮助我们实现 OCP 的工具。</strong></p><table><thead><tr><th style="text-align:center">原则</th><th style="text-align:center">中文名</th><th style="text-align:center">作用</th><th style="text-align:center">与 OCP 的关系</th></tr></thead><tbody><tr><td style="text-align:center">OCP</td><td style="text-align:center">开闭原则</td><td style="text-align:center">最终目标：可扩展、可维护</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LSP</td><td style="text-align:center">里氏替换原则</td><td style="text-align:center">正确继承，确保扩展不会破坏原有功能</td><td style="text-align:center">OCP 的根基</td></tr><tr><td style="text-align:center">LoD</td><td style="text-align:center">迪米特原则</td><td style="text-align:center">减少耦合，间接提高可扩展性</td><td style="text-align:center">提供低耦合环境</td></tr><tr><td style="text-align:center">SRP</td><td style="text-align:center">单一职责原则</td><td style="text-align:center">单一职责，使扩展简单</td><td style="text-align:center">便于扩展、减少修改</td></tr><tr><td style="text-align:center">ISP</td><td style="text-align:center">接口分隔原则</td><td style="text-align:center">专门接口，提高灵活性</td><td style="text-align:center">避免修改胖接口</td></tr><tr><td style="text-align:center">DIP</td><td style="text-align:center">依赖倒置原则</td><td style="text-align:center">高层不依赖低层，实现可替换</td><td style="text-align:center">通过抽象实现 OCP</td></tr><tr><td style="text-align:center">CARP</td><td style="text-align:center">组合/聚合复用原则</td><td style="text-align:center">用组合支持扩展、减少继承修改</td><td style="text-align:center">扩展开放、修改关闭</td></tr></tbody></table><div class="note note-info"><p>面向对象七大原则的核心是“<strong>开闭原则</strong>”，它强调对扩展开放、对修改关闭。</p><ul><li><strong>里氏替换原则</strong>保证继承结构的正确性；</li><li><strong>迪米特原则</strong>降低耦合；</li><li><strong>单一职责原则</strong>和<strong>接口隔离原则</strong>控制了类与接口的粒度；</li><li><strong>依赖倒置原则</strong>通过抽象降低层间依赖；</li><li><strong>组合/聚合复用原则</strong>提供了一种比继承更稳定的复用机制。</li></ul><p>它们共同协作以提高软件的可扩展性、可维护性和稳定性。</p></div><table><thead><tr><th style="text-align:center">原则</th><th style="text-align:center">最常见错误</th></tr></thead><tbody><tr><td style="text-align:center">OCP</td><td style="text-align:center">大量 if-else 判断类型</td></tr><tr><td style="text-align:center">LSP</td><td style="text-align:center">子类破坏父类行为约定，父类可以做但是子类做不了</td></tr><tr><td style="text-align:center">LoD</td><td style="text-align:center">一长串对象调用链</td></tr><tr><td style="text-align:center">SRP</td><td style="text-align:center">万人嫌“上帝类”，职责太多</td></tr><tr><td style="text-align:center">ISP</td><td style="text-align:center">巨型接口，方法太多，子类没必要去每个都实现</td></tr><tr><td style="text-align:center">DIP</td><td style="text-align:center">依赖具体实现而不是抽象基类</td></tr><tr><td style="text-align:center">CARP</td><td style="text-align:center">滥用继承，只为复用代码</td></tr></tbody></table><h5 id="开闭原则（Open-Closed-Principle-OCP）">开闭原则（Open-Closed Principle, OCP）</h5><blockquote><p>软件实体应该<em>对扩展开放</em>，<em>对修改关闭</em>。</p></blockquote><p>即：添加功能<strong>不改旧代码，通过扩展类/接口实现新行为</strong>。</p><p>意义：</p><ul><li><strong>稳定性</strong>：减少修改旧模块引入 bug。</li><li><strong>扩展性</strong>：通过新类扩展系统能力。</li></ul><p>如何实现？</p><ul><li>找出系统中“变化点”，抽象为接口。</li><li>使用“面向接口编程”而不是面向实现。</li><li>新行为 = 新类 + 实现既有接口，而不是改旧类。</li></ul><p>典型反例：</p><blockquote><p>绘图程序中有 <code>Circle</code>、<code>Square</code>，错误设计用 <code>switch-case</code> 判断类型 → 违反 OCP。</p></blockquote><p>正确方法：</p><blockquote><p>给 <code>Shape</code> 定义抽象方法 <code>draw()</code>，每个图形类实现自己的 draw。</p></blockquote><hr><h5 id="里氏替换原则（LSP）">里氏替换原则（LSP）</h5><blockquote><p>任何父类出现的地方，子类必须能够透明替换，并保持程序正确性。</p></blockquote><p>一句话：<strong>子类必须完全遵守父类的行为契约</strong>。</p><p>违反的表现：</p><ul><li>用 <code>typeid</code>、<code>instanceof</code> 判断类型 → 明显违反 LSP。</li><li>子类重写方法后导致父类行为被破坏。</li></ul><p>经典反例：</p><blockquote><p><code>Square</code> 继承 <code>Rectangle</code></p><p><code>Rectangle</code> 有：</p><ul><li><code>setWidth</code></li><li><code>setHeight</code></li></ul><p><code>Square</code> 继承后无法保持矩形逻辑 → 损坏父类行为。</p><p>因此，这种继承是<strong>错误的继承</strong>。</p></blockquote><p>正确做法：</p><blockquote><p>建立更高层抽象，例如 <code>Quadrilateral</code>。</p></blockquote><p>本质：</p><ul><li>正确判断哪些类应该“继承”，哪些应该“关联”。</li><li>如果继承会破坏行为契约，则不应该继承。</li></ul><hr><h5 id="迪米特原则（LoD，最少知道原则）">迪米特原则（LoD，最少知道原则）</h5><blockquote><p>一个对象应该尽量少地了解其他对象，只与直接朋友通信。</p></blockquote><p>判断“朋友”：</p><ul><li><code>this</code></li><li>方法参数</li><li>成员变量</li><li>成员变量的元素（如列表内元素）</li><li>当前对象创建的对象</li></ul><p>其他都属于“陌生人”，不应该直接访问。</p><p>表现形式：</p><ul><li>不要“链式访问”：<code>a.getB().getC().doSomething()</code> → 违反 LoD</li><li>不要暴露太多 <code>public</code> 方法。</li></ul><p>示例：洗衣机</p><blockquote><p><code>Person</code> 调用 <code>WashingMachine</code> 的内部细节（<code>receiveClothes</code>、<code>wash</code>、<code>dry</code>） → 知道太多。</p></blockquote><p>调整为：</p><blockquote><p><code>WashingMachine</code> 提供 <code>automatic()</code>，内部自己组织流程。</p></blockquote><hr><h5 id="单一职责原则（SRP）">单一职责原则（SRP）</h5><blockquote><p>一个类应该只有一个引起它变化的原因。</p></blockquote><p>如果一个类承担多个职责：</p><ul><li>一个职责变化会影响另一个职责的用户</li><li>增加耦合性、降低可维护性</li></ul><p>例子：<code>Modem</code></p><blockquote><ul><li><p><code>dial</code>/<code>hangup</code> = 连接职责</p></li><li><p><code>send</code>/<code>receive</code> = 通讯职责</p></li><li><p>放一起 → 违反 SRP</p></li></ul><p>应该分成 <code>Connect</code> 接口 + <code>DataCommunicate</code> 接口。</p></blockquote><hr><h5 id="接口分隔原则（ISP）">接口分隔原则（ISP）</h5><blockquote><p>不要强迫用户依赖他们不需要的接口。</p><p>使用多个专用接口，而不是单一的胖接口。</p></blockquote><p>ISP 和 SRP 的区别：</p><ul><li><strong>SRP</strong>：关注“类/接口本身是否职责单一”</li><li><strong>ISP</strong>：从“调用者角度”，避免把不必要的方法塞给用户</li></ul><p>例子：</p><blockquote><p><code>Door</code> + <code>Alarm</code> 功能</p><ul><li>错误：<code>Door</code> 接口包含 <code>alarm()</code></li></ul><p>正确方案：</p><ul><li><code>Door</code> 接口：<code>lock</code>/<code>unlock</code></li><li><code>Alarm</code> 接口：<code>alarm</code></li><li><code>AlarmDoor</code> = <code>Door</code> + <code>Alarm</code></li></ul></blockquote><hr><h5 id="依赖倒置原则（DIP）">依赖倒置原则（DIP）</h5><blockquote><ul><li><p>高层模块不应依赖低层模块；二者都应依赖抽象</p></li><li><p>抽象不应该依赖细节；细节应该依赖抽象</p></li></ul></blockquote><p>本质：面向接口编程</p><p>例如：</p><blockquote><p><strong>反例</strong>（错误）</p><p>高层直接依赖 <code>FileLogger</code> / <code>DatabaseLogger</code> 等具体类</p><p><strong>正例</strong>（正确）</p><ul><li>定义 <code>Logger</code> 接口</li><li>高层依赖 <code>Logger</code></li><li>具体 <code>FileLogger</code>、<code>DbLogger</code> 实现 <code>Logger</code></li></ul><p>这样：</p><ul><li>新增 <code>RedisLogger</code> → 不改高层代码 → 符合 OCP</li><li>高层不依赖具体实现 → 松耦合</li></ul></blockquote><hr><h5 id="组合-聚合复用原则（CARP）">组合/聚合复用原则（CARP）</h5><blockquote><p>尽量使用“组合/聚合”来实现复用，而不是继承。</p></blockquote><p>继承的问题：</p><ul><li>父类变 → 子类全变（紧耦合）</li><li>强类型绑定，限制结构</li></ul><p>组合的优势：</p><ul><li>灵活替换（符合 OCP）</li><li>对象之间松耦合</li></ul><blockquote><p>例：<code>Player</code> 拥有 <code>Bike</code>（组合）<br>而不是 <code>class Player : private Bike</code> → <strong>继承不符合实际关系</strong>。</p></blockquote><div class="note note-info"><p>另外，<strong>继承属于典型的白箱复用</strong>，通过修改或扩展其内部实现来实现复用。而<strong>黑箱复用</strong>利用<strong>组合/委托</strong>来实现复用，只依赖行为接口，不关心内部实现，耦合性更弱，更安全。</p></div><h4 id="设计模式是对-OO-设计经验的提炼">设计模式是对 OO 设计经验的提炼</h4><ul><li>基于关系模型</li><li>遵循设计原则</li><li>解决反复出现的设计问题</li><li>是从大量复用实践中总结的通用解决方案</li></ul><div class="note note-info"><p>总结三者关系：</p><ul><li>关系模型 = 工具</li><li>设计原则 = 准则</li><li>设计模式 = 在工具与准则基础上总结出的经验</li></ul><pre><code class="mermaid">graph TD
    A[面向对象基础] --&gt; B[类间关系]
    A --&gt; C[设计原则]
    C --&gt; D[SOLID 原则]

    C --&gt; E[设计模式]
    B --&gt; E

    E --&gt; F[可复用/可扩展的软件结构]
</code></pre></div><h2 id="设计模式">设计模式</h2><p>设计模式并非起源于软件行业，而是起源于建筑学。</p><p>“模式之父” Christopher Alexander（加州大学环境结构中心 所长）在 1977 年出版了 <em>A Pattern Language</em>，总结了 <strong>253 个建筑与城市规划模式</strong>。Alexander 给出的模式定义：</p><blockquote><p>“每个模式描述了一个在环境中不断出现的问题，并提供解决该问题的核心方案，可反复使用。”</p><p><strong>A pattern is a solution to a problem in a context.</strong></p></blockquote><p>即：<strong>模式 = 在特定环境中解决某类问题的通用方案</strong></p><hr><p>1990 年代，软件工程界开始关注模式思想。</p><ul><li><strong>1991–1992 年</strong>：四人组（<strong>Gang of Four, GoF</strong>：Gamma、Helm、Johnson、Vlissides）把模式引入面向对象软件设计。</li><li><strong>1994 年</strong>：他们发表了著名的 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>，总结 <strong>23 个经典设计模式</strong>，奠定了软件设计模式的基础。</li></ul><p>此后，设计模式成为软件工程教育的标准内容，也广泛应用在 Java、.NET 等平台中。</p><h3 id="软件模式">软件模式</h3><p>软件模式是对软件开发中 <strong>重复出现的问题及其解决方案</strong> 的总结，包括：</p><ul><li>架构模式（如 MVC）</li><li>分析模式</li><li>设计模式（GoF）</li><li>过程模式（如敏捷模式）</li></ul><p>软件模式的结构一般包含四部分：</p><ol><li>问题描述</li><li>前提条件（环境或约束）</li><li>解决方案</li><li>效果（优缺点）</li></ol><h4 id="模式发现的“三次律”（Rule-of-Three）">模式发现的“三次律”（Rule of Three）</h4><p>一个方案必须至少在 <strong>三个不同系统</strong> 中成功使用，才有资格成为一个真正的模式。</p><h3 id="GoF-设计模式">GoF 设计模式</h3><p>GoF 在 1994 年总结了 <strong>23 种最经典的软件设计模式</strong>，用于解决软件设计中可复用性、扩展性、可维护性的问题。</p><p>设计模式帮助统一分析、设计、实现之间的沟通语言，使面向对象设计更加系统化与工程化。</p><h4 id="设计模式的基本要素">设计模式的基本要素</h4><p>每个设计模式一般包含如下关键结构：</p><ul><li><strong>模式名称</strong>（Pattern Name）：便于沟通的“专业词汇”</li><li><strong>问题</strong>（Problem）：该模式要解决的矛盾或场景</li><li><strong>解决方案</strong>（Solution）：类结构与交互方式</li><li><strong>效果</strong>（Consequences）：优点、缺点、对系统的影响</li></ul><blockquote><p>实际书中通常还包含示例代码、相关模式等内容。</p></blockquote><h4 id="设计模式的分类">设计模式的分类</h4><h5 id="按“目的”分类（WHAT-解决什么问题）">按“目的”分类（WHAT 解决什么问题）</h5><ol><li><strong>创建型（Creational）</strong><ul><li>用于对象的创建过程</li><li>如：工厂方法、单例、建造者、抽象工厂、原型</li></ul></li><li><strong>结构型（Structural）</strong><ul><li>如何组合类或对象形成更大的结构</li><li>如：适配器、代理、桥接、组合、装饰、享元、外观</li></ul></li><li><strong>行为型（Behavioral）</strong><ul><li>类或对象之间如何分配职责、如何通信</li><li>如：观察者、策略、命令、状态、迭代器、访问者等</li></ul></li></ol><h5 id="按“范围”分类（WHO-参与关系）">按“范围”分类（WHO 参与关系）</h5><ol start="4"><li><p><strong>类模式</strong></p><ul><li><p>处理类与子类之间的关系（通过继承，编译期确定）</p></li><li><p>静态结构</p></li></ul></li><li><p><strong>对象模式</strong></p><ul><li><p>处理对象之间的关系（运行期确定）</p></li><li><p>动态结构，更灵活，也更多出现</p></li></ul></li></ol><hr><table><thead><tr><th style="text-align:center">范围 \ 目的</th><th style="text-align:center">创建型模式</th><th style="text-align:center">结构型模式</th><th style="text-align:center">行为型模式</th></tr></thead><tbody><tr><td style="text-align:center"><strong>类模式</strong></td><td style="text-align:center">工厂方法</td><td style="text-align:center">类适配器</td><td style="text-align:center">解释器、模板方法</td></tr><tr><td style="text-align:center"><strong>对象模式</strong></td><td style="text-align:center">抽象工厂、建造者、原型、单例</td><td style="text-align:center">对象适配器、桥接、组合、装饰、外观、享元、代理</td><td style="text-align:center">职责链、命令、迭代器、中介者、备忘录、观察者、状态、策略、访问者</td></tr></tbody></table><h3 id="设计模式的优点">设计模式的优点</h3><ol><li><p><strong>提供通用语言</strong>（便于沟通），设计模式为开发者提供标准术语，使讨论系统结构更清晰。例如：</p><ul><li><p>“这里使用观察者模式通知 UI”</p></li><li><p>“把数据库访问层抽象成工厂模式”<br>这些话大家都能理解。</p></li></ul></li><li><p><strong>提高代码复用性、可维护性</strong>，设计模式总结了成熟的设计方案，避免：</p><ul><li><p>重新发明轮子</p></li><li><p>重复犯常见设计错误</p></li></ul></li><li><p><strong>让系统更加灵活且易扩展</strong>：许多模式（如策略、装饰）让系统结构更具可扩展性，符合开闭原则。</p></li><li><p><strong>提升软件质量与开发效率</strong>：设计模式经过验证，是构建高可靠软件的重要技术。</p></li><li><p><strong>帮助初学者理解面向对象思想</strong>：设计模式是学习 OO 思维的最佳教材：</p><ul><li><p>抽象</p></li><li><p>封装</p></li><li><p>多态</p></li><li><p>组合优于继承</p></li></ul></li></ol><h2 id="创建型设计模式">创建型设计模式</h2><p>创建型模式（Creational Patterns）的核心思想：</p><blockquote><p><strong>把“创建对象”这件事独立出来，让使用对象的代码不再关心创建过程。</strong></p></blockquote><p>换句话说：平时我们总是在写 <code>new XXX()</code>，但一旦类多、构建复杂、依赖变化，<code>new</code> 会成为巨大的负担，创建型模式就是帮助你：<strong>不要乱用 <code>new</code></strong>。</p><p>它的两个关键特征：</p><ol><li><strong>客户不知道对象的具体类是什么</strong>（解耦，隐藏细节）</li><li><strong>隐藏对象实例的创建与组织过程</strong>（你只“要”，不“造”）</li></ol><p>只要想写出：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">SomeObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeObject</span>();  <span class="hljs-comment">// ← 看到 new 就要想：能不能用工厂？</span><br></code></pre></td></tr></tbody></table></figure><p>就可以考虑创建型模式。</p><p>创建型模式包括：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>建造者模式</li><li>原型模式</li><li>单例模式</li></ul><h3 id="简单工厂模式">简单工厂模式</h3><p>比如 UI 中有三种按钮：</p><ul><li>圆形按钮</li><li>矩形按钮</li><li>菱形按钮</li></ul><p>不想写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundButton</span>();<br></code></pre></td></tr></tbody></table></figure><p>而希望：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ButtonFactory.getButton(<span class="hljs-string">"round"</span>);<br></code></pre></td></tr></tbody></table></figure><p>你只需要知道一个“<strong>类型参数</strong>”，不需要知道类名，不需要知道构造过程。</p><hr><p>简单工厂 又叫 <strong>静态工厂方法</strong> Static Factory Method，即：</p><blockquote><p>定义一个专门的工厂类，根据传入参数，返回某个父类（抽象产品）下的具体子类（具体产品）。</p></blockquote><p>因此角色有：</p><ul><li><strong>Factory 工厂角色</strong>：负责创建对象（通常是 static 方法）</li><li><strong>Product 抽象产品角色</strong>：父类/接口</li><li><strong>ConcreteProduct 具体产品角色</strong>：各种实际产品的实现类</li></ul><pre><code class="mermaid">classDiagram
    class Product {
        &lt;&lt;interface&gt;&gt;
        +operation()
    }

    class ConcreteProductA {
        +operation()
    }

    class ConcreteProductB {
        +operation()
    }

    class Factory {
        +createProduct(type): Product
    }

    Product &lt;|.. ConcreteProductA
    Product &lt;|.. ConcreteProductB
    Factory --&gt; Product
</code></pre><hr><p>示例：未使用工厂，代码臃肿难维护：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String type)</span> {<br>    <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">"cash"</span>)) {<br>        ...<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">"creditcard"</span>)) {<br>        ...<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">"voucher"</span>)) {<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>所有支付逻辑写在一起，增加新的支付方式 → 必须改这个函数。<strong>违反开闭原则</strong> OCP。</p><hr><p><strong>使用简单工厂</strong>：</p><ol><li><strong>抽象产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>具体产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> { <span class="hljs-comment">/* 现金支付 */</span> }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>工厂类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayMethodFactory</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractPay <span class="hljs-title function_">getPayMethod</span><span class="hljs-params">(String type)</span> {<br>        <span class="hljs-keyword">if</span>(type.equalsIgnoreCase(<span class="hljs-string">"cash"</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashPay</span>();<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equalsIgnoreCase(<span class="hljs-string">"creditcard"</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreditcardPay</span>();<br>        }<br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AbstractPay</span> <span class="hljs-variable">pay</span> <span class="hljs-operator">=</span> PayMethodFactory.getPayMethod(<span class="hljs-string">"cash"</span>);<br>pay.pay();<br></code></pre></td></tr></tbody></table></figure><p><strong>对象的创建完全被封装</strong>，业务逻辑更清晰。</p><hr><p><strong>优点</strong>：</p><ol><li><strong>工厂类集中管理对象创建</strong>，客户端不需要知道具体类名。</li><li><strong>客户端与具体类解耦</strong>，只需传入一个参数。</li><li>可以将参数放到 <strong>配置文件 / 数据库</strong> 中，实现“无需修改代码即可替换产品”。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>工厂类承担所有对象创建职责，过于臃肿</strong>，一个工厂要知道所有产品，非常不灵活。</li><li><strong>不符合开闭原则</strong>，添加新产品就必须修改工厂类的判断逻辑。</li><li><strong>工厂方法是静态的</strong>，无法通过继承扩展工厂（这是和工厂方法模式的区别）。</li></ol><p>如果产品越来越多，应该升级到 <strong>工厂方法模式</strong> 或 <strong>抽象工厂模式</strong>。</p><hr><p><strong>模式适用场景</strong></p><p>适用于：</p><ul><li>产品数量 <strong>较少</strong>；</li><li>客户端只有一个“类型参数”，不关心如何创建对象；</li><li>希望集中管理对象创建逻辑；</li><li>创建逻辑简单，不需要复杂构建流程；</li></ul><p>典型场景：</p><ul><li>JDK 的工具类</li><li>加密算法（Cipher）</li><li>日期格式化（DateFormat）</li></ul><hr><p>JDK 经典例子：<code>DateFormat</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateFormat</span> <span class="hljs-variable">df1</span> <span class="hljs-operator">=</span> DateFormat.getDateInstance();<br><span class="hljs-type">DateFormat</span> <span class="hljs-variable">df2</span> <span class="hljs-operator">=</span> DateFormat.getDateInstance(DateFormat.FULL);<br><span class="hljs-type">DateFormat</span> <span class="hljs-variable">df3</span> <span class="hljs-operator">=</span> DateFormat.getDateInstance(DateFormat.FULL, Locale.US);<br></code></pre></td></tr></tbody></table></figure><p>这就是一个典型的 <strong>多个静态工厂方法</strong>。</p><hr><p>Java 加密 API 示例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">KeyGenerator</span> <span class="hljs-variable">keyGen</span> <span class="hljs-operator">=</span> KeyGenerator.getInstance(<span class="hljs-string">"DESede"</span>);<br><span class="hljs-type">Cipher</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"DESede"</span>);<br></code></pre></td></tr></tbody></table></figure><p><code>getInstance</code> 就是简单工厂。</p><h4 id="模式扩展：把工厂放到产品类中">模式扩展：把工厂放到产品类中</h4><p>可以将工厂方法直接写进抽象产品中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title function_">create</span><span class="hljs-params">(String type)</span> { ... }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>优点：减少类数量。</li><li>缺点：产品类职责增加，不够纯粹。</li></ul><p>下面我继续为你<strong>归纳 + 系统化讲解工厂方法模式（Factory Method Pattern）</strong>，内容结构与上一部分保持一致，并会适当插入 <strong>Mermaid UML 图代码</strong>，你可以直接放进 slides 使用。</p><h3 id="工厂方法模式">工厂方法模式</h3><p>简单工厂模式的问题：</p><ul><li>工厂类只有一个，负责所有产品实例化 → <strong>职责过重</strong></li><li>增加新产品必须修改工厂类 → <strong>违反开闭原则</strong></li><li>产品越多，判断逻辑越复杂 → <strong>不利维护与扩展</strong></li></ul><p>工厂方法模式的目标就是解决这些问题：<strong>把创建对象的选择延迟到子类，由子类决定创建哪种产品。</strong></p><hr><p><strong>问题</strong>：如何“扩展”一个产品，而不修改已有工厂？</p><p>例：按钮系统 → 圆形按钮、矩形按钮、菱形按钮……如果想增加 “椭圆形按钮”，简单工厂必须修改 <code>if</code>…<code>else</code>。</p><p><strong>解决</strong>：把“创建哪个按钮”的决定交给子类</p><ul><li>定义一个抽象工厂：<code>ButtonFactory</code></li><li>每种按钮对应一个工厂子类：<code>CircleButtonFactory</code>、<code>RectButtonFactory</code>…</li><li>子类负责实例化具体按钮</li></ul><p>优点：不改旧代码，<strong>直接增加新工厂即可</strong> → <strong>完全符合开闭原则</strong>！</p><hr><blockquote><p><strong>工厂方法模式：定义一个创建对象的接口（工厂方法），让子类决定实例化哪一个类。</strong></p><p>工厂方法让一个类的实例化延迟到其子类完成。</p></blockquote><p><strong>角色说明</strong>：</p><ul><li><strong>Product</strong>（抽象产品）：所有产品的父接口</li><li><strong>ConcreteProduct</strong>（具体产品）：具体产品实现</li><li><strong>Factory</strong>（抽象工厂）：声明工厂方法</li><li><strong>ConcreteFactory</strong>（具体工厂）：真正生产对应的具体产品</li></ul><pre><code class="mermaid">classDiagram
    class Product {
        &lt;&lt;interface&gt;&gt;
    }
    class ConcreteProductA
    class ConcreteProductB

    Product &lt;|.. ConcreteProductA
    Product &lt;|.. ConcreteProductB

    class Factory {
        &lt;&lt;abstract&gt;&gt;
        +createProduct() Product
    }

    class ConcreteFactoryA {
        +createProduct() Product
    }
    class ConcreteFactoryB {
        +createProduct() Product
    }

    Factory &lt;|-- ConcreteFactoryA
    Factory &lt;|-- ConcreteFactoryB
    ConcreteFactoryA --&gt; ConcreteProductA
    ConcreteFactoryB --&gt; ConcreteProductB
</code></pre><hr><p>典型实例：</p><ol><li><strong>抽象产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>具体产品</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPay</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 现金支付处理</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>抽象工厂</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayMethodFactory</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractPay <span class="hljs-title function_">createPayMethod</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>具体工厂</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPayFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PayMethodFactory</span> {<br>    <span class="hljs-keyword">public</span> AbstractPay <span class="hljs-title function_">createPayMethod</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashPay</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li><strong>客户端</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PayMethodFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashPayFactory</span>();<br><span class="hljs-type">AbstractPay</span> <span class="hljs-variable">pay</span> <span class="hljs-operator">=</span> factory.createPayMethod();<br>pay.pay();<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>优点</strong>：</p><table><thead><tr><th style="text-align:center">简单工厂</th><th style="text-align:center">工厂方法</th></tr></thead><tbody><tr><td style="text-align:center">新产品 → 修改工厂</td><td style="text-align:center">新产品 → 创建新工厂</td></tr><tr><td style="text-align:center">不符合开闭原则</td><td style="text-align:center"><strong>完全符合开闭原则</strong></td></tr><tr><td style="text-align:center">工厂逻辑复杂</td><td style="text-align:center">工厂类单一职责</td></tr><tr><td style="text-align:center">静态方法不可扩展</td><td style="text-align:center">多态，可以动态加载</td></tr></tbody></table><p><strong>工厂方法利用多态，通过子类决定“创建什么产品”，实现耦合解散。</strong></p><hr><p><strong>反射 + 配置文件</strong>（高级使用）</p><p>实际开发中可以不用 <code>new</code>：</p><p>XML：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">className</span>&gt;</span>CashPayFactory<span class="hljs-tag">&lt;/<span class="hljs-name">className</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Java：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(className);<br><span class="hljs-type">PayMethodFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> (PayMethodFactory) c.newInstance();<br></code></pre></td></tr></tbody></table></figure><p>优点：<strong>新增产品完全零修改客户端代码</strong></p><hr><p><strong>适用场景</strong>：</p><p>工厂方法非常适用于：</p><ol><li><strong>类不知道需要创建何种类的实例</strong></li><li><strong>系统需要在运行时决定创建哪个产品</strong></li><li><strong>想做到真正的开闭原则</strong></li></ol><p>典型使用地方：</p><ul><li>JDBC</li><li>JNDI</li><li>JMS</li><li>Spring BeanFactory（底层思想）</li></ul><h3 id="抽象工厂模式">抽象工厂模式</h3><p>工厂方法模式一个工厂只负责一个产品等级结构。但开发中经常出现：</p><ul><li>一个工厂要生产<strong>多个相互关联的产品对象</strong></li><li>这些产品分属于不同的“产品等级结构”（类的继承体系）</li><li>这些产品必须来自同一个“产品族”（例如海尔电视 + 海尔冰箱）</li></ul><blockquote><p>工厂方法模式无法同时创建多个产品族内的不同产品，因此需要抽象工厂模式。</p></blockquote><p><strong>两个关键概念</strong>：</p><table><thead><tr><th style="text-align:center">概念</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>产品等级结构</strong>（Product Hierarchy）</td><td style="text-align:center">指一个抽象产品及其所有具体子类，构成一个继承体系</td></tr><tr><td style="text-align:center"><strong>产品族</strong>（Product Family）</td><td style="text-align:center">指同一工厂生产的、属于不同等级结构的一组产品（一起使用）</td></tr></tbody></table><p>例如：</p><ul><li>产品等级结构1：电视（抽象电视 → 海尔电视、TCL电视…）</li><li>产品等级结构2：冰箱（抽象冰箱 → 海尔冰箱、TCL冰箱…）</li></ul><p>“海尔”是一个产品族，“TCL”也是产品族。</p><ul><li>当需要“同时创建同一个品牌的电视 + 冰箱”等一组产品时，使用抽象工厂。</li></ul><hr><blockquote><p><strong>抽象工厂模式（Abstract Factory）</strong>：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</p></blockquote><p>又叫 <strong>Kit 模式</strong>。</p><p><strong>模式结构</strong></p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>AbstractFactory（抽象工厂）</strong></td><td style="text-align:center">声明“每个产品族”中产品的创建方法</td></tr><tr><td style="text-align:center"><strong>ConcreteFactory（具体工厂）</strong></td><td style="text-align:center">实现抽象工厂，创建某个产品族中的所有产品</td></tr><tr><td style="text-align:center"><strong>AbstractProduct（抽象产品）</strong></td><td style="text-align:center">每个产品等级结构的抽象父类</td></tr><tr><td style="text-align:center"><strong>Product（具体产品）</strong></td><td style="text-align:center">具体工厂创建的产品类</td></tr></tbody></table><pre><code class="mermaid">classDiagram
    class AbstractFactory {
        +createTV() AbstractTV
        +createFridge() AbstractFridge
    }

    class HaierFactory {
        +createTV() HaierTV
        +createFridge() HaierFridge
    }

    class TCLFactory {
        +createTV() TCLTV
        +createFridge() TCLFridge
    }

    AbstractFactory &lt;|-- HaierFactory
    AbstractFactory &lt;|-- TCLFactory

    class AbstractTV
    class HaierTV
    class TCLTV
    AbstractTV &lt;|.. HaierTV
    AbstractTV &lt;|.. TCLTV
    HaierFactory --&gt; HaierTV
    TCLFactory --&gt; TCLTV

    class AbstractFridge
    class HaierFridge
    class TCLFridge
    AbstractFridge &lt;|.. HaierFridge
    AbstractFridge &lt;|.. TCLFridge
    HaierFactory --&gt; HaierFridge
    TCLFactory --&gt; TCLFridge
</code></pre><hr><p><strong>优点</strong>：</p><ol><li><p><strong>隔离具体类</strong>，客户端完全不知道产品具体类名称 → 松耦合。</p></li><li><p><strong>保证产品族的一致性</strong>，创建出的产品一定属于同一族（如海尔电视 + 海尔冰箱）。</p></li><li><p><strong>增加产品族方便</strong>（扩展性强），新增一个品牌 → 增加一个新的 ConcreteFactory 即可。</p></li></ol><p><strong>缺点</strong>：</p><ol><li><strong>难以增加新的产品等级结构</strong>（非常重要）</li></ol><p>例如：</p><ul><li>原来只有电视 + 冰箱</li><li>想增加“洗衣机”</li></ul><p>❗需要修改：</p><ul><li>抽象工厂接口</li><li>所有具体工厂类</li></ul><p>违背开闭原则 → <strong>开闭原则的倾斜性</strong></p><ol start="2"><li><strong>类数量多，结构复杂</strong></li></ol><hr><p>抽象工厂模式适用于：</p><ul><li>系统需要与环境绑定（如 GUI 主题、OS UI）</li><li>程序需同时创建某一产品族中的多个对象</li><li>一个产品族中的多个对象必须一起使用</li><li>系统提供产品接口库，隐藏实现细节</li></ul><p>典型例子：</p><ul><li>Java AWT：不同操作系统生成不同外观组件</li><li>GUI 主题切换：按钮 + 输入框 + 背景成套变化</li></ul><hr><p><strong>模式扩展</strong></p><p>开闭原则的倾斜性（<strong>非常关键</strong>）：</p><table><thead><tr><th style="text-align:center">扩展内容</th><th style="text-align:center">难度</th></tr></thead><tbody><tr><td style="text-align:center"><strong>增加新的产品族</strong></td><td style="text-align:center">简单（新增 ConcreteFactory）</td></tr><tr><td style="text-align:center"><strong>增加新的产品等级结构</strong></td><td style="text-align:center">困难（必须改抽象工厂 + 所有具体工厂）</td></tr></tbody></table><h4 id="抽象工厂方法的退化链条">抽象工厂方法的退化链条</h4><table><thead><tr><th>情况</th><th>退化成</th></tr></thead><tbody><tr><td>抽象工厂中每个具体工厂只有一个工厂方法</td><td>工厂方法模式</td></tr><tr><td>工厂方法中的抽象工厂和具体工厂合并，且方法改为 static</td><td>简单工厂模式</td></tr></tbody></table><p>它们三个其实是一个“进阶链”。</p><hr><blockquote><p><strong>抽象工厂模式的本质是 —— 选择整个产品族的实现。</strong></p></blockquote><p>工厂方法选择“一个产品”，</p><p>抽象工厂选择“一系列相关产品（产品族）”。</p><hr><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">简单工厂</th><th style="text-align:center">工厂方法</th><th style="text-align:center">抽象工厂</th></tr></thead><tbody><tr><td style="text-align:center"><strong>创建什么</strong></td><td style="text-align:center">一个产品</td><td style="text-align:center">一个产品等级结构</td><td style="text-align:center">一个产品族（多产品等级结构）</td></tr><tr><td style="text-align:center"><strong>如何创建</strong></td><td style="text-align:center">静态方法 + 分支判断</td><td style="text-align:center">多态：子类决定创建哪种产品</td><td style="text-align:center">多态：子类一次创建多个相关产品</td></tr><tr><td style="text-align:center"><strong>扩展新产品是否修改旧代码？</strong></td><td style="text-align:center"><strong>必须修改工厂类</strong></td><td style="text-align:center"><strong>新建工厂即可</strong></td><td style="text-align:center"><strong>新建工厂即可</strong>（仅限产品族）</td></tr><tr><td style="text-align:center"><strong>对开闭原则的支持</strong></td><td style="text-align:center">差</td><td style="text-align:center">好</td><td style="text-align:center">倾斜：对产品族好，对产品等级结构差</td></tr><tr><td style="text-align:center"><strong>适用场景</strong></td><td style="text-align:center">产品简单</td><td style="text-align:center">产品等级结构扩展</td><td style="text-align:center">多产品族、整体替换主题/平台</td></tr><tr><td style="text-align:center"><strong>示例</strong></td><td style="text-align:center"><code>DateFormat.parse()</code></td><td style="text-align:center">JDBC <code>DriverManager</code></td><td style="text-align:center">GUI 主题、AWT Toolkit</td></tr><tr><td style="text-align:center"><strong>复杂度</strong></td><td style="text-align:center">最简单</td><td style="text-align:center">中等</td><td style="text-align:center">最高</td></tr></tbody></table><h3 id="建造者模式">建造者模式</h3><p>在现实世界与软件系统中，有些对象结构复杂，需要多个步骤才能完成。例如：</p><ul><li>车 = 轮胎 + 发动机 + 座椅 + 方向盘</li><li>游戏中的地图 = 天空 + 背景 + 地面</li><li>邮件对象 = 发送者 + 接收者 + 标题 + 内容 + 日期…</li></ul><p><strong>复杂对象 = 多个组件 + 有顺序的组装步骤</strong></p><p>关键问题：</p><ul><li>用户 <strong>不需要</strong> 明确知道这些组件如何组合</li><li>产品内部构造很复杂</li><li>构建步骤通常必须按顺序</li><li>不同建造者可以产生不同版本的产品（如不同风格的 UI、不同配置的电脑）</li></ul><p>解决方案：<strong>将构建过程与产品组成分离，封装到 <code>Builder</code> 中，由 <code>Director</code> 指挥组装。</strong></p><hr><blockquote><p><strong>建造者模式（Builder Pattern）</strong>： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>也就是<strong>把“怎么构建”与“构建出的对象长什么样”分开。</strong></p><p><strong>模式结构</strong>：</p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Builder（抽象建造者）</strong></td><td style="text-align:center">定义构建产品部件的接口</td></tr><tr><td style="text-align:center"><strong>ConcreteBuilder（具体建造者）</strong></td><td style="text-align:center">实现具体部件的构造与装配</td></tr><tr><td style="text-align:center"><strong>Director（指挥者）</strong></td><td style="text-align:center">控制构建顺序，调用 Builder 的方法</td></tr><tr><td style="text-align:center"><strong>Product（产品）</strong></td><td style="text-align:center">最终生成的复杂对象</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251119145606655.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>优点</strong>：</p><ul><li><strong>分离构建与表示</strong>（符合单一职责原则）</li><li><strong>相同构建过程可以生成不同产品</strong></li><li><strong>更精细控制构建步骤</strong></li><li><strong>增加新的建造者容易</strong>（符合开闭原则）</li><li><strong>隐藏复杂构建逻辑，客户端无需知晓内部细节</strong></li></ul><p><strong>缺点</strong>：</p><ul><li>产品结构相似，才能使用，否则 <code>Builder</code> 太多</li><li>产品内部变化复杂时 <code>Builder</code> 也会变复杂</li></ul><hr><p><strong>适用场景</strong>：</p><ul><li>产品内部结构 <strong>复杂</strong>（多属性、多子对象）</li><li>产品构建需要 <strong>特定顺序</strong></li><li>创建产品过程需要 <strong>独立于产品类</strong></li><li>同样的构建步骤要生产 <strong>不同风格的产品</strong></li></ul><hr><p><strong>经典应用</strong>：</p><ol><li><p>JavaMail 邮件构建流程（邮件内容多，构建步骤多 → 非常适合 Builder）</p></li><li><p>游戏中的“地图/人物建造器”</p></li><li><p>GUI 界面搭建（如 Swing/AWT）</p></li><li><p>SQL 构造器（MyBatis、Hibernate）</p></li></ol><hr><p><strong>模式扩展</strong>：</p><p><strong>可简化版本</strong></p><ul><li><p><strong>去掉 <code>AbstractBuilder</code></strong></p></li><li><p><strong>去掉 <code>Director</code></strong></p></li><li><p>甚至两者合并</p></li></ul><p>适合产品结构简单、只有一个 <code>Builder</code> 时。</p><hr><table><thead><tr><th style="text-align:center">比较项</th><th style="text-align:center">Builder</th><th style="text-align:center">Abstract Factory</th></tr></thead><tbody><tr><td style="text-align:center">返回对象</td><td style="text-align:center">完整产品</td><td style="text-align:center">产品家族（多个产品）</td></tr><tr><td style="text-align:center">核心思想</td><td style="text-align:center">关注构建步骤</td><td style="text-align:center">关注对象分类</td></tr><tr><td style="text-align:center">适用场景</td><td style="text-align:center">复杂对象，步骤明确</td><td style="text-align:center">多产品族</td></tr></tbody></table><p>比喻：</p><ul><li><strong>抽象工厂</strong> = 汽车配件工厂（轮胎、发动机）</li><li><strong>建造者模式</strong> = 汽车总装厂（组装一辆整车）</li></ul><h3 id="原型模式">原型模式</h3><p>问题场景：</p><ul><li>创建对象成本很高（构造复杂、消耗资源）</li><li>有时需要频繁创建类似对象</li><li>构造函数复杂但对象大部分状态相同</li></ul><p>解决方案：<strong>用原型对象克隆得到新对象，而不是重新 <code>new</code>。</strong></p><p>类比：</p><ul><li>拉一份文档模板再修改</li><li>复印机复制信件</li><li>复制 UI 组件后再修改</li></ul><hr><blockquote><p><strong>原型模式（Prototype Pattern）</strong>：通过复制现有实例来创建新的对象，而无需知道创建的细节。</p></blockquote><p>简化理解：<strong>不用 <code>new</code>，直接 <code>clone</code>。</strong></p><p><strong>模式结构</strong>：</p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Prototype（抽象原型）</strong></td><td style="text-align:center">定义 <code>clone</code> 方法</td></tr><tr><td style="text-align:center"><strong>ConcretePrototype（具体原型）</strong></td><td style="text-align:center">实现 <code>clone</code> 方法</td></tr><tr><td style="text-align:center"><strong>Client（客户端）</strong></td><td style="text-align:center">使用原型对象生成新对象</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251119145530992.png" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="深拷贝-浅拷贝">深拷贝 &amp; 浅拷贝</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">基本类型</th><th style="text-align:center">引用类型</th></tr></thead><tbody><tr><td style="text-align:center"><strong>浅拷贝</strong></td><td style="text-align:center">复制值</td><td style="text-align:center">仅复制引用地址</td></tr><tr><td style="text-align:center"><strong>深拷贝</strong></td><td style="text-align:center">复制值</td><td style="text-align:center">复制对象本身（递归克隆）</td></tr></tbody></table><p>Java 默认 <code>Object.clone()</code> 是 <strong>浅克隆</strong>。</p><p>深克隆可以通过：</p><ul><li>手动克隆每个引用对象</li><li>序列化（最常见）</li></ul><hr><p>示例：Java <code>clone()</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypeDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> {<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone(); <span class="hljs-comment">// 浅克隆</span><br>        } <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) {<br>            System.err.println(<span class="hljs-string">"Not support cloneable"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>使用场景</strong></p><p>适合：</p><ul><li>创建对象开销大（IO、数据库、复杂计算）</li><li>对象大量相似，只需少量属性不同</li><li>系统需要保存对象不同历史状态（可与备忘录模式结合）</li><li>需要避免庞大的工厂类层级结构</li></ul><hr><p><strong>优点</strong>：</p><ul><li><strong>效率高</strong>（避免复杂构造）</li><li><strong>减少类层次结构</strong></li><li><strong>动态扩展容易</strong>（新增原型不影响现有代码）</li><li><strong>可配合深克隆保存对象状态</strong></li></ul><p><strong>缺点</strong>：</p><ul><li>每个类都必须实现 <code>clone</code>（违反开闭原则）</li><li>深克隆代码复杂</li><li>存在多层嵌套对象时容易出错</li></ul><h4 id="带原型管理器">带原型管理器</h4><p>等价于一个“对象工厂”，内部存放多个原型对象。</p><pre><code class="mermaid">classDiagram
direction LR

class PrototypeManager {
    -registry : Map&lt;String, Prototype&gt;
    +add(name, prototype)
    +get(name) Prototype
}

PrototypeManager --&gt; Prototype
</code></pre><p>作用：</p><ul><li>管理多个原型</li><li>通过 key 复制对应对象</li></ul><hr><table><thead><tr><th style="text-align:center">设计模式</th><th style="text-align:center">本质</th></tr></thead><tbody><tr><td style="text-align:center"><strong>建造者模式</strong></td><td style="text-align:center">分离：构建算法 与 部件构造</td></tr><tr><td style="text-align:center"><strong>原型模式</strong></td><td style="text-align:center">克隆生成对象，避免重复构建</td></tr></tbody></table><h3 id="单例模式">单例模式</h3><p>在某些场景中，系统只需要某个类的一个实例，例如：</p><ul><li>文件系统</li><li>任务管理器</li><li>打印池 <code>Print Spooler</code></li><li>全局配置、日志记录器</li><li>序列号生成器</li></ul><p>传统方式（如全局变量）无法防止对象被重复实例化，因此需要一种机制——<strong>让类自己管理唯一实例，并提供全局访问点</strong>。</p><hr><blockquote><p><strong>保证一个类只有一个实例</strong>，并提供一个可访问它的<strong>全局访问点</strong>。</p></blockquote><p>要点：</p><ol><li>类只能有一个实例</li><li>类负责自行创建这个实例</li><li>类提供全局访问该实例的静态方法</li></ol><p><img src="https://images.kisechan.space/20251119151757573.png" srcset="/img/loading.gif" lazyload alt="image-20251119151757504"></p><hr><p>一个标准的单例类必须满足：</p><ul><li><strong>构造函数私有化</strong>（禁止外部 <code>new</code>）</li><li><strong>包含静态私有实例变量</strong></li><li><strong>提供静态公共工厂方法返回唯一实例</strong></li></ul><p>Java 实现示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}   <span class="hljs-comment">// 私有构造函数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) {<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 第一次访问时创建实例</span><br>        }<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p>示例 1：<strong>身份证号码</strong></p><pre><code class="mermaid">classDiagram
    class IDCard {
        - static instance : IDCard
        - idNumber : String
        - IDCard()
        + static getInstance() IDCard
        + getIdNumber() String
    }
   IDCard o--&gt; IDCard
</code></pre><p>居民身份证号唯一，一个人补办身份证时仍使用同一号码。</p><hr><p>示例 2：<strong>打印池</strong> <code>Print Spooler</code></p><pre><code class="mermaid">classDiagram
    class PrintSpooler {
        - static instance : PrintSpooler
        - PrintSpooler()
        + static getInstance() PrintSpooler
        + submitJob()
        + cancelJob()
    }
   
   PrintSpooler o--&gt; PrintSpooler
</code></pre><p>系统中只能有一个打印池程序，否则可能导致打印任务管理混乱。</p><p><strong>优点</strong>：</p><ul><li><strong>受控访问唯一实例</strong>，单例类通过自身封装严格控制实例创建。</li><li><strong>节约系统资源</strong>，频繁创建/销毁对象将增加开销，单例可以减少开销。</li><li><strong>允许扩展为“可控数量的实例”</strong>，可扩展为多例模式（Multiton），控制实例数目。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不易扩展</strong>：因为没有抽象层，很难继承和扩展</li><li><strong>职责过重</strong>：既负责创建实例又负责自身业务逻辑</li><li><strong>容易被滥用</strong>：可能导致对象共享过多，造成安全或资源问题（如把数据库连接池设计为单例导致连接耗尽）</li></ul><hr><p>适合使用单例模式的情况：</p><ul><li>系统中只需要一个实例（如日志记录器、配置管理器）</li><li>实例需要通过唯一的全局访问点访问</li><li>实例创建成本高、或需要在整个运行周期维持的对象</li></ul><p><strong>系统中的实际应用</strong></p><ol><li>Java Runtime（经典单例）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    }<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> {}<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>Spring 默认 <code>Bean Scope = Singleton</code></li></ol><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.Date"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"singleton"</span>/&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Spring 默认管理的 Bean 是单例级别（应用范围内共享）。</p><h4 id="单例模式的扩展">单例模式的扩展</h4><ol><li><strong>饿汉式</strong>（<strong>类加载时就创建对象</strong>）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> instance;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>优点：</strong> 线程安全、实现简单</p><p><strong>缺点：</strong> 可能占用不必要的资源（类加载时就创建）</p><pre><code class="mermaid">classDiagram
    class Singleton {
        - static instance : Singleton = new Singleton()
        - Singleton()
        + static getInstance() Singleton
    }
</code></pre><ol start="2"><li><strong>懒汉式</strong>（第一次使用时才创建）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span><br></code></pre></td></tr></tbody></table></figure><p><strong>优点：</strong> 节省资源</p><p><strong>缺点：</strong> 在多线程环境下需要同步，性能较低</p><pre><code class="mermaid">classDiagram
    class Singleton {
        - static instance : Singleton
        - Singleton()
        + static getInstance() Singleton  &lt;&lt;synchronized&gt;&gt;
    }
</code></pre><hr><p>单例模式的本质是：<strong>控制实例数量</strong>。</p><p>不仅可以控制为 1 个，也可以控制为 2 个、3 个或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 个 → 形成 <strong>多例模式</strong>（Multiton）。</p><h2 id="结构型设计模式">结构型设计模式</h2><p>结构型模式主要解决 —— <strong>如何把类或对象组合成更强大、更复杂的结构</strong>。</p><p>就像：</p><ul><li>积木组合 → 建筑</li><li>代码组件组合 → 模块化软件系统</li></ul><p>结构型模式分为两类：</p><ol><li><p><strong>类结构型模式</strong>（以继承关系为主）</p><ul><li><p>通过类与类之间的继承、实现关系组成更大结构</p></li><li><p>特点：编译期静态绑定，灵活性较低</p></li></ul></li><li><p><strong>对象结构型模式</strong>（以组合、聚合为主）</p><ul><li><p>对象组合：一个对象持有另一个对象，实现更灵活的结构</p></li><li><p>更符合“合成复用原则”（优先使用组合而不是继承）</p></li><li><p>大多数结构型模式属于对象结构型模式</p></li></ul></li></ol><p><strong>常见的结构型设计模式</strong>：</p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>适配器模式</strong> Adapter</td><td style="text-align:center">接口转换，使不兼容对象协同工作</td></tr><tr><td style="text-align:center"><strong>桥接模式</strong> Bridge</td><td style="text-align:center">将抽象与实现分离，两者独立变化</td></tr><tr><td style="text-align:center"><strong>组合模式</strong> Composite</td><td style="text-align:center">树形结构，统一处理单个与组合对象</td></tr><tr><td style="text-align:center"><strong>装饰模式</strong> Decorator</td><td style="text-align:center">动态为对象添加额外职责</td></tr><tr><td style="text-align:center"><strong>外观模式</strong> Facade</td><td style="text-align:center">为复杂子系统提供统一简化接口</td></tr><tr><td style="text-align:center"><strong>享元模式</strong> Flyweight</td><td style="text-align:center">共享对象，减少内存消耗</td></tr><tr><td style="text-align:center"><strong>代理模式</strong> Proxy</td><td style="text-align:center">控制访问对象，附加额外功能</td></tr></tbody></table><h3 id="适配器模式">适配器模式</h3><p>当“已有类”能满足需求但<strong>接口不兼容</strong>时，会出现以下问题：</p><ul><li>方法名不同</li><li>参数格式不同</li><li>类不方便修改（黑盒库、第三方库）</li></ul><p>类似我们日常使用的“电源适配器”：</p><ul><li>插头不匹配 → 使用 <code>adapter</code> 来转换接口</li></ul><p>适配器模式的目的：<strong>把一个接口转换成客户期望的接口，使得现有类可以复用。</strong></p><hr><p><strong>适配器模式</strong>（Adapter Pattern）：</p><blockquote><p>将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作。</p></blockquote><p>又称为：<strong>包装器</strong>（Wrapper）</p><p>适配器模式分两类：</p><ol><li><strong>类适配器</strong>（<strong>使用继承</strong>）</li><li><strong>对象适配器</strong>（<strong>使用组合</strong>）</li></ol><hr><h4 id="对象适配器">对象适配器</h4><p>对象适配器使用组合，更加常用。</p><p>注意，在图中， <strong><code>Target</code> 是我们需要调用的“统一的接口”</strong>，而 <code>Adaptee</code> 是旧的或者不兼容的接口，所以我们需要用 <code>Adapter</code> 兼容它的功能。</p><p><img src="https://images.kisechan.space/20251119173802423.png" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> {<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> {<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> {<br>        adaptee.specificRequest();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>特点：</p><ul><li><strong>更灵活</strong>，可适配多个适配者类</li><li>强烈符合“合成复用原则”</li></ul><hr><p>对象适配器的优点：</p><ul><li>一个适配器可以对应多个适配者实例</li><li>可以适配适配者及其子类</li><li>灵活性更高 → 使用更多</li></ul><p>缺点：</p><ul><li>不易重写适配者方法（除非再写子类）</li></ul><h4 id="类适配器">类适配器</h4><p>使用继承。</p><p><img src="https://images.kisechan.space/20251119173726029.png" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> {<br>        specificRequest(); <span class="hljs-comment">// 调用父类方法</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>特点：</p><ul><li>使用 <strong>多重继承（类继承 + 接口实现）</strong></li><li>Java/C# 不支持多重继承 → 只能继承一个 Adaptee</li></ul><p>类适配器的优点：</p><ul><li>由于使用继承，可以覆盖适配者的方法（更灵活）</li></ul><p>缺点：</p><ul><li><strong>不能适配多个适配者类</strong>（继承限制）</li><li>目标必须是接口或抽象类（否则不能继承）</li></ul><hr><p><strong>适配器模式的优点</strong>：</p><ul><li><strong>解耦</strong>：目标类与适配者类解耦</li><li><strong>复用性强</strong>：可以复用已有类（不用改源代码）</li><li><strong>符合开闭原则</strong>：可以随时添加新的适配器</li><li><strong>对象适配器支持适配多个类及其子类</strong></li></ul><hr><p><strong>适配器模式适用环境</strong></p><ul><li>系统需要使用某个类，但其接口不兼容</li><li>希望复用一些“功能相似但接口不同”的类</li><li>想为未来可能增加的新类（适配者）准备好扩展点</li></ul><hr><p><strong>应用实例</strong></p><ol><li><p><strong>JDBC 驱动</strong>（典型应用）</p><ul><li>JDBC → 抽象的 Target</li><li>数据库驱动 → Adapter</li><li>底层数据库 API → Adaptee</li><li>每种数据库都有自己的适配器。</li></ul></li><li><p><strong>JDK 的 <code>InputStreamAdapter</code></strong></p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> {<br>    ImageInputStream stream;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamAdapter</span><span class="hljs-params">(ImageInputStream stream)</span> {<br>        <span class="hljs-built_in">this</span>.stream = stream;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-keyword">return</span> stream.read();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException {<br>        <span class="hljs-keyword">return</span> stream.read(b, off, len);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>模式扩展</strong></p><ol><li><strong>默认适配器模式</strong>（接口适配器）</li></ol><p>当一个接口方法很多，但我们只需要一部分时：</p><ul><li>定义一个 <strong>默认适配器类（提供空方法）</strong></li><li>子类只需覆盖需要的方法</li></ul><p><img src="https://images.kisechan.space/20251119174411026.png" srcset="/img/loading.gif" lazyload alt=""></p><p>常见于 Java AWT：</p><ul><li><code>WindowAdapter</code></li><li><code>KeyAdapter</code></li><li><code>MouseAdapter</code></li></ul><ol start="2"><li><strong>双向适配器</strong></li></ol><p>可以同时转换：</p><ul><li>Target → Adaptee</li><li>Adaptee → Target</li></ul><p><img src="https://images.kisechan.space/20251119174346497.png" srcset="/img/loading.gif" lazyload alt="image-20251119174346420"></p><ol start="3"><li><strong>智能适配器</strong></li></ol><p>在调用前后加入附加处理，例如：</p><ul><li>日志</li><li>校验</li><li>缓存</li><li>自动选择不同的适配者（策略化）</li></ul><hr><blockquote><p>适配器模式的本质：<strong>转换匹配 + 复用功能</strong></p></blockquote><p>核心理念：</p><ul><li>不修改旧代码</li><li>把旧接口“包装”为新接口</li><li>让不兼容的类可以协作</li></ul><p>结构型模式的核心是：<strong>通过组合/继承构建更强大结构</strong>，适配器模式正是其中最典型的“接口转换器”。</p><h3 id="桥接模式">桥接模式</h3><p>蜡笔具有两个变化维度：</p><ul><li>颜色（12 种）</li><li>型号（大、中、小）</li></ul><p>它们被“绑定在同一类中”：</p><blockquote><p>型号 + 颜色 → 一个具体类</p></blockquote><p>所以：</p><ul><li>增加一种型号 → 多 12 个类</li><li>增加一种颜色 → 多 3 个类</li></ul><p>最终膨胀为 36 个类。</p><p>原因：<strong>两个变化维度没有分离（耦合大）</strong>。</p><hr><p>而毛笔分为：</p><ul><li>型号 → 3 种笔（抽象维度）</li><li>颜色 → 12 种颜料（实现维度）</li></ul><p>组合后仍然可以实现 3×12 的组合，但只需 <strong>3 + 12 = 15 类对象</strong>。</p><p>图形学中的“形状 Shape + 颜色 Color”也是同样的问题。</p><p>此类问题的本质：</p><blockquote><p><strong>某个类存在两个（或多个）独立变化的维度</strong>，但如果写死在一个类中，扩展必然爆炸。</p></blockquote><hr><p><strong>桥接模式</strong>：</p><blockquote><p><strong>将抽象部分与实现部分分离</strong>，使它们都可以独立地变化。</p></blockquote><p>关键词：</p><ul><li>独立变化的维度（如“形状”和“颜色”）</li><li>抽象部分（Abstraction）</li><li>实现部分（Implementor）</li><li>用“对象组合”代替“继承耦合”</li><li>是对象结构型模式</li></ul><p>经常也被叫做：</p><ul><li>Handle and Body</li><li>Interface</li></ul><p><img src="https://images.kisechan.space/20251119211900832.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li><strong>实现接口</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Implementor</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationImpl</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>抽象部分</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> {<br>    <span class="hljs-keyword">protected</span> Implementor impl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImpl</span><span class="hljs-params">(Implementor impl)</span> {<br>        <span class="hljs-built_in">this</span>.impl = impl;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>扩展抽象部分</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 先做抽象类的操作</span><br>        impl.operationImpl();  <span class="hljs-comment">// 调用实现层的方法</span><br>        <span class="hljs-comment">// 再做子类扩展操作</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="桥接模式实例：模拟毛笔">桥接模式实例：模拟毛笔</h4><p>根据课件：3 种型号 × 5 种颜色。</p><ol><li><strong>颜色的维度（Implementor）</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Color</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(String penType, String name)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>不同颜色实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Color</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(String penType, String name)</span> {<br>        System.out.println(penType + <span class="hljs-string">" red "</span> + name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>型号的维度（Abstraction）</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pen</span> {<br>    <span class="hljs-keyword">protected</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(Color color)</span> {<br>        <span class="hljs-built_in">this</span>.color = color;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String name)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>型号的子类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigPen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pen</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String name)</span> {<br>        color.paint(<span class="hljs-string">"Big pen"</span>, name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>使用示例</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pen</span> <span class="hljs-variable">pen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigPen</span>();<br>pen.setColor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Red</span>());<br>pen.draw(<span class="hljs-string">"Flower"</span>);<br></code></pre></td></tr></tbody></table></figure><p><strong>桥接模式的优点</strong>：</p><table><thead><tr><th style="text-align:left">优点</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. 分离抽象与实现</strong>（最核心）</td><td>两个维度可独立变化</td></tr><tr><td style="text-align:left"><strong>2. 替代多重继承</strong></td><td>避免继承层次爆炸</td></tr><tr><td style="text-align:left"><strong>3. 组合优于继承</strong></td><td>更灵活、更可扩展</td></tr><tr><td style="text-align:left"><strong>4. 任意维度扩展不影响对方</strong></td><td>符合开闭原则</td></tr><tr><td style="text-align:left"><strong>5. 运行期动态切换实现</strong></td><td>更灵活</td></tr></tbody></table><p><strong>缺点</strong></p><ul><li>增加设计复杂度</li><li>需要识别“独立变化的维度”，需要经验</li></ul><hr><p><strong>适用场景</strong></p><ul><li>当一个类有 <strong>两个或多个独立变化维度</strong></li><li>不希望使用继承来绑定多个维度</li><li>想要在运行时动态切换某一个维度</li><li>系统要支持组合爆炸（如 3×5）但不能真的写那么多个类</li></ul><hr><blockquote><p>桥接模式的本质是：<strong>分离抽象和实现，让它们可以独立变化。</strong></p></blockquote><p>其余优点（动态切换、减少子类个数等）都是这一点带来的必然结果。</p><hr><h4 id="桥接-适配器模式">桥接 + 适配器模式</h4><p>两种模式的区别：</p><table><thead><tr><th style="text-align:center">点</th><th style="text-align:center">桥接模式</th><th style="text-align:center">适配器模式</th></tr></thead><tbody><tr><td style="text-align:center">目的</td><td style="text-align:center">解耦“抽象与实现”两个独立变化维度</td><td style="text-align:center">兼容已有接口，使旧代码能用</td></tr><tr><td style="text-align:center">用在</td><td style="text-align:center">系统设计初期</td><td style="text-align:center">系统已经成型后，为兼容旧代码/第三方库</td></tr><tr><td style="text-align:center">改代码</td><td style="text-align:center">需要设计两个层次结构</td><td style="text-align:center">不需要改原有类（黑盒）</td></tr><tr><td style="text-align:center">本质</td><td style="text-align:center">组合两个维度</td><td style="text-align:center">转换接口</td></tr><tr><td style="text-align:center">解决问题</td><td style="text-align:center">扩展性和解耦</td><td style="text-align:center">可复用性和兼容性</td></tr></tbody></table><p>一句话总结：</p><blockquote><ul><li>桥接：<strong>设计好的解耦结构</strong></li><li>适配器：<strong>后期发现接口不兼容时的补丁</strong></li></ul></blockquote><hr><p><strong>联用场景</strong>：报表显示 × 数据源读取</p><p>需求：</p><ul><li>报表有多种显示方式（PDF / HTML …）</li><li>数据源有多种读取方式（txt / DB / Excel …）</li></ul><p>→ 报表（抽象维度）<br>→ 数据源（实现维度）</p><p>但 Excel API 由第三方提供，需要：</p><ul><li><code>ExcelDataReaderAdapter</code>（适配器）转为系统可用格式</li><li><code>DataReader</code> 是 bridge 的实现层</li></ul><p>结构示意：</p><p><img src="https://images.kisechan.space/20251119212646602.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p>问：<strong>为什么要桥接 + 适配</strong>？</p><p>因为：</p><ul><li><strong>桥接</strong>解决“报表显示方式 × 数据读取方式”的多维扩展</li><li><strong>适配器</strong>解决“Excel API 与系统接口不兼容”</li></ul><p>进一步总结：</p><table><thead><tr><th>模式</th><th>在此场景中作用</th></tr></thead><tbody><tr><td><strong>桥接</strong></td><td>报表和数据源是两个维度，需灵活组合</td></tr><tr><td><strong>适配器</strong></td><td>Excel API 接口与 <code>DataReader</code> 不兼容</td></tr></tbody></table><p>这一组合在实际系统中极其常见：</p><ul><li>多媒体播放器（视频编码 × 播放方式）</li><li>数据可视化（图表类型 × 数据供应器）</li><li>跨平台 GUI（控件 × 渲染接口）</li></ul><h3 id="组合模式">组合模式</h3><p>现实中大量结构是 <strong>树形结构</strong>，例如：</p><ul><li>文件系统：文件夹里有文件和子文件夹</li><li>公司组织：部门 &gt; 小组 &gt; 员工</li><li>GUI 系统：窗口 &gt; 面板 &gt; 控件</li></ul><p><strong>问题：</strong><br>容器节点（<code>Folder</code>）和叶子节点（<code>File</code>）功能不一样，如果客户端要遍历它们，就必须区分处理：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">if (node is folder) {<br>    traverse children<br>} else if (node is file) {<br>    open file<br>}<br></code></pre></td></tr></tbody></table></figure><p>这会让客户端代码复杂、难以维护。</p><p><strong>组合模式的目标：</strong>“让客户端对叶子对象和容器对象一视同仁（统一处理）。”</p><hr><p><strong>组合模式</strong>：</p><blockquote><p>通过把对象组合成树形结构，让客户端对 <em>整体</em> 和 <em>部分</em> 的使用保持一致。</p></blockquote><ul><li>叶子对象（Leaf）：没有子节点</li><li>容器对象（Composite）：含有子节点（叶子或容器）</li><li>抽象组件（Component）：对两者统一建模并提供相同接口</li><li>客户端（Client）：只依赖 Component，不关心是叶子还是组合</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">    Component<br>   /         \<br>Leaf      Composite<br>               |<br>            children[]<br></code></pre></td></tr></tbody></table></figure><p>Component 中会出现的典型结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">add(c)<br>remove(c)<br>getChild(i)<br>operation()<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>抽象组件</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); }<br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>叶子组件</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"Leaf operation"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>容器组件</strong>（重点：<strong>递归</strong>）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    List&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> { children.add(c); }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> { children.remove(c); }<br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> { <span class="hljs-keyword">return</span> children.get(i); }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">for</span> (Component c : children) {<br>            c.operation();   <span class="hljs-comment">// 递归</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://images.kisechan.space/20251119214330094.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p>实例：<strong>水果盘</strong>（Plate）</p><ul><li>Leaf：Apple, Banana</li><li>Composite：Plate（含若干水果或子盘子）</li><li>调用 <code>operation()</code> → 遍历整个结构并吃掉水果</li></ul><p><img src="https://images.kisechan.space/20251119214246123.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>优点</strong>：</p><ol><li><strong>统一叶子与容器接口</strong> —— 客户端不必区分</li><li><strong>容易扩展</strong> —— 添加新的 Leaf 或 Composite 不影响原有代码</li><li><strong>天然适配树结构</strong> —— 遍历用递归即可</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>难以限制容器的子类型</strong>（可能放入非法类型组件）</li><li><strong>管理子节点操作可能导致叶子类出现无意义方法</strong>（透明模式）</li></ol><h4 id="透明组合模式">透明组合模式</h4><p>较为常见</p><p><code>Component</code> 中包含 <code>add</code>/<code>remove</code>/<code>getChild()</code><br>→ 客户端统一处理<br>→ <strong><code>Leaf</code> 中这些方法无意义，但必须实现（抛异常）</strong></p><h4 id="安全组合模式">安全组合模式</h4><p><code>Component</code> 不包含 <code>add</code>/<code>remove</code>/<code>getChild</code>，<code>Composite</code> 中才有 <code>add</code>/<code>remove</code><br>→ 安全，但客户端必须区分 <code>Composite</code>/<code>Leaf</code></p><hr><blockquote><p>组合模式的本质：<strong>统一叶子对象和组合对象</strong>。</p></blockquote><p>客户端只面对 Component，不管是整体还是部分都一样使用。</p><h3 id="装饰模式">装饰模式</h3><p>给对象<strong>动态添加功能</strong>有几种方式：</p><ol><li><strong>继承</strong>（缺点：静态、组合爆炸）</li></ol><p>想给 Car 添加各种功能：</p><ul><li>会说话</li><li>会飞</li><li>会射击</li><li>会游泳</li></ul><p>如果用继承：</p><blockquote><p><code>FlyingTalkingSwimmingShootingCar</code></p></blockquote><p>类爆炸，扩展困难。</p><ol start="2"><li><strong>关联</strong>（装饰模式思想）</li></ol><blockquote><p><code>Car</code> -&gt; 装饰器(飞) -&gt; 装饰器(说话) -&gt; 装饰器(泳)</p></blockquote><p><strong>动态组合、随装随改、可多次叠加。</strong></p><hr><p>装饰模式通过创建一个“<strong>装饰器对象</strong>”包裹原对象，在原方法执行的前后增强行为，实现功能的动态叠加。</p><p>别名：Wrapper（包装器）</p><blockquote><p>装饰模式的核心：<strong>动态组合，而不是继承</strong>。</p></blockquote><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">         Component<br>      /              \<br>ConcreteComponent  Decorator<br>                      |<br>             ConcreteDecoratorA<br>             ConcreteDecoratorB<br></code></pre></td></tr></tbody></table></figure><p><img src="https://images.kisechan.space/20251119214859977.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>抽象组件</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体组件</strong>（被装饰对象）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"基础功能"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>抽象装饰类</strong>（关键）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> {<br>    <span class="hljs-keyword">protected</span> Component component;<br>  	<span class="hljs-comment">// 注意这里，记录了一个外层的装饰器</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component c)</span> {<br>        <span class="hljs-built_in">this</span>.component = c;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        component.operation();   <span class="hljs-comment">// 默认先调用原功能</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体装饰器</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecoratorA</span><span class="hljs-params">(Component c)</span> { <span class="hljs-built_in">super</span>(c); }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> {<br>        <span class="hljs-built_in">super</span>.operation();<br>        System.out.println(<span class="hljs-string">"附加功能A"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p>实例：<strong>变形金刚</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Car <span class="hljs-comment">(基础)</span><br>  ↓ 装饰为 Robot<br>Robot <br>  ↓ 再装饰为 飞机<br>RobotFly<br></code></pre></td></tr></tbody></table></figure><p>客户端：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Component</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RobotDecorator</span>(c);    <span class="hljs-comment">// 变成机器人</span><br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirplaneDecorator</span>(c); <span class="hljs-comment">// 加飞行能力</span><br>c.operation();<br></code></pre></td></tr></tbody></table></figure><p><strong>优点</strong>：</p><ol><li><strong>比继承更灵活（组合 &gt; 继承）</strong></li><li><strong>功能小而单一，易复用</strong></li><li><strong>动态：运行时自由叠加</strong></li></ol><p><strong>缺点</strong>：</p><ol><li><strong>类数变多</strong>（每一种功能一个装饰器）</li><li><strong>排查问题（多层嵌套）较困难</strong></li></ol><hr><p><strong>适用场景</strong></p><ul><li>不改原有类结构，但想给对象添加功能</li><li>许多独立功能需要自由组合</li><li>类不能继承（例如 <code>final class</code>）</li></ul><p>特别常见于：</p><ul><li><strong>Java I/O 体系（最典型）</strong></li><li><strong>Swing/<code>JScrollPane</code> 装饰 <code>JList</code></strong></li><li><strong>流式 API 中增强行为</strong></li></ul><h4 id="透明装饰模式">透明装饰模式</h4><p>所有东西都用 <code>Component</code> 类型接收：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Component</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvancedDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>()));<br></code></pre></td></tr></tbody></table></figure><h4 id="半透明装饰模式">半透明装饰模式</h4><p>更常见。</p><p>允许访问具体装饰器的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Robot</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Robot</span>(car);<br>r.say();  <span class="hljs-comment">// 特有功能</span><br></code></pre></td></tr></tbody></table></figure><hr><blockquote><p>装饰模式的本质是“<strong>动态组合对象行为</strong>”。</p></blockquote><ul><li>动态（运行时）</li><li>组合（不是继承）</li><li>通过叠加装饰器来增强功能</li></ul><h3 id="外观模式">外观模式</h3><p>现实中的场景：</p><ul><li>组装电脑需要分别和 CPU 商家、主板商家、显卡商家打交道 → <strong>复杂</strong>。</li><li>找装机店 → 只跟装机店沟通，装机店内部对接多个商家 → <strong>简单</strong>。</li></ul><p>在软件系统中：客户端若要使用系统 A 的功能，却必须调用 <strong>子系统 A、子系统 B、子系统 C</strong>……</p><p>这让客户端代码变得复杂、耦合度高。</p><p><strong>解决方案：引入“外观角色”（Facade）</strong><br>→ 客户端只与外观类交互<br>→ 外观类内部协同多个子系统完成任务<br>→ 隐藏系统复杂性，降低耦合度。</p><hr><blockquote><p>外观模式（Facade Pattern）：<strong>为子系统中的一组接口提供一个统一的入口</strong>。</p><p>它定义一个高层接口，让子系统更易使用。</p></blockquote><p>特性：</p><ul><li>客户端只需与外观类交互，不需要了解子系统细节。</li><li>外观模式是 <strong>迪米特法则</strong>（最少知识原则） 的典型实现。</li></ul><hr><p><strong>模式结构与角色</strong></p><ol><li><p><strong>Facade</strong> <strong>外观角色</strong></p><ul><li><p>提供一个统一入口，封装对子系统的调用逻辑。</p></li><li><p>知道“应该调用哪个子系统”。</p></li></ul></li><li><p><strong>SubSystem</strong> <strong>子系统角色</strong></p><ul><li><p>完成实际业务逻辑。</p></li><li><p>不知道外观类的存在。</p></li></ul></li></ol><p><img src="https://images.kisechan.space/20251120104532730.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>模式实现示例</strong></p><ol><li><strong>子系统类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemA</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodA</span><span class="hljs-params">()</span> { }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemB</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodB</span><span class="hljs-params">()</span> { }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemC</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodC</span><span class="hljs-params">()</span> { }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>外观类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemA</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemB</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemC</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemC</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>        a.MethodA();<br>        b.MethodB();<br>        c.MethodC();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>客户端</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Facade</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br>f.method();<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>优点</strong></p><ul><li><strong>大幅降低系统复杂度</strong>，客户端只依赖外观类。</li><li><strong>子系统变化不影响客户端</strong>。</li><li>客户端更易使用（统一入口）。</li><li>外观可以作为系统 API 的入口（分层结构的边界）。</li></ul><p><strong>缺点</strong></p><ul><li>过度使用可能让 “外观类过于臃肿”。</li><li>增加或删除子系统需要修改外观类 → <strong>违反开闭原则</strong>。</li></ul><hr><p><strong>模式适用场景</strong></p><ul><li>系统复杂，希望给客户一个简单接口。</li><li>客户端与多个子系统高度耦合。</li><li>分层架构中，使用外观作为层之间的 API。</li></ul><hr><p><strong>模式实例</strong>：<strong>JDBC 外观封装</strong></p><p>传统 JDBC 要创建：Connection → Statement → ResultSet<br>非常繁琐。</p><p>外观类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCFacade</span> {<br>    <span class="hljs-keyword">private</span> Connection conn;<br>    <span class="hljs-keyword">private</span> Statement statement;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(...)</span> { ... }<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeUpdate</span><span class="hljs-params">(String sql)</span> { ... }<br>    <span class="hljs-keyword">public</span> ResultSet <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(String sql)</span> { ... }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> { ... }<br>}<br></code></pre></td></tr></tbody></table></figure><p>客户端只用一个类就能完成所有数据库操作。</p><hr><p><strong>模式扩展</strong></p><ol><li><p><strong>外观类可以有多个</strong>：按业务拆分多个 Facade，不必所有子系统都放在一个大外观中。</p></li><li><p><strong>不要在外观类中加入新业务</strong>：外观不是业务处理层，只是“调用协调器”。</p></li><li><p>可以引入 <strong>抽象外观类</strong></p><ul><li><p>使系统更遵守开闭原则。</p></li><li><p>可以在不改客户端代码的情况下替换外观类。</p></li></ul></li></ol><hr><blockquote><p>外观模式的本质：<strong>封装交互，简化调用</strong>。</p></blockquote><p>外观屏蔽了多个子系统之间的复杂交互，为客户端提供简单统一的 API。</p><h3 id="享元模式">享元模式</h3><p>围棋棋盘上：</p><ul><li>黑子：数百个</li><li>白子：数百个</li></ul><p>但其实：</p><ul><li>所有黑子 <strong>外观完全相同</strong></li><li>所有白子 <strong>外观完全相同</strong></li></ul><p>如果为每一个棋子都 <code>new</code> 一个对象：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">500</span>个黑子 + <span class="hljs-number">500</span>个白子 = <span class="hljs-number">1000</span>个对象<br></code></pre></td></tr></tbody></table></figure><p>这 1000 个对象内部保存的：</p><ul><li>颜色</li><li>形状</li><li>显示信息</li></ul><p>全部重复 → 浪费内存</p><p>但实际上：</p><blockquote><p>同一种颜色的棋子，只需要一个对象位置由外部记录</p></blockquote><p><strong>享元模式的本质：用“位置”等外部状态替代对象内部的重复信息</strong></p><h4 id="内部状态和外部状态">内部状态和外部状态</h4><ol><li><strong>内部状态</strong>（Intrinsic State）</li></ol><p>特点：</p><ul><li>不会因为环境变化而变化</li><li>可以共享</li><li>存储在享元对象内部</li></ul><p>比如：<br>围棋中的棋子颜色：黑 / 白<br>字符中的字母内容：<code>a</code>, <code>b</code>, <code>c</code></p><ol start="2"><li><strong>外部状态</strong>（Extrinsic State）</li></ol><p>特点：</p><ul><li>随环境变化</li><li>不可共享</li><li>由外部传入</li></ul><p>比如：<br>围棋中的位置：<code>(x, y)</code><br>字符的字体大小 / 颜色</p><hr><p><strong>相同内部状态的对象可以共享，同一个对象多次使用，不同的外部状态通过参数传入。</strong></p><hr><p><strong>抽象享元类</strong>：<code>ChessFlyweight</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessFlyweight</span> {<br>    <span class="hljs-keyword">protected</span> String color;  <span class="hljs-comment">// 内部状态：颜色</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessFlyweight</span><span class="hljs-params">(String color)</span> {<br>        <span class="hljs-built_in">this</span>.color = color;<br>    }<br><br>    <span class="hljs-comment">// 外部状态通过参数注入（位置）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体享元类</strong>：<code>BlackChess</code> 和 <code>WhiteChess</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackChess</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChessFlyweight</span> {<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlackChess</span><span class="hljs-params">()</span> {<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">"黑色"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> {<br>        System.out.println(<span class="hljs-string">"在位置 ("</span> + x + <span class="hljs-string">", "</span> + y + <span class="hljs-string">") 放置 "</span> + color + <span class="hljs-string">" 棋子"</span>);<br>    }<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WhiteChess</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChessFlyweight</span> {<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WhiteChess</span><span class="hljs-params">()</span> {<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">"白色"</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> {<br>        System.out.println(<span class="hljs-string">"在位置 ("</span> + x + <span class="hljs-string">", "</span> + y + <span class="hljs-string">") 放置 "</span> + color + <span class="hljs-string">" 棋子"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>享元工厂类</strong>：<code>ChessFlyweightFactory</code></p><p>这个是核心角色：<strong>享元池 + 管理创建</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessFlyweightFactory</span> {<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, ChessFlyweight&gt; pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChessFlyweight <span class="hljs-title function_">getChess</span><span class="hljs-params">(String color)</span> {<br>        <span class="hljs-type">ChessFlyweight</span> <span class="hljs-variable">chess</span> <span class="hljs-operator">=</span> pool.get(color);<br>        <span class="hljs-comment">// 从享元池里面取出对象</span><br>				<span class="hljs-comment">// 如果享元池里面不存在，那就创建一个</span><br>        <span class="hljs-keyword">if</span> (chess == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">if</span> (color.equals(<span class="hljs-string">"black"</span>)) {<br>                chess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackChess</span>();<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.equals(<span class="hljs-string">"white"</span>)) {<br>                chess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WhiteChess</span>();<br>            }<br>            pool.put(color, chess);<br>        }<br><br>        <span class="hljs-keyword">return</span> chess;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>客户端使用代码</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><br>        <span class="hljs-type">ChessFlyweight</span> <span class="hljs-variable">black1</span> <span class="hljs-operator">=</span> ChessFlyweightFactory.getChess(<span class="hljs-string">"black"</span>);<br>        black1.display(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">ChessFlyweight</span> <span class="hljs-variable">black2</span> <span class="hljs-operator">=</span> ChessFlyweightFactory.getChess(<span class="hljs-string">"black"</span>);<br>        black2.display(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-type">ChessFlyweight</span> <span class="hljs-variable">white1</span> <span class="hljs-operator">=</span> ChessFlyweightFactory.getChess(<span class="hljs-string">"white"</span>);<br>        white1.display(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br>        System.out.println(black1 == black2); <span class="hljs-comment">// true，共享</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>两个 <code>black</code> 实际只创建了一个对象，只是位置是外部传入：这就是享元。</p><h4 id="单纯享元模式">单纯享元模式</h4><p>特点：</p><ul><li>所有享元类都是共享的</li><li>没有非共享子类</li></ul><p>例子：围棋棋子、字符共享</p><p>最适合：大量重复、无个性变化的对象</p><h4 id="复合享元模式（结合组合模式）">复合享元模式（结合组合模式）</h4><p>比如：文本编辑器中的<strong>一段文字</strong>可以由多个字符组合而成，它们可以共用同一外部状态（字体、大小等）/</p><p>伪代码示意：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompositeFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyweight</span> {<br><br>    <span class="hljs-keyword">private</span> List&lt;Flyweight&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Flyweight f)</span> {<br>        children.add(f);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span> {<br>        <span class="hljs-keyword">for</span> (Flyweight f : children) {<br>            f.operation(extrinsicState);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>复合享元 = 享元 + 组合模式</p><h4 id="与工厂模式">与工厂模式</h4><p>大多数享元模式：</p><ul><li>一定要有工厂</li><li>工厂负责缓存对象</li></ul><p>典型结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Flyweight <span class="hljs-title function_">get</span><span class="hljs-params">(key)</span>;<br></code></pre></td></tr></tbody></table></figure><h4 id="与单例模式">与单例模式</h4><p>一般一个系统中：</p><blockquote><p>只需要一个享元工厂</p></blockquote><p>所以：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">FlyweightFactory</span> → 通常设计为单例<br></code></pre></td></tr></tbody></table></figure><h4 id="与组合模式">与组合模式</h4><p>在做“复合享元”时：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">多个Flyweight → 组成一个整体<br></code></pre></td></tr></tbody></table></figure><p>这个本质上就是：</p><blockquote><p>享元模式 + 组合模式</p></blockquote><h4 id="与装饰模式">与装饰模式</h4><table><thead><tr><th>模式</th><th>关注点</th></tr></thead><tbody><tr><td>享元</td><td>节省内存、共享对象</td></tr><tr><td>装饰</td><td>动态扩展功能</td></tr></tbody></table><p>享元是“<strong>减少对象数量</strong>”，装饰是“<strong>增强对象能力</strong>”。</p><hr><p><strong>适用条件</strong>：</p><blockquote><p><strong>对象多 + 内容像 + 可外部化 = 用享元</strong></p></blockquote><ul><li>大量对象</li><li>大量重复</li><li>大部分状态可外部化</li><li>多次重复使用同类对象</li></ul><hr><p>**享元模式核心目标：**把大量重复对象变成少量共享对象，用“外部状态”代替对象的“内部个性差异”。</p><h3 id="代理模式">代理模式</h3><ul><li><p>现实中的“代购”场景：你不能（或不想）直接访问国外商店，于是找代购网站代理你购买。</p></li><li><p>软件中：有时客户端“不想”或“不能”直接访问某个对象，<strong>需要第三者代理</strong>。</p></li></ul><p>例如：</p><ul><li>控制权限（保护代理）</li><li>控制对象生成（虚拟代理）</li><li>远程访问（远程代理）</li><li>访问额外行为（智能引用代理）</li><li>缓存结果（缓冲代理）</li></ul><hr><blockquote><p>代理模式（Proxy Pattern）：<strong>为某个对象提供一个代理，由代理控制对这个对象的访问</strong>。</p></blockquote><p>代理充当真实对象的替身，负责：</p><ul><li>转发调用</li><li>控制访问</li><li>附加附加功能（延迟加载、缓存、权限检查等）</li></ul><hr><p><strong>模式结构与角色</strong></p><ol><li><p><strong>Subject</strong> <strong>抽象主题</strong>：真实对象和代理对象的共同接口。</p></li><li><p><strong>RealSubject</strong> <strong>真实主题</strong>：真正干活的对象。</p></li><li><p><strong>Proxy</strong> <strong>代理类</strong></p><ul><li><p>维护 RealSubject 的引用</p></li><li><p>控制访问</p></li><li><p>调用前后加入新的行为</p></li></ul></li></ol><p><img src="https://images.kisechan.space/20251120104441427.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>模式示例</strong></p><ol><li><strong>抽象主题</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>真实主题</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 真实业务逻辑</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>代理类</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> <span class="hljs-variable">real</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> {<br>        preRequest();<br>        real.request();<br>        postRequest();<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preRequest</span><span class="hljs-params">()</span> { }<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postRequest</span><span class="hljs-params">()</span> { }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>代理模式分类 &amp; 适用场景</strong></p><table><thead><tr><th>代理类型</th><th>作用</th></tr></thead><tbody><tr><td><strong>远程代理</strong></td><td>跨网络访问对象（RMI、WebService）</td></tr><tr><td><strong>虚拟代理</strong></td><td>延迟创建开销大的对象，如大图片、大文档</td></tr><tr><td><strong>保护代理</strong></td><td>控制权限，用户权限不一样</td></tr><tr><td><strong>缓冲代理</strong></td><td>保存结果，减少重复计算</td></tr><tr><td><strong>智能引用代理</strong></td><td>调用计数、自动加锁等</td></tr><tr><td><strong>防火墙代理</strong></td><td>阻止不安全访问</td></tr><tr><td><strong>同步代理</strong></td><td>多线程环境下控制访问</td></tr><tr><td><strong>写时复制代理</strong></td><td>Copy-on-write</td></tr></tbody></table><hr><p><strong>优点</strong></p><ul><li>解耦客户端与真实对象</li><li>代理可增强功能</li><li>可扩展性强（符合开闭原则）</li></ul><p><strong>缺点</strong></p><ul><li>多了一层调用，可能降低性能</li><li>某些代理复杂度较高（如动态代理）</li></ul><h4 id="动态代理">动态代理</h4><p>相对于静态代理，动态代理更灵活：</p><ul><li>不需要为每个 RealSubject 写一个代理类</li><li>运行时自动生成</li></ul><p>基于两个核心类：</p><ul><li><code>InvocationHandler</code></li><li><code>Proxy.newProxyInstance()</code></li></ul><p>例如 Spring AOP 的实现原理。</p><hr><blockquote><p>代理模式的本质：<strong>控制对象访问</strong>（添加间接层）。</p></blockquote><p>代理插入在客户端与目标对象之间，从而：</p><ul><li>控制访问（权限）</li><li>改善性能（缓存、延迟加载）</li><li>添加功能（日志、统计、事务）</li></ul><h2 id="行为型模式">行为型模式</h2><p>行为型模式关注的是：</p><ul><li><strong>对象之间如何分配职责</strong></li><li><strong>对象之间如何交互</strong></li><li><strong>运行时对象如何协作完成任务</strong></li></ul><p>分为两大类：</p><table><thead><tr><th>类型</th><th>特征</th></tr></thead><tbody><tr><td><strong>类行为型模式</strong></td><td>通过 <em>继承</em> 分配行为，父类与子类之间职责分配</td></tr><tr><td><strong>对象行为型模式</strong></td><td>通过 <em>对象关联（组合）</em> 分配行为，更符合合成复用原则，大部分行为模式属于此类</td></tr></tbody></table><p>常见行为型模式包括：</p><ul><li>职责链</li><li>中介者</li><li>命令</li><li>观察者</li><li>策略</li><li>状态</li><li>解释器</li><li>迭代器</li><li>访问者</li><li>模板方法</li><li>备忘录</li></ul><h3 id="职责链模式">职责链模式</h3><p>现实中的“链式处理”场景：</p><ul><li>斗地主：出牌→下家→下下家→…直到有人要得起</li><li>请假审批：辅导员 → 系主任 → 院长 → 校长</li><li>异常捕获：子类异常 → 父类异常 → Throwable</li></ul><p>这些共同特点：</p><ul><li><strong>请求会沿着一条链依次传递</strong></li><li><strong>每个节点可以处理，也可以继续往下传</strong></li><li><strong>客户端不关心最终由谁来处理</strong></li></ul><p>职责链模式就是对这种结构的抽象。</p><hr><blockquote><p>**职责链模式（Chain of Responsibility）**让多个对象都有机会处理请求，将这些处理对象连接成一条链，并沿着链传递请求，直到某个对象处理为止。</p><p>——属于对象行为型模式。</p></blockquote><p>关键点：</p><ul><li>发送者 → 不知道 → 最终处理者是谁</li><li>处理者 → 只知道 → 自己的“下家”是谁</li><li>链可以动态组合</li></ul><hr><p><strong>角色</strong></p><table><thead><tr><th>角色</th><th>职责</th></tr></thead><tbody><tr><td><strong>Handler</strong>（抽象处理者）</td><td>定义处理接口；保存 <code>successor</code>（下家）引用</td></tr><tr><td><strong>ConcreteHandler</strong></td><td>实现处理逻辑；决定是否处理或转发</td></tr><tr><td><strong>Client</strong></td><td>负责创建链并发起请求</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251120112503279.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>典型代码</strong></p><ol><li><strong>抽象处理者：</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> {<br>    <span class="hljs-keyword">protected</span> Handler successor;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> {<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>具体处理者：</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> {<br>        <span class="hljs-keyword">if</span> (day &lt; <span class="hljs-number">3</span>) {<br>            System.out.println(<span class="hljs-string">"Manager approves"</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) {<br>            successor.handleRequest(day);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>Client 组织链：</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br><span class="hljs-type">Handler</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>();<br><span class="hljs-type">Handler</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CEO</span>();<br><br>a.setSuccessor(b);<br>b.setSuccessor(c);<br><br>a.handleRequest(<span class="hljs-number">10</span>);<br></code></pre></td></tr></tbody></table></figure><p>模式实例：<strong>请假审批</strong></p><table><thead><tr><th>请假天数</th><th>审批人</th></tr></thead><tbody><tr><td>&lt;3</td><td>主任</td></tr><tr><td>3~9</td><td>经理</td></tr><tr><td>10~29</td><td>总经理</td></tr><tr><td>≥30</td><td>不批准</td></tr></tbody></table><p>请求沿链依次传递——典型的职责链模式。</p><p><strong>优点</strong></p><ul><li><strong>降低耦合度</strong>：发送者不关心处理者是谁</li><li><strong>动态组合职责链</strong>：可以在运行时调整处理顺序</li><li><strong>符合开闭原则</strong>：新增处理者无需修改旧代码</li></ul><p><strong>缺点</strong></p><ul><li><strong>可能没人处理请求</strong></li><li><strong>调试困难</strong>（链很长时不易定位）</li><li><strong>链配置不当可能导致循环</strong></li></ul><p><strong>适用场景</strong></p><ul><li>多个对象都可能处理请求，但具体由谁处理未知</li><li>希望“职责可变”，可以动态组合处理链</li><li>请求处理逻辑以“逐级过滤”的方式出现<br>e.g. Web Filter Chain</li></ul><p><strong>模式扩展</strong></p><ol><li><p><strong>纯职责链</strong></p><ul><li><p>每个处理者 <strong>要么处理，要么向下传递</strong></p></li><li><p>请求一定被处理</p></li></ul></li><li><p><strong>不纯职责链</strong>（更常见）</p><ul><li><p>处理者可以部分处理再往下传</p></li><li><p>请求可被多个处理者处理</p></li><li><p>请求可能没人处理（JavaScript 事件冒泡）</p></li></ul></li></ol><hr><blockquote><p>职责链模式本质：<strong>分离职责、动态组合处理流程</strong></p></blockquote><h3 id="中介者模式">中介者模式</h3><p>现实类比：</p><ul><li>QQ 群 → 群负责群成员之间消息的转发与协调</li><li>机场塔台 → 管理所有飞机起降调度</li><li>GUI 中控（Dialog 中控按钮、列表框等互相影响）</li></ul><p>这些场景共同特点：</p><ul><li><strong>对象之间存在非常复杂的多对多关系</strong></li><li>如果对象互相直接引用，则耦合极高</li><li>修改一个对象会牵连整个系统</li></ul><p>解决方式：</p><p>引入一个<strong>中介者</strong>（Mediator）</p><ul><li>将对象之间的交互逻辑统一封装</li><li>同事对象不再直接相互引用</li></ul><hr><blockquote><p><strong>中介者模式（Mediator）</strong>：用一个中介对象来封装一系列对象交互，使对象不需要显式地相互引用，从而使其耦合松散，交互集中管理。<br>——属于对象行为型模式。</p></blockquote><p>核心思想：</p><ul><li>多对多 → 转换为 → 一对多</li><li>交互逻辑全部交给中介者处理</li></ul><hr><table><thead><tr><th>角色</th><th>职责</th></tr></thead><tbody><tr><td><strong>Mediator（抽象中介者）</strong></td><td>定义交互接口；提供同事注册方法</td></tr><tr><td><strong>ConcreteMediator</strong></td><td>实现具体协调逻辑；维护同事引用</td></tr><tr><td><strong>Colleague（同事抽象类）</strong></td><td>持有中介者引用；定义自身行为</td></tr><tr><td><strong>ConcreteColleague</strong></td><td>实现同事行为，通过中介者与其他同事通信</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251120112729183.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>典型代码</strong></p><ol><li><strong>抽象中介者：</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Colleague c)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(Colleague sender, String msg)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>具体中介者：</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> {<br>    <span class="hljs-keyword">private</span> List&lt;Colleague&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Colleague c)</span> {<br>        list.add(c);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(Colleague sender, String msg)</span> {<br>        <span class="hljs-keyword">for</span> (Colleague c : list) {<br>            <span class="hljs-keyword">if</span> (c != sender) {<br>                c.receive(msg);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>同事类：</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> {<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span> { <span class="hljs-built_in">this</span>.mediator = mediator; }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> { mediator.operation(<span class="hljs-built_in">this</span>, msg); }<br>}<br></code></pre></td></tr></tbody></table></figure><p>模式实例：<strong>聊天室</strong></p><ul><li>群主（Mediator）负责消息广播</li><li>群成员（Colleague）只与群主交互，不直接找其他成员</li></ul><p>发送消息代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">member1.send(<span class="hljs-string">"hello"</span>);<br></code></pre></td></tr></tbody></table></figure><p>群主转给其他所有人。</p><hr><p><strong>优点</strong></p><ul><li><strong>彻底降低同事对象之间耦合</strong></li><li><strong>同事对象更易复用</strong></li><li><strong>交互逻辑集中管理，易修改、易扩展</strong></li></ul><p><strong>缺点</strong></p><ul><li><strong>中介者过度膨胀（复杂度转移）</strong><br>越多的交互越集中，中介者可能成为“上帝类”</li></ul><hr><p><strong>适用场景</strong></p><ul><li>多个对象之间存在复杂的引用关系和交互</li><li>GUI 组件之间联动（按钮、列表框、文本框）</li><li>聊天室、消息系统</li><li>MVC 模式中的 <code>Controller</code>（典型中介者）</li></ul><h4 id="与外观模式的比较">与外观模式的比较</h4><table><thead><tr><th>模式</th><th>作用</th><th>交互方向</th><th>应用位置</th></tr></thead><tbody><tr><td><strong>中介者模式</strong></td><td>封装对象<strong>内部</strong>交互</td><td>多向</td><td>同层对象之间（内部）</td></tr><tr><td><strong>外观模式</strong></td><td>简化子系统对外接口</td><td>单向</td><td>系统外部调用系统内部</td></tr></tbody></table><p>一句话总结：<strong>外观是外部调用内部；中介者是内部之间交互。</strong></p><hr><blockquote><p>中介者本质：封装交互，<strong>把网状结构变为星形结构</strong>。</p></blockquote><h3 id="命令模式">命令模式</h3><p>命令模式可看作 “<strong>把一个请求变成一个对象</strong>”。</p><p>现实类比 —— <strong>开关控制电器</strong></p><ul><li>“开关” 是 <strong>请求发送者</strong></li><li>“电灯” 是 <strong>请求接收者</strong></li><li>“电线” 是 <strong>命令对象</strong></li></ul><p>关键点：</p><blockquote><p><strong>开关并不知道要控制什么电器，只负责发送“开/关”的动作；真正执行逻辑由电器完成。</strong></p></blockquote><p>这就是 <strong>解耦发送者与接收者</strong>，使得发送者不关心接收者的类型和逻辑。</p><p>软件类比：</p><ul><li>GUI按钮（Invoker）</li><li>点击处理函数（Command）</li><li>实际业务处理类（Receiver）</li></ul><hr><blockquote><p>命令模式<strong>将一个请求封装为一个对象，因此可以对请求排队、记录日志、撤销、组合等</strong>。</p></blockquote><p>命令 = 对接收者执行某种操作的 “对象化表示”。</p><p>角色职责：</p><ul><li><strong>Command</strong>：抽象命令，声明 <code>execute()</code></li><li><strong>ConcreteCommand</strong>：具体命令，包装了 Receiver</li><li><strong>Receiver</strong>：执行真正的业务逻辑</li><li><strong>Invoker</strong>：请求发送者，通过 Command 调用 Receiver</li></ul><p><img src="https://images.kisechan.space/20251120153648003.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p>命令模式的关键点在于：</p><ol><li><p><strong>把“行为”对象化</strong>，请求从“函数调用”变成独立对象 → 可以存储、传递、排队。</p></li><li><p><strong>彻底解耦发送者与接收者</strong>，Invoker 不知道 Receiver 的存在，只认识 Command。</p></li><li><p>能支持以下功能：</p><ul><li><p>请求队列（批处理）</p></li><li><p>请求日志（恢复/重放）</p></li><li><p>撤销（Undo）</p></li><li><p>重做（Redo）</p></li><li><p>宏命令（组合命令）</p></li></ul></li></ol><p>且命令模式真正厉害的地方在于扩展性，而不仅是结构：</p><h4 id="命令队列（多命令批处理）">命令队列（多命令批处理）</h4><p>将多个命令对象存入队列：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandQueue</span> {  <br>    <span class="hljs-comment">//定义一个ArrayList来存储命令队列  </span><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Command&gt; commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Command&gt;();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCommand</span><span class="hljs-params">(Command command)</span> {  commands.add(command);   }  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeCommand</span><span class="hljs-params">(Command command)</span> {  commands.remove(command);  }  <br>    <span class="hljs-comment">//循环调用每一个命令对象的execute()方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> {  <br>        <span class="hljs-keyword">for</span> (Object command : commands) {  <br>            ((Command)command).execute();  <br>        }  <br>    }  <br>} <br></code></pre></td></tr></tbody></table></figure><pre><code class="mermaid">flowchart LR
Invoker --&gt; CommandQueue --&gt;|execute| SeveralCommands
</code></pre><p>作用：</p><ul><li>批量执行</li><li>顺序执行或并发执行</li><li>常用于调度器、批任务系统</li></ul><h4 id="请求日志">请求日志</h4><p>保存“命令对象”而不是“执行结果”，在系统重启后可以 <strong>重放操作</strong>。</p><p>典型应用：</p><ul><li>数据库日志</li><li>配置文件增删改日志</li><li>文件操作日志</li></ul><h4 id="撤销">撤销</h4><p>两种方式：</p><ol><li><strong>命令类提供反向操作</strong>（<code>reverse</code>/<code>undo</code>）</li><li><strong>通过保存执行前的状态</strong>（借助备忘录模式）</li></ol><p>第二种是命令模式 + 备忘录模式的联用。</p><h4 id="宏命令">宏命令</h4><p>命令模式 + 组合模式：一个命令包含多个命令，可以多层嵌套。</p><p>常见应用：</p><ul><li>Shell 脚本</li><li>VS Code “组命令”</li><li>关键帧动画：一个宏命令 = 多个简单命令</li></ul><hr><p>实例：<strong>电视遥控器</strong></p><ul><li>Button → Invoker</li><li>OpenTVCommand → ConcreteCommand</li><li>TV → Receiver</li></ul><p>一个按钮可以绑定为任意行为 → 解耦。</p><hr><p>实例：<strong>功能键定义</strong></p><p>FunctionButton 是 Invoker<br>用户可以通过配置文件修改功能：</p><p>功能 A → exit<br>功能 B → help<br>功能 C → save</p><p>无需改变按钮代码，只改变配置文件 → 非常灵活。</p><hr><p><strong>优点</strong></p><ul><li>极强的扩展性（新命令类不影响已有代码）</li><li>彻底解耦请求者/接收者</li><li>内建支持撤销、队列、日志等复杂操作</li><li>宏命令功能强大</li></ul><p><strong>缺点</strong></p><ul><li>会生成大量命令类（类爆炸）</li></ul><hr><p><strong>模式适用场景</strong></p><ul><li>需要撤销</li><li>需要日志</li><li>需要排队</li><li>GUI 中按钮/菜单/快捷键绑定</li><li>宏命令</li><li>事务模型（正向调用 → 反向撤销）</li></ul><hr><p>命令模式的本质：</p><blockquote><p><strong>对请求进行封装，使行为对象化。</strong></p></blockquote><h3 id="备忘录模式">备忘录模式</h3><p>备忘录模式要解决的是：</p><blockquote><p><strong>在不暴露对象内部结构的前提下，保存和恢复对象的内部状态。</strong></p></blockquote><p>这是“复杂撤销”的基础设施。</p><p>现实类比 —— <kbd>Ctrl</kbd> + <kbd>Z</kbd></p><ul><li>用户误操作</li><li>软件需要回到 <strong>之前的某个状态</strong></li></ul><p>百分之百依赖 <strong>状态保存</strong>。</p><hr><blockquote><p>备忘录模式<strong>保存对象在某一时刻的状态，使其可以恢复</strong>。</p></blockquote><p>关键词：</p><ul><li>不破坏封装</li><li>保存状态</li><li>恢复状态</li></ul><hr><p><img src="https://images.kisechan.space/20251120154459358.png" srcset="/img/loading.gif" lazyload alt=""></p><p>角色：</p><ul><li><strong>Originator</strong>：有状态，要被恢复的对象</li><li><strong>Memento</strong>：保存状态</li><li><strong>Caretaker</strong>：管理备忘录（但不能修改）</li></ul><hr><p>备忘录模式的关键点是 <strong>封装性必须强</strong>：</p><ul><li>外界不能修改备忘录</li><li>只有 Originator 才能读写备忘录</li></ul><p>Java 通过：包级可见性 / 内部类实现隐藏。</p><p>C++ 可通过 <code>friend</code>。</p><hr><p><strong>缺点</strong>：</p><ul><li><strong>大状态 = 大内存消耗</strong></li><li>频繁快照非常昂贵</li></ul><p>这就是为什么编辑器的撤销次数一般有限。</p><h4 id="多次撤销-重做">多次撤销 &amp; 重做</h4><p>策略：</p><ul><li><code>Caretaker</code> 维护一个栈或列表</li><li><code>undo</code>：向后取一个备忘录</li><li><code>redo</code>：向前取一个备忘录</li></ul><p><img src="https://images.kisechan.space/20251120154619657.png" srcset="/img/loading.gif" lazyload alt=""></p><pre><code class="mermaid">sequenceDiagram
    participant Originator
    participant Caretaker

    Originator-&gt;&gt;Caretaker: save m1
    Originator-&gt;&gt;Caretaker: save m2
    Caretaker-&gt;&gt;Originator: restore m1 (undo)
    Caretaker-&gt;&gt;Originator: restore m2 (redo)
</code></pre><h4 id="与命令模式的联动">与命令模式的联动</h4><p>命令模式负责 <strong>动作</strong>，备忘录模式负责 <strong>保存状态</strong>。</p><p>两者可组合成强力撤销系统：</p><ul><li>执行命令前：生成 <code>Memento</code></li><li>撤销时：<code>restoreMemento()</code></li></ul><h4 id="与原型模式的结合">与原型模式的结合</h4><p>Originator 可以直接 <code>clone()</code>，这个 <code>clone</code> 就作为备忘录对象保存。</p><p>适合“全部状态都需要存储”的系统。</p><hr><p>备忘录模式的本质：</p><blockquote><p><strong>保存和恢复内部状态</strong>（<strong>不破坏封装</strong>）。</p></blockquote><h4 id="命令模式和备忘录模式的对比">命令模式和备忘录模式的对比</h4><table><thead><tr><th>特征</th><th>命令模式</th><th>备忘录模式</th></tr></thead><tbody><tr><td>目的</td><td>封装行为/请求</td><td>保存状态以恢复</td></tr><tr><td>支持撤销？</td><td>需配合备忘录</td><td>是撤销的基础设施</td></tr><tr><td>本质</td><td>行为对象化</td><td>状态对象化</td></tr><tr><td>主要用于</td><td>GUI、事务、队列、宏命令</td><td>编辑器撤销、游戏回合、数据库回滚</td></tr><tr><td>是否解耦</td><td>解耦发送者/接收者</td><td>不破坏封装，状态安全</td></tr></tbody></table><p>组合使用效果最佳：</p><ul><li>命令 → 执行/撤销</li><li>备忘录 → 保存状态</li></ul><h3 id="迭代器模式">迭代器模式</h3><p><strong>核心矛盾：</strong></p><blockquote><p>一个类既要负责<strong>存储数据</strong>，又要负责<strong>遍历数据</strong>，会导致职责混乱、扩展困难。</p></blockquote><p>比如：</p><ul><li>一个 <code>TV</code> 类既存频道，又提供 <code>nextChannel()</code>、<code>prevChannel()</code>、<code>randomChannel()</code> 等遍历方式。</li><li>如果以后要加“按频道类型遍历”？你就要改 <code>TV</code> 类。</li></ul><p>这违反了：<strong>单一职责原则</strong>和<strong>开闭原则</strong></p><p>因此我们：</p><blockquote><p>把“遍历行为”从“存储类”中剥离出来，由一个独立的对象负责 —— 迭代器。</p></blockquote><p>就像：</p><ul><li>电视：只负责存频道</li><li>遥控器：负责访问和切换频道</li></ul><hr><blockquote><p>迭代器模式：<strong>提供一种统一的方式访问聚合对象内部元素，而不暴露其内部结构</strong>。</p></blockquote><p>关键词记住三点：</p><ul><li>不暴露内部结构</li><li>顺序访问</li><li>职责分离</li></ul><hr><table><thead><tr><th>角色</th><th>职责</th></tr></thead><tbody><tr><td>Iterator</td><td>定义遍历接口</td></tr><tr><td>ConcreteIterator</td><td>实现具体遍历逻辑</td></tr><tr><td>Aggregate</td><td>抽象聚合类，负责创建迭代器</td></tr><tr><td>ConcreteAggregate</td><td>具体聚合对象</td></tr></tbody></table><figure class="highlight brainfuck"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">客户端</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">迭代器</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">聚合对象</span><br></code></pre></td></tr></tbody></table></figure><p>迭代器内部持有聚合对象的引用。</p><p><img src="https://images.kisechan.space/20251121163400638.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>抽象迭代器</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>抽象聚合</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> {<br>    Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体实现关系</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> {<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; elements;<br><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);<br>    }<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>        <span class="hljs-keyword">return</span> elements.get(index);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> elements.size();<br>    }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> {<br>    <span class="hljs-keyword">private</span> ConcreteAggregate aggregate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> {<br>        cursor = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {<br>        cursor++;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> cursor &lt; aggregate.size();<br>    }<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> aggregate.get(cursor);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>优点</strong>：</p><ol><li>分离集合与遍历逻辑</li><li>支持多种遍历策略</li><li>符合开闭原则</li><li>统一访问方式</li></ol><p><strong>缺点</strong>：</p><ol><li>类数量增加</li><li>抽象设计难度较高</li><li>有些情况下性能略有损耗</li></ol><h4 id="内部与外部迭代器">内部与外部迭代器</h4><table><thead><tr><th>比较</th><th>外部迭代器</th><th>内部迭代器</th></tr></thead><tbody><tr><td>控制权</td><td>客户端控制</td><td>迭代器控制</td></tr><tr><td>方式</td><td>手动调用 <code>next()</code></td><td>传回调函数</td></tr><tr><td>例子</td><td><code>Iterator</code></td><td><code>forEach</code> / <code>Stream</code></td></tr></tbody></table><blockquote><p>外部是“你走路”，内部是“它推你走”。</p></blockquote><hr><p>迭代器模式的本质：<strong>控制对聚合对象内部元素的访问</strong>。</p><h3 id="观察者模式">观察者模式</h3><blockquote><p>当一个对象发生改变时，如何让所有依赖它的对象自动更新？</p></blockquote><p>比如：</p><ul><li>股票价格变化 → 各个股票 App 显示更新</li><li>老师出成绩 → 所有学生收到通知</li><li>游戏中 Boss 状态变化 → UI、音效、队友同步反馈</li></ul><hr><blockquote><p><strong>定义对象间的一种一对多依赖关系，使得当一个对象状态改变时，所有依赖它的对象都会收到通知并更新。</strong></p></blockquote><p>别名：</p><ul><li>发布-订阅模式</li><li>事件监听模式</li></ul><hr><p>观察者模式的角色：</p><table><thead><tr><th>角色</th><th>职责</th></tr></thead><tbody><tr><td>Subject</td><td>被观察目标</td></tr><tr><td>ConcreteSubject</td><td>具体目标</td></tr><tr><td>Observer</td><td>抽象观察者</td></tr><tr><td>ConcreteObserver</td><td>具体观察者</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251121163603487.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>抽象目标类</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {<br>    <span class="hljs-keyword">protected</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer obs)</span> {<br>        observers.add(obs);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer obs)</span> {<br>        observers.remove(obs);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>抽象观察者</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体目标类</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> {<br>        <span class="hljs-built_in">this</span>.state = state;<br>        notifyObservers();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> state;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">for</span>(Observer obs : observers) {<br>            obs.update();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>具体观察者</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> {<br>    <span class="hljs-keyword">private</span> ConcreteSubject subject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteObserver</span><span class="hljs-params">(ConcreteSubject subject)</span> {<br>        <span class="hljs-built_in">this</span>.subject = subject;<br>        subject.attach(<span class="hljs-built_in">this</span>);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"状态更新为："</span> + subject.getState());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>优点</strong>：</p><ol><li>解耦目标与观察者</li><li>支持动态联动</li><li>支持广播机制</li><li>符合开闭原则</li></ol><p><strong>缺点</strong>：</p><ol><li>多级联动可能导致级联问题</li><li>可能出现死循环（互相观察）</li><li>广播效率问题（观察者多时）</li></ol><hr><p>典型应用场景：</p><table><thead><tr><th>场景</th><th>模式</th></tr></thead><tbody><tr><td>GUI事件</td><td><code>MouseListener</code> / <code>ActionListener</code></td></tr><tr><td>AWT/Swing事件</td><td>事件监听模型</td></tr><tr><td>MVC架构</td><td>Model ← View</td></tr></tbody></table><p>观察者模式的本质：</p><ol><li><strong>建立动态的一对多联动机制</strong></li><li><strong>由目标对象的状态变化触发</strong></li><li><strong>通知所有依赖它的对象执行响应</strong></li></ol><h3 id="状态模式">状态模式</h3><p>对象在不同状态下，<strong>行为不同</strong>，而且状态之间<strong>会发生转换</strong>。</p><p>如果用 <code>if-else</code> 或 <code>switch-case</code> 写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (state == NEWBIE) {...}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == MASTER) {...}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == EXPERT) {...}<br></code></pre></td></tr></tbody></table></figure><p>一旦状态和行为增多，这个类就会爆炸、难维护。</p><p>状态模式的目的就是：把**“状态 + 状态下的行为”**抽出来，交给不同类管理。</p><hr><p><strong>角色结构如下</strong>：</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Context（环境类）</td><td>拥有状态的对象</td></tr><tr><td>State（抽象状态类）</td><td>统一定义不同状态的行为接口</td></tr><tr><td>ConcreteState（具体状态类）</td><td>每个状态一个类，封装该状态的行为</td></tr></tbody></table><p><img src="https://images.kisechan.space/20251121164751972.png" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="状态转换的两种方式">状态转换的两种方式</h4><ol><li><p><strong>由 <code>Context</code> 负责切换</strong></p><ul><li><p>状态管理集中</p></li><li><p><code>State</code> 类“纯粹”，只做行为</p></li></ul></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeState</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">this</span>.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StateA</span>());<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">this</span>.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StateB</span>());<br>}<br></code></pre></td></tr></tbody></table></figure><p>特点：</p><ul><li>状态类简洁</li><li><code>Context</code> 会逐渐变复杂（状态过多）</li></ul><ol start="2"><li><strong>由 <code>State</code> 自己控制切换</strong><ul><li>每个状态知道自己“该何去何从”</li></ul></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context ctx)</span> {<br>    <span class="hljs-keyword">if</span> (ctx.getValue() &gt; <span class="hljs-number">100</span>) {<br>        ctx.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpertState</span>());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>特点：</p><ul><li>符合“对象自治”</li><li>状态类与 <code>Context</code> 强耦合</li></ul><h4 id="共享状态">共享状态</h4><p>多个对象共享一个状态对象（类似单例）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ConcreteStateA</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>好处是：减少对象创建开销。</p><h4 id="简单状态模式和可切换状态模式">简单状态模式和可切换状态模式</h4><table><thead><tr><th>比较维度</th><th>简单状态模式</th><th>可切换状态模式</th></tr></thead><tbody><tr><td>是否状态转换</td><td>没有</td><td>有</td></tr><tr><td>状态类是否知道 <code>Context</code></td><td>不需要</td><td>通常需要</td></tr><tr><td>是否符合开闭原则</td><td>比较好</td><td>新状态通常要改旧代码</td></tr><tr><td>典型场景</td><td>客户端指定状态</td><td>系统运行中自动切换</td></tr></tbody></table><h4 id="状态模式和观察者模式">状态模式和观察者模式</h4><table><thead><tr><th>对比点</th><th>状态模式</th><th>观察者模式</th></tr></thead><tbody><tr><td>触发时机</td><td>状态变化</td><td>状态变化</td></tr><tr><td>触发的行为</td><td>根据状态不同选择行为</td><td>通知订阅者</td></tr><tr><td>行为固定？</td><td>不固定</td><td>固定（通知）</td></tr><tr><td>本质区别</td><td>状态决定行为</td><td>变化通知外部</td></tr></tbody></table><hr><blockquote><p>状态模式的本质：<strong>根据状态封装行为，根据状态切换决策行为。</strong></p></blockquote><p>核心思想： “把不同状态的行为隔离到不同的类中”。</p><h3 id="策略模式">策略模式</h3><ul><li><p>出行策略：步行 / 汽车 / 火车 / 飞机</p></li><li><p>排序策略：冒泡 / 选择 / 插入</p></li></ul><p>它的关键词只有一个：<strong>多种算法，可相互替换</strong>。</p><p>和状态模式不同：策略模式关注的是**“算法不同”**，而不是“状态变化”。</p><hr><p><strong>三大角色</strong></p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Context</td><td>使用算法的类</td></tr><tr><td>Strategy</td><td>抽象策略</td></tr><tr><td>ConcreteStrategy</td><td>具体策略实现</td></tr></tbody></table><p><strong>代码模型</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">()</span>;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">()</span> { ... }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> {<br>    <span class="hljs-keyword">private</span> Strategy strategy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy strategy)</span> {<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> {<br>        strategy.algorithm();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://images.kisechan.space/20251121165212124.png" srcset="/img/loading.gif" lazyload alt=""></p><hr><p><strong>策略模式的真正价值</strong>：</p><ul><li>消灭 if-else</li><li>支持运行时切换</li><li>算法解耦</li></ul><h4 id="策略模式和状态模式">策略模式和状态模式</h4><table><thead><tr><th>对比维度</th><th>策略模式</th><th>状态模式</th></tr></thead><tbody><tr><td>关注点</td><td>算法选择</td><td>状态变化</td></tr><tr><td>是否自动切换</td><td>客户端切换</td><td>状态内部管理</td></tr><tr><td>是否关心上下文</td><td>不关心 <code>Context</code></td><td>常需要 <code>Context</code></td></tr><tr><td>状态是否互斥</td><td>可以多个策略并存</td><td>状态是排他的</td></tr><tr><td>本质不同</td><td>算法可替换</td><td>行为随状态变</td></tr></tbody></table><ul><li>策略 = 做什么方式</li><li>状态 = 处于什么阶段</li></ul><p><strong>策略是“换做法”，状态是“变身份”。</strong></p><h4 id="策略模式和命令模式-sup-id-fnref-1-class-footnote-ref-a-href-fn-1-rel-footnote-span-class-hint-top-hint-rounded-aria-label-https-github-com-ChenGeng0102-JLU-blob-main-E5-A4-A7-E4-B8-89-E4-B8-8A-E8-BD-AF-E4-BB-B6-E8-AE-BE-E8-AE-A1-E6-A8-A1-E5-BC-8F-E6-9C-9F-E6-9C-AB-E7-AC-94-E8-AE-B0-EF-BC-88-E8-80-83-E5-9C-BA-E7-89-88-EF-BC-89-E8-AE-BE-E8-AE-A1-E6-A8-A1-E5-BC-8F-E3-80-90-E6-96-87-E4-BB-B6A-E3-80-91-pdf-1-span-a-sup">策略模式和命令模式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/ChenGeng0102/JLU/blob/main/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%EF%BC%88%E8%80%83%E5%9C%BA%E7%89%88%EF%BC%89/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%90%E6%96%87%E4%BB%B6A%E3%80%91.pdf">[1]</span></a></sup></h4><p>命令模式和策略模式的类图确实很相似，只是命令模式多了一个<strong>接收者</strong>（Receiver）角色。它们虽然同为行为类模式，但是两者的区别还是很明显的。</p><p>策略模式的意图是封装算法，它认为“算法”已经是一个完整的、不可拆分的原子业务（注意这里是原子业务，而不是原子对象），即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象（接收者角色）、执行行为（命令角色），让两者相互独立而不相互影响。</p><ol><li><strong>关注点不同</strong><ul><li>策略模式关注的是算法替换的问题，一个新的算法投产，旧算法退休，或者提供多种算法由调用者自<br>己选择使用，算法的自由更替是它实现的要点。换句话说，策略模式关注的是算法的完整性、封装<br>性，只有具备了这两个条件才能保证其可以自由切换。</li><li>命令模式则关注的是解耦问题，如何让请求者和执行者解耦是它需要首先解决的，解耦的要求就是把<br>请求的内容封装为一个一个的命令，由接收者执行。由于封装成了命令，就同时可以对命令进行多种<br>处理，例如撤销、记录等。</li></ul></li><li>角色功能不同<ul><li>在我们的例子中，策略模式中的抽象算法和具体算法与命令模式的接收者非常相似，但是它们的职责<br>不同。策略模式中的具体算法是负责一个完整算法逻辑，它是不可再拆分的原子业务单元，一旦变更<br>就是对算法整体的变更。</li><li>而命令模式则不同，它关注命令的实现，也就是功能的实现。例如我们在分支中也提到接收者的变更<br>问题，它只影响到命令族的变更，对请求者没有任何影响，从这方面来说，接收者对命令负责，而与<br>请求者无关。命令模式中的接收者只要符合六大设计原则，完全不用关心它是否完成了一个具体逻<br>辑，它的影响范围也仅仅是抽象命令和具体命令，对它的修改不会扩散到模式外的模块。</li><li>当然，如果在命令模式中需要指定接收者，则需要考虑接收者的变化和封装，例如一个老顾客每次吃<br>饭都点同一个厨师的饭菜，那就必须考虑接收者的抽象化问题。</li></ul></li><li>使用场景不同<ul><li>策略模式适用于算法要求变换的场景，而命令模式适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景。</li></ul></li></ol><h3 id="模板方法模式">模板方法模式</h3><p>有些步骤是固定的，有些步骤是变化的。</p><p>固定的：</p><ul><li>点单</li><li>买单</li></ul><p>变化的：</p><ul><li>吃什么</li></ul><hr><p>模板方法模式的结构是最简单的行为模式之一：</p><p><img src="https://images.kisechan.space/20251121165346083.png" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dining</span> {<br>    <span class="hljs-comment">// 模板方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> {<br>        order();<br>        doEat();  <span class="hljs-comment">// 抽象</span><br>        pay();<br>    }<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"点单"</span>);<br>    }<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEat</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"买单"</span>);<br>    }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EatNoodles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dining</span> {<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEat</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"吃面条"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>几个重点概念</strong>：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>模板方法</td><td>定义整个流程骨架</td></tr><tr><td>基本方法</td><td>流程中具体步骤</td></tr><tr><td>钩子方法（可选）</td><td>子类可选择覆盖或不覆盖</td></tr></tbody></table><p>模板方法通常用 <code>final</code> 修饰，防止子类篡改流程。</p><h4 id="模板方法和策略模式">模板方法和策略模式</h4><table><thead><tr><th>维度</th><th>模板方法</th><th>策略模式</th></tr></thead><tbody><tr><td>技术手段</td><td>继承</td><td>组合</td></tr><tr><td>改变行为方式</td><td>子类重写方法</td><td>注入不同策略</td></tr><tr><td>编译期/运行期</td><td>编译期固定结构</td><td>运行期切换</td></tr><tr><td>灵活性</td><td>较低</td><td>较高</td></tr><tr><td>适用场景</td><td>流程固定，步骤可变</td><td>算法整体可替换</td></tr></tbody></table><p>一句话总结：</p><ul><li>模板方法是“<strong>父类定流程，子类实现细节</strong>”</li><li>策略模式是“<strong>接口定算法，运行时切换实现</strong>”。</li></ul><h2 id="备考方法总结">备考方法总结</h2><h3 id="选择题速查">选择题速查</h3><p>Gemini 整理。</p><h4 id="面向对象与基础理论（必考-2-4-分）">面向对象与基础理论（必考 2-4 分）</h4><p>这部分主要考定义和原则。看到左边的描述，直接选右边的词。</p><table><thead><tr><th style="text-align:center">题目出现的关键词/描述</th><th style="text-align:left">对应的术语/答案</th></tr></thead><tbody><tr><td style="text-align:center"><strong>对扩展开放，对修改关闭</strong></td><td style="text-align:left"><strong>开闭原则 (OCP)</strong></td></tr><tr><td style="text-align:center"><strong>一个类只有一个引起它变化的原因</strong></td><td style="text-align:left"><strong>单一职责原则 (SRP)</strong></td></tr><tr><td style="text-align:center"><strong>子类必须能够替换父类</strong></td><td style="text-align:left"><strong>里氏替换原则 (LSP)</strong></td></tr><tr><td style="text-align:center"><strong>依赖于抽象，不要依赖于具体</strong></td><td style="text-align:left"><strong>依赖倒置原则 (DIP)</strong></td></tr><tr><td style="text-align:center"><strong>接口要小而专，客户端不应依赖不需要的方法</strong></td><td style="text-align:left"><strong>接口隔离原则 (ISP)</strong></td></tr><tr><td style="text-align:center"><strong>只与直接的朋友通信 / 最少知识原则</strong></td><td style="text-align:left"><strong>迪米特法则 (LoD)</strong></td></tr><tr><td style="text-align:center"><strong>优先使用对象组合，而不是类继承</strong></td><td style="text-align:left"><strong>合成复用原则 (CARP)</strong> / <strong>黑箱复用</strong></td></tr><tr><td style="text-align:center"><strong>继承复用 / 父类细节对子类可见</strong></td><td style="text-align:left"><strong>白箱复用</strong></td></tr><tr><td style="text-align:center"><strong>设计模式的三大要素</strong></td><td style="text-align:left"><strong>名称 (Name)、问题 (Problem)、解决方案 (Solution)</strong></td></tr><tr><td style="text-align:center"><strong>模式发现的“三次律”</strong></td><td style="text-align:left"><strong>Rule of Three</strong> (事不过三，不要预先设计模式)</td></tr><tr><td style="text-align:center"><strong>高内聚、低耦合</strong></td><td style="text-align:left"><strong>High Cohesion, Low Coupling</strong> (软件设计目标)</td></tr></tbody></table><h4 id="设计模式的分类（送分题，必考-2-分）">设计模式的分类（送分题，必考 2 分）</h4><h4 id="23种模式的一句话定义（核心考点）">23种模式的一句话定义（核心考点）</h4><p>这是选择题的重灾区。看到题干的描述，快速定位是哪个模式。</p><ol><li><strong>创建型</strong></li></ol><table><thead><tr><th style="text-align:left">关键词 / 题干描述</th><th style="text-align:left">对应模式</th></tr></thead><tbody><tr><td style="text-align:left"><strong>保证一个类只有一个实例</strong>，提供全局访问点</td><td style="text-align:left"><strong>单例 (Singleton)</strong></td></tr><tr><td style="text-align:left"><strong>定义创建对象的接口，让子类决定实例化哪一个类</strong></td><td style="text-align:left"><strong>工厂方法 (Factory Method)</strong></td></tr><tr><td style="text-align:left">提供一个接口，创建<strong>一系列相关或相互依赖</strong>的对象（产品族）</td><td style="text-align:left"><strong>抽象工厂 (Abstract Factory)</strong></td></tr><tr><td style="text-align:left">将一个复杂对象的<strong>构建与表示分离</strong>，使得同样的构建过程可以创建不同的表示</td><td style="text-align:left"><strong>建造者 (Builder)</strong></td></tr><tr><td style="text-align:left">通过<strong>复制 (Clone)</strong> 现有对象来创建新对象</td><td style="text-align:left"><strong>原型 (Prototype)</strong></td></tr></tbody></table><ol start="2"><li><strong>结构型</strong></li></ol><table><thead><tr><th style="text-align:left">关键词 / 题干描述</th><th style="text-align:left">对应模式</th></tr></thead><tbody><tr><td style="text-align:left">将一个接口<strong>转换</strong>成客户希望的另一个接口</td><td style="text-align:left"><strong>适配器 (Adapter)</strong></td></tr><tr><td style="text-align:left">将<strong>抽象部分与实现部分分离</strong>，使它们可以独立变化（多维度变化）</td><td style="text-align:left"><strong>桥接 (Bridge)</strong></td></tr><tr><td style="text-align:left">将对象组合成<strong>树形结构</strong>，以表示“部分-整体”的层次结构</td><td style="text-align:left"><strong>组合 (Composite)</strong></td></tr><tr><td style="text-align:left"><strong>动态地</strong>给一个对象<strong>添加一些额外的职责</strong>（比继承更灵活）</td><td style="text-align:left"><strong>装饰 (Decorator)</strong></td></tr><tr><td style="text-align:left">为子系统中的一组接口提供一个<strong>一致的界面/统一入口</strong></td><td style="text-align:left"><strong>外观 (Facade)</strong></td></tr><tr><td style="text-align:left">运用<strong>共享</strong>技术有效地支持大量细粒度的对象</td><td style="text-align:left"><strong>享元 (Flyweight)</strong></td></tr><tr><td style="text-align:left">为其他对象提供一种<strong>代理</strong>以<strong>控制</strong>对这个对象的访问</td><td style="text-align:left"><strong>代理 (Proxy)</strong></td></tr></tbody></table><ol start="3"><li><strong>行为型</strong></li></ol><table><thead><tr><th style="text-align:left">关键词 / 题干描述</th><th style="text-align:left">对应模式</th></tr></thead><tbody><tr><td style="text-align:left">定义一系列<strong>算法</strong>，把它们封装起来，并且使它们可<strong>互换</strong></td><td style="text-align:left"><strong>策略 (Strategy)</strong></td></tr><tr><td style="text-align:left">定义一个操作中算法的<strong>骨架</strong>，而将一些步骤<strong>延迟到子类</strong>中</td><td style="text-align:left"><strong>模板方法 (Template Method)</strong></td></tr><tr><td style="text-align:left">一对多依赖，一个对象<strong>改变状态</strong>，所有依赖者<strong>收到通知</strong>并自动更新</td><td style="text-align:left"><strong>观察者 (Observer)</strong></td></tr><tr><td style="text-align:left">将<strong>请求封装为一个对象</strong>，从而支持排队、日志、撤销操作</td><td style="text-align:left"><strong>命令 (Command)</strong></td></tr><tr><td style="text-align:left">允许一个对象在其<strong>内部状态改变</strong>时改变它的行为</td><td style="text-align:left"><strong>状态 (State)</strong></td></tr><tr><td style="text-align:left">使多个对象都有机会处理请求，将这些对象连成<strong>一条链</strong></td><td style="text-align:left"><strong>职责链 (Chain of Resp.)</strong></td></tr><tr><td style="text-align:left">用一个<strong>中介对象</strong>来封装一系列的对象<strong>交互</strong>（多对多变一对多）</td><td style="text-align:left"><strong>中介者 (Mediator)</strong></td></tr><tr><td style="text-align:left">在不破坏封装性的前提下，<strong>捕获</strong>一个对象的内部状态，并在该对象之外<strong>保存</strong></td><td style="text-align:left"><strong>备忘录 (Memento)</strong></td></tr><tr><td style="text-align:left">提供一种方法<strong>顺序访问</strong>一个聚合对象中各个元素，而不暴露内部表示</td><td style="text-align:left"><strong>迭代器 (Iterator)</strong></td></tr></tbody></table><h4 id="易混淆概念辨析（陷阱题）">易混淆概念辨析（陷阱题）</h4><p>选择题里经常会有干扰项，比如“A和B的区别”。</p><ol><li><p><strong>适配器 vs 桥接</strong>：</p><ul><li><strong>适配器</strong>：事后补救。接口不通，我加个转接头。（关键词：转换、兼容）。</li><li><strong>桥接</strong>：事前设计。防止类爆炸，两个维度独立变化。（关键词：分离抽象与实现）。</li></ul></li><li><p><strong>适配器 vs 装饰 vs 代理</strong>：</p><ul><li><strong>适配器</strong>：<strong>改变</strong>接口，不改变功能（为了能插进去）。</li><li><strong>装饰</strong>：<strong>不改变</strong>接口，<strong>增强</strong>功能（为了更漂亮/强大）。</li><li><strong>代理</strong>：<strong>不改变</strong>接口，<strong>控制</strong>访问（为了安全/性能）。</li></ul></li><li><p><strong>外观 (Facade) vs 中介者 (Mediator)</strong>：</p><ul><li><strong>外观</strong>：单向。客户端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> 外观 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> 子系统。（为了简单）。</li><li><strong>中介者</strong>：双向/多向。同事A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">↔</span></span></span></span> 中介 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">↔</span></span></span></span> 同事B。（为了解耦）。</li></ul></li><li><p><strong>状态 (State) vs 策略 (Strategy)</strong>：</p><ul><li><strong>状态</strong>：状态转移通常是<strong>自动</strong>的，或者由上下文内部逻辑决定。</li><li><strong>策略</strong>：算法的选择通常是<strong>客户端主动指定</strong>的。</li></ul></li></ol><h4 id="真题里出现过的“偏门”考点">真题里出现过的“偏门”考点</h4><ul><li><strong>开闭原则的英文</strong>：The Open-Closed Principle (OCP)。</li><li><strong>单一职责原则的英文</strong>：Single Responsibility Principle (SRP)。</li><li><strong>设计模式的起源</strong>：建筑学（Christopher Alexander）。</li><li><strong>GoF (Gang of Four)</strong>：指《设计模式》那本书的四位作者。</li><li><strong>模式数量</strong>：GoF 书里一共有 <strong>23</strong> 种典型模式，但是<strong>所有的设计模式不止 23 种</strong>。</li></ul><h3 id="设计原则">设计原则</h3><table><thead><tr><th style="text-align:center">症状 /坏味道 (Bad Smell)</th><th style="text-align:center">违反的原则</th><th style="text-align:center">标准修正方案</th></tr></thead><tbody><tr><td style="text-align:center">类的方法太多，大杂烩</td><td style="text-align:center">SRP (单一职责)</td><td style="text-align:center">拆分类</td></tr><tr><td style="text-align:center">接口方法太多，实现类被迫写空方法</td><td style="text-align:center">ISP(接口隔离)</td><td style="text-align:center">拆分接口</td></tr><tr><td style="text-align:center">修改功能要去改旧代码 (<code>if-else</code>)</td><td style="text-align:center">OCP (开闭原则)</td><td style="text-align:center">加策略模式/多态</td></tr><tr><td style="text-align:center">高层代码里直接 <code>new</code> 底层具体类</td><td style="text-align:center">DIP (依赖倒置)</td><td style="text-align:center">依赖接口，依赖注入</td></tr><tr><td style="text-align:center">子类抛出“不支持操作"异常</td><td style="text-align:center">LSP (里氏替换)</td><td style="text-align:center">提取公共父类，取消继承</td></tr><tr><td style="text-align:center">代码出现 <code>a.getB().getC().do()</code></td><td style="text-align:center">LoD (迪米特)</td><td style="text-align:center">在 B 中增加 <code>doSomething()</code> 方法</td></tr><tr><td style="text-align:center">继承仅仅为了用代码，不是 is-A</td><td style="text-align:center">CARP(合成复用)</td><td style="text-align:center">改为成员变量组合</td></tr></tbody></table><h3 id="UML-绘图">UML 绘图</h3><p><img src="https://images.kisechan.space/20251122202516535.png" srcset="/img/loading.gif" lazyload alt="类间关系与 UML 绘制"></p><h3 id="选取设计模式">选取设计模式</h3><table><thead><tr><th>题目关键词/场景描述</th><th>对应设计模式</th><th>核心特征</th></tr></thead><tbody><tr><td><strong>树形结构</strong>、目录、文件夹、部分-整体一致</td><td><strong>组合模式</strong> (Composite)</td><td>统一叶子和容器的接口</td></tr><tr><td><strong>动态添加功能</strong>、加边框、加滤镜、层层包装</td><td><strong>装饰模式</strong> (Decorator)</td><td>继承+组合同一个接口</td></tr><tr><td><strong>算法切换</strong>、多种打折方式、多种税费计算、排序</td><td><strong>策略模式</strong> (Strategy)</td><td>消除 <code>if-else</code>，算法独立</td></tr><tr><td><strong>联动</strong>、当…变化时通知其他…、广播、订阅</td><td><strong>观察者模式</strong> (Observer)</td><td>1对多依赖，自动更新</td></tr><tr><td><strong>换肤</strong>、多数据库支持、生产<strong>一系列</strong>产品(上衣+裤子)</td><td><strong>抽象工厂</strong></td><td>生产“产品族”</td></tr><tr><td><strong>撤销/重做</strong>、<strong>解耦请求和执行</strong>、<strong>将请求封装为对象</strong>、宏指令、菜单请求、排队、日志</td><td><strong>命令模式</strong> (Command)</td><td>请求封装成对象</td></tr><tr><td><strong>旧系统</strong>、接口不兼容、转换接口</td><td><strong>适配器模式</strong> (Adapter)</td><td>包装旧接口适配新接口</td></tr><tr><td><strong>状态流转</strong>、行为随状态改变（如订单已支付/未支付）</td><td><strong>状态模式</strong> (State)</td><td>消除庞大的 switch-case</td></tr><tr><td><strong>唯一实例</strong>、读取全局配置</td><td><strong>单例模式</strong> (Singleton)</td><td>private static instance</td></tr><tr><td><strong>多维度变化</strong>（如：形状+颜色，品牌+型号）</td><td><strong>桥接模式</strong> (Bridge)</td><td>分离抽象与实现</td></tr></tbody></table><p>根据 <em>设计模式通关指南</em> 整合（Gemini）：</p><h4 id="创建型模式-Creational">创建型模式 (Creational)</h4><ol><li><p><strong>抽象工厂模式</strong> (Abstract Factory)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>校服生产子系统</strong>（作业二，第8页）。</p><ul><li><strong>场景特征</strong>：<ul><li>题目提到“生产<strong>一系列</strong>产品”或“<strong>产品族</strong>”。</li><li>产品有明确的<strong>套系</strong>概念，且套系之间不能混用。</li><li><strong>关键词</strong>：“一套秋季校服（含上衣、裤子）”、“一套夏季校服”、“Windows风格控件（含按钮、窗口）”。</li></ul></li></ul></li><li><p><strong>判题逻辑</strong>：</p><ul><li>如果只产一种产品（如只产上衣） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>工厂方法</strong>。<ul><li>如果产一套搭配好的产品（上衣+裤子） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>抽象工厂</strong>。</li></ul></li></ul></li></ul></li><li><p><strong>建造者模式</strong> (Builder)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>数据导出框架/文件生成</strong>（作业二，第10页）。</p><ul><li><strong>场景特征</strong>：<ul><li>创建一个复杂的对象，且创建过程有严格的<strong>步骤/顺序</strong>。</li><li><strong>关键词</strong>：“分三个部分：文件头、文件体、文件尾”、“分步构建”、“组装”。</li></ul></li></ul></li><li><p><strong>判题逻辑</strong>：</p><ul><li>看到“分步骤”或“组成部分固定但内容不同” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>建造者</strong>。</li></ul></li></ul></li><li><p><strong>单例模式</strong> (Singleton)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>TicketMaker</strong>（作业二，第12页）、<strong>DBConnections</strong>（第13页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>全局只需要一个实例，或者需要限制实例的数量（如连接池）。</li><li><strong>关键词</strong>：“全局唯一”、“资源共享”、“序列号生成器”、“读取配置”。</li></ul></li><li><p><strong>易错点</strong>：注意<strong>双重检查锁 (Double-Check Locking)</strong> 的写法，考试常考代码填空。</p></li></ul></li><li><p><strong>原型模式</strong> (Prototype)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>银行广告信发送</strong>（作业四最后，第55页）、<strong>水果克隆</strong>（作业一，第3页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>创建新对象成本较高，或者需要大量相似对象。</li><li><strong>关键词</strong>：“大量”、“克隆”、“复制”、“Clone()方法”。</li></ul></li><li><p><strong>混淆误区</strong>：</p><ul><li><strong>vs 抽象工厂</strong>：有时抽象工厂内部会使用原型模式来快速生成产品，但如果强调“复制自身”就是原型。</li></ul></li></ul></li></ol><h4 id="结构型模式-Structural">结构型模式 (Structural)</h4><ol><li><p><strong>适配器模式</strong> (Adapter)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>类/对象适配器转换</strong>（作业三，第13页）、<strong>视频监控系统/播放器</strong>（第54页）、<strong>电商税费计算</strong>（第47页）。</p><ul><li><strong>场景特征</strong>：<ul><li><strong>新旧</strong>系统对接，接口不兼容。</li><li><strong>关键词</strong>：“已有的类接口不符合需求”、“第三方库”、“复用旧代码”。</li></ul></li></ul></li><li><p><strong>重要考点</strong>：</p><ul><li><strong>类适配器</strong>：继承旧类，实现新接口（继承关系）。<ul><li><strong>对象适配器</strong>：持有旧类的对象，实现新接口（组合关系）。<strong>PDF第13页专门考了这个转换，必看！</strong></li></ul></li></ul></li></ul></li><li><p><strong>桥接模式</strong> (Bridge)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>操作系统线程调度</strong>（作业三，第14页）、<strong>报表系统</strong>（作业四最后，第56页）。</p><ul><li><strong>场景特征</strong>：<ul><li>一个类存在<strong>两个或多个独立变化的维度</strong>。</li><li><strong>关键词</strong>：“M个操作系统 x N种调度算法”、“M种图表类型 x N种数据源”、“排列组合”。</li></ul></li></ul></li><li><p><strong>判题逻辑</strong>：</p><ul><li>看到“两个维度”的组合爆炸 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>桥接模式</strong>。</li><li><strong>报表系统</strong>那个题是<strong>桥接+适配器</strong>的混用（桥接解决图表和数据源的组合，适配器解决Excel接口不兼容）。</li></ul></li></ul></li><li><p><strong>组合模式</strong> (Composite)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>五星级酒店菜单</strong>（作业三，第15页）、<strong>电子相册目录</strong>（作业四，第44页）、<strong>楼宇房间管线</strong>（作业四，第41页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li><strong>树形结构</strong>，需要统一对待整体（文件夹/菜单）和部分（文件/菜品）。</li><li><strong>关键词</strong>：“树状”、“目录”、“层级”、“递归”、“部分-整体”。</li></ul></li><li><p><strong>判题逻辑</strong>：</p><ul><li>只要看到“树”或“无限层级嵌套” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>组合模式</strong>。</li></ul></li></ul></li><li><p><strong>装饰模式</strong> (Decorator)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>饮料加配料</strong>（作业三，第18页）、<strong>奖金计算</strong>（作业三，第20页）、<strong>照片加特效</strong>（作业四，第44页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li><strong>动态</strong>地给对象增加功能，且功能可以<strong>叠加</strong>。</li><li><strong>关键词</strong>：“加糖加奶”、“加滤镜加边框”、“奖金层层叠加”、“无限包装”。</li></ul></li><li><p><strong>混淆误区 (高频)</strong>：</p><ul><li><strong>vs 策略模式</strong>：<ul><li><strong>策略</strong>是“<strong>换</strong>衣服”（多种算法选一个：要么打8折，要么满减）。</li><li><strong>装饰</strong>是“<strong>穿</strong>衣服”（功能叠加：底薪 + 业务奖 + 团队奖 = 总工资）。</li><li><em>注意</em>：PDF第20页的奖金计算用了装饰模式，因为奖金是<strong>累加</strong>的。如果题目说“根据不同职级选择<strong>一种</strong>计算公式”，那就是策略模式。</li></ul></li></ul></li></ul></li><li><p><strong>代理模式</strong> (Proxy)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>带名字的打印机</strong>（作业四，第53页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>控制对对象的访问，或者需要延迟加载。</li><li><strong>关键词</strong>：“代理人”、“权限控制”、“不直接实例化真正的对象”。</li></ul></li></ul></li></ol><h4 id="行为型模式-Behavioral">行为型模式 (Behavioral)</h4><ol><li><p><strong>策略模式</strong> (Strategy)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>电影票打折</strong>（作业四，第39页）、<strong>电商促销</strong>（第47页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>有多种算法/规则，需要在运行时根据条件切换。</li><li><strong>关键词</strong>：“打折方式”、“税费计算算法”、“排序算法”、“if-else过多”。</li></ul></li><li><p><strong>判题逻辑</strong>：</p><ul><li>看到“多种计算方式可互换” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>策略模式</strong>。</li><li><em>高级用法</em>：第40页提到，如果策略中有公共代码，可以结合<strong>模板方法模式</strong>（父类定骨架，子类实现具体算法）。</li></ul></li></ul></li><li><p><strong>观察者模式</strong> (Observer)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>病房呼叫系统</strong>（作业三，第28页）、<strong>消防应急系统</strong>（作业四，第32页）、<strong>智能家居</strong>（第50页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>一个对象变化，自动通知其他多个对象。</li><li><strong>关键词</strong>：“联动”、“一变多”、“发布-订阅”、“触发响应”。</li></ul></li><li><p><strong>混淆误区</strong>：</p><ul><li><strong>vs 中介者</strong>：第28页的病房呼叫系统，题目特意提到了“中介者模式”，但实际上如果主要是“状态改变通知”，观察者更常用。区别在于：<ul><li><strong>观察者</strong>：A变了，通知B、C、D。（单向广播）</li><li><strong>中介者</strong>：A和B不说话，A告诉M，M决定告诉B还是C。（网状变星状，逻辑集中在M）。</li></ul></li></ul></li></ul></li><li><p><strong>命令模式</strong> (Command)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>快餐店点餐</strong>（作业四，第25页）、<strong>Word文档操作</strong>（作业四，第42页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>将“<strong>请求</strong>”封装成对象，支持<strong>撤销、重做、排队、日志</strong>。</li><li><strong>关键词</strong>：“菜单按钮”、“快捷键”、“宏指令”、“请求排队”。</li></ul></li><li><p><strong>判题逻辑</strong>：</p><ul><li>看到“按钮绑定操作”或“撤销(Undo)” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <strong>命令模式</strong>。</li></ul></li></ul></li><li><p><strong>职责链模式</strong> (Chain of Responsibility)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>差旅费报销审批</strong>（作业四，第24页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>请求在多级对象间传递，直到有人处理。</li><li><strong>关键词</strong>：“审批流程”、“科长-处长-校长”、“层级处理”。</li></ul></li></ul></li><li><p><strong>状态模式</strong> (State)</p><ul><li><p><strong>PDF对应例题</strong>：<strong>金库/银行安防系统</strong>（作业四，第34页）、<strong>温度自动调节系统</strong>（作业四，第37页）。</p></li><li><p><strong>场景特征</strong>：</p><ul><li>对象的<strong>行为取决于它的状态</strong>，且状态会在运行时转换。</li><li><strong>关键词</strong>：“白天/黑夜模式”、“开启/关闭/运行中”、“状态流转”。</li></ul></li><li><p><strong>混淆误区 (必考)</strong>：</p><ul><li><strong>vs 策略模式</strong>：<ul><li><strong>策略</strong>：客户端<strong>主动选择</strong>算法（我要用VIP打折）。</li><li><strong>状态</strong>：系统<strong>自动流转</strong>（当前是“加热态”，到了100度自动变成“保温态”，用户不直接干预）。</li></ul></li></ul></li></ul></li></ol><h4 id="混合模式实战（高分关键）">混合模式实战（高分关键）</h4><p>PDF中出现了几个难度较高的混合模式，这是大题的压轴点：</p><ol><li><p><strong>组合 + 装饰 (Composite + Decorator)</strong></p><ul><li><strong>例题</strong>：电子相册（第44页）。</li><li><strong>逻辑</strong>：用组合模式构建相册（年/月/日/照片）的树形结构，用装饰模式给照片（叶子节点）加特效。</li></ul></li><li><p><strong>策略 + 适配器 (Strategy + Adapter)</strong></p><ul><li><strong>例题</strong>：电商促销与税费（第47页）。</li><li><strong>逻辑</strong>：用策略模式处理不同的促销折扣，用适配器模式接入不同供应商的税费计算接口。</li></ul></li><li><p><strong>观察者 + 适配器 (Observer + Adapter)</strong></p><ul><li><strong>例题</strong>：消防系统（第32页）。</li><li><strong>逻辑</strong>：探测器发现火灾（Subject）通知各种设备（Observer），但不同品牌的设备接口不一样，所以用适配器（Adapter）包一层再接收通知。</li></ul></li><li><p><strong>桥接 + 适配器 (Bridge + Adapter)</strong></p><ul><li><strong>例题</strong>：报表系统（第56页）。</li><li><strong>逻辑</strong>：图表形状和数据来源是两个维度（桥接），其中Excel数据源是第三方API，不兼容，需要适配（适配器）。</li></ul></li></ol><h4 id="总结：考试答题“必杀技”">总结：考试答题“必杀技”</h4><ol><li><strong>找维数</strong>：一个维度变化选策略，两个维度选桥接。</li><li><strong>看数量</strong>：一个对象选单例，一族对象选抽象工厂。</li><li><strong>看关系</strong>：树形选组合，层层包裹选装饰，转换接口选适配器。</li><li><strong>看动作</strong>：多级审批选职责链，撤销重做选命令，联动更新选观察者。</li><li><strong>看逻辑</strong>：状态自动变选状态模式，算法人为换选策略模式。</li></ol><h2 id="参考和注解">参考和注解</h2><p><strong>参考</strong>：</p><ul><li>这位学长的笔记：<a target="_blank" rel="noopener" href="https://blog.chencs.online/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/">https://blog.chencs.online/posts/设计模式应试笔记/</a></li><li>设计模式通关指南：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gonghr/p/16907680.html">https://www.cnblogs.com/gonghr/p/16907680.html</a></li><li>学长整理的资料集合：<a target="_blank" rel="noopener" href="https://github.com/ChenGeng0102/JLU/tree/main/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">https://github.com/ChenGeng0102/JLU/tree/main/大三上/软件设计模式</a></li><li>张欣佳老师的教案</li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://github.com/ChenGeng0102/JLU/blob/main/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9C%9F%E6%9C%AB%E7%AC%94%E8%AE%B0%EF%BC%88%E8%80%83%E5%9C%BA%E7%89%88%EF%BC%89/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%90%E6%96%87%E4%BB%B6A%E3%80%91.pdf">https://github.com/ChenGeng0102/JLU/blob/main/大三上/软件设计模式/期末笔记（考场版）/设计模式【文件A】.pdf</a> <a href="#fnref:1" rev="footnote" class="footnote-backref">↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="print-no-link">#设计模式</a></div></div><div class="license-box my-3"><div class="license-title"><div>软件设计模式 课程笔记</div><div>https://blog.kisechan.space/2025/notes-design-pattern/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kisechan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年11月15日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2025年12月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/notes-machine-learning/" title="机器学习 课程笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">机器学习 课程笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/db-engine-2/" title="设计一个数据库引擎 (2) 索引"><span class="hidden-mobile">设计一个数据库引擎 (2) 索引</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",function(){var e=Object.assign({clientID:"Ov23liWYIiu2jxReIEhB",clientSecret:"d7b44817ae2553b2175fdecfde9718b582bdc653",repo:"Comment-Kisechan",owner:"Kisechan",admin:["Kisechan"],language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!0,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",enabled:!0},{id:"b46cbace8fa64af2c1ae854a18cd6771"});new Gitalk(e).render("gitalk-container")})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded(function(){Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})})</script><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><div><span>Frame by <a href="https://hexo.io" target="_blank" rel="nofollow noopener">Hexo</a></span> <span>| Theme <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></span></div><div style="font-size:.85rem"><span><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></span><span><script async src="https://views.kisechan.space/views.js"></script><br><span id="my-site-view">本站总访问量：加载中...</span><br><br><span>&copy; 2024 - 2025 By <a href="https://github.com/Kisechan" target="_blank" rel="nofollow noopener"><strong>Kisechan</strong></a><br></span><span>今天也很喜欢你！</span><br><a href="https://icp.gov.moe/?keyword=20251453" target="_blank">萌ICP备20251453号</a></span></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,i,n,m=document.getElementById("updated-time");m&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(i=(t=m.textContent).match(e))&&(n=moment(i[0]).fromNow(),m.textContent=t.replace(e,n)),m.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/linkcard.js"></script><script src="/js/cursor.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script><script type="text/javascript">var originalTitle=document.title;window.onblur=function(){document.title="等你回来哦"},window.onfocus=function(){document.title=originalTitle}</script><div id="tooltip-rightmenu" class="tooltip-rightmenu">如果需要使用原始右键菜单请按下 <strong>Ctrl+右键</strong></div><div id="tooltip-clipboard" class="tooltip-rightmenu">链接复制成功！</div><div id="rightmenu-wrapper"><ul class="list-v rightmenu" id="rightmenu-content"><li class="navigation menuNavigation-Content"><a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa fa-arrow-left rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa fa-arrow-right rightmenu-icon"></i></a> <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa fa-refresh rightmenu-icon"></i></a> <a aria-label="TOP" href="#" role="button"><i class="fa fa-arrow-up rightmenu-icon"></i></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><span><i class="fa fa-search rightmenu-icon"></i> 站内搜索</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="toggleFullScreen()"><span><i class="fa fa-arrows-alt rightmenu-icon"></i> 切换全屏</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="copyPageUrl()"><span><i class="fa fa-clipboard rightmenu-icon"></i> 复制链接</span></a></li><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" href="javascript:;" onclick="scrollToComments()"><span><i class="fa fa-commenting rightmenu-icon"></i> 立即评论</span></a></li><hr class="menuLoad-Content" style="display:block"><li class="menuLoad-Content" style="display:block"><a class="vlts-menu fix-cursor-default" target="_blank" rel="noopener" href="https://www.kisechan.space/" data-group="link"><span><i class="fa fa-info-circle rightmenu-icon"></i> 关于本站</span></a></li></ul></div><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/css/custom_right_menu_icons.css" type="text/css" rel="stylesheet"><script src="/js/right_menu.js" type="text/javascript"></script><link href="/css/right_menu.css" type="text/css" rel="stylesheet"><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>