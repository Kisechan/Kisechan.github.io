<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux课程笔记</title>
    <link href="/2024/linux-note/"/>
    <url>/2024/linux-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux和开源"><a href="#Linux和开源" class="headerlink" title="Linux和开源"></a>Linux和开源</h1><h2 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h2><h3 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h3><ul><li><strong>时间</strong>：1969</li><li><strong>地点</strong>：AT&amp;T 贝尔实验室</li><li><strong>人物</strong>：Ken Thompson和Dennis Ritchie</li><li><strong>动机</strong>：玩游戏</li><li><strong>理念</strong>：简单易用（KISS，Keep it simple, stupid!）</li></ul><p>最初使用<strong>汇编语言</strong>开发，1973年，二人使用C重写了UNIX源码。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>UNIX以<strong>源代码形式</strong>发行，形成了两个重要流派：</p><table><thead><tr><th align="center">UNIX版本</th><th align="center">主要发行版分支</th></tr></thead><tbody><tr><td align="center">UNIX SYSTEM V</td><td align="center">AIX、SOLARIS、HP-UX、IRIX</td></tr><tr><td align="center">Berkeley UNIX</td><td align="center">FreeBSD、NetBSD、OpenBSD</td></tr></tbody></table><blockquote><p>BSD：Berkeley Software Distribution</p></blockquote><p>80年代，UNIX版本剧增，各版本间差别扩大，于是就有了对每种实现必须定义各种限制的说明的<strong>标准化</strong>。两个重要的标准是：</p><ul><li><p><strong>系统V接口定义（SVID，System V Interface Definition）</strong>，来自AT&amp;T</p></li><li><p><strong>可移植操作系统接口（POSIX，Portable Operating System Interface）</strong>，来自ISO和IEEE</p></li></ul><blockquote><p>目前几乎所有的UNIX&#x2F;Linux发行版均遵循POSIX标准。</p></blockquote><h2 id="Linux的兴起"><a href="#Linux的兴起" class="headerlink" title="Linux的兴起"></a>Linux的兴起</h2><p>目前应用最广泛的类UNIX系统。<strong>2个人4个1</strong>：</p><ul><li>2个人：Richard Stallman &amp; Linus Torvalds</li><li>4个1：<ul><li>1个项目：GNU</li><li>1个组织：FSF</li><li>1个理念：Copyleft</li><li>1个许可证：GPL</li></ul></li></ul><h3 id="GNU计划"><a href="#GNU计划" class="headerlink" title="GNU计划"></a>GNU计划</h3><p>GNU is Not Unix.</p><p>1983年9月27日发起，目标：</p><ul><li>创建一个<strong>自由共享</strong>、<strong>可被任何人修改</strong>的类UNIX系统</li><li>与UNIX兼容</li><li>不受UNIX名字和代码私有权限制</li><li>能运行UNIX程序</li></ul><p>GNU的执行者是<strong>自由软件基金会</strong>（FSF，Free Software Foundation），在1985年成立，目标：</p><ul><li>执行GNU计划</li><li>提供技术、法律、财政支持</li><li>开发更多自由软件</li></ul><p>GNU完成了许多UNIX应用程序的仿制品，例如：</p><ul><li>GCC</li><li>GDB：源代码级程序调试工具</li><li>GNU make：软件构建工具</li><li>bash</li><li>GNU Emacs：文本编辑器</li></ul><p>但是并没有GNU并没有成功开发Linux内核。</p><h3 id="GPL许可证"><a href="#GPL许可证" class="headerlink" title="GPL许可证"></a>GPL许可证</h3><p>Richard Stallman提出<strong>Copyleft</strong>（著佐权）概念：著作权归原作者所有，但其他一切权利可以让所有人共享：</p><ul><li>授予使用者运行、赋值、修改、发行修改后的程序的权利</li><li>不能在修改后的软件上添加限制</li><li>修改后的软件要以同等授权方式发布回馈社会</li></ul><p>基于Copyleft，Stallman提出了<strong>GPL许可证</strong>（GNU General Public License）。</p><p>GNU开发的工具都在GPL下发行。</p><p>意义：</p><ul><li>确保任何使用自由软件创建的新产品，都必须在GPL协议下发行。</li><li>以自由软件为基础，修改后重新发行也必须公开源代码。</li><li>允许商业使用</li></ul><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><p>Linus Torvalds希望开发一个自由，开放源代码的Unix，并在1991年在GPL协议下发布了第一版Linux内核。Linux的吉祥物为Tux。</p><p>Linux内核目前在Linux基金会支持下由贡献者共同开发，Linus拥有内核能接受哪些更改和谁可以成为维护者的最终决定权。</p><p>Linux既是操作系统内核，又是基于内核的操作系统。Linux&#x3D;GNU Tools+Linus Kernel，故也称为GNU&#x2F;Linux。</p><p>Linux包括内核版本和发行版本。</p><ul><li>内核版本由社区（<a href="https://www.kernel.org/">https://www.kernel.org/</a> ）统一发布，包括主、次版本号和修订次数。</li><li>发行版本的名称和版本号由发行维护者决定，分为<strong>商业发行版</strong>和<strong>社区发行版</strong>。</li></ul><h2 id="开源软件运动"><a href="#开源软件运动" class="headerlink" title="开源软件运动"></a>开源软件运动</h2><p>自由软件运动蓬勃发展后，并非全部自由软件用户和开发者都赞同自由软件运动的目标。1998年，自由软件阵营中的部分成员分裂出来，并以“开源”为名继续开展活动。而后，开源的理念不断兴起，不断发展与壮大，其声势与影响力早已远超自由软件的运动。</p><p>埃里克·雷蒙1997在《大教堂与集市》中提出开放源代码软件理念，对自由软件的商业模式加以描述和讨论：<strong>自由软件存在的意义不是替代现存的商业软件，共享源代码可以产生更好的结果。</strong></p><p>1998年，<strong>开放源代码促进会</strong>（Open Source Initiative，OSI）成立，推动开源软件发展，统一了开源软件的认证标准。</p><p>OSI首次正式提出开源软件的概念：</p><ul><li>一种源代码可以任意获取的计算机软件</li><li>软件著作权持有人在软件协议的规定之下保留一部分权利</li><li>允许用户学习、修改以及以任何目的向任何人分发该软件</li><li>开源协议通常符合开放源代码的定义的要求</li></ul><p>这之后也诞生了一些一些开源许可证，如<strong>Apache、BSD、MIT、Mozilla、木兰公共许可证</strong>等。木兰开源许可证是中国首个开源许可证，分为木兰宽松许可证和木兰公共许可证。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>Linux操作系统的结构总体上分为内核空间和用户空间两部分：</p><ul><li><p><strong>内核空间</strong>：管理系统资源、提供服务以及控制硬件</p></li><li><p><strong>用户空间</strong>：包括用户应用程序和系统工具，通过内核提供的接口来访问系统资源</p></li></ul><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>主要功能有：</p><ul><li>进程管理</li><li>内存管理</li><li>文件系统</li><li>设备管理</li><li>网络堆栈管理</li><li>系统调用</li></ul><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>包括用户程序和系统工具，重要组件：<strong>库函数</strong>和<strong>shell</strong></p><p>库函数即<strong>预先编写好的代码</strong>，以库的形式组织。库函数执行各种常见的任务，如输入&#x2F;输出处理、数学计算等，避免开发者重写相同代码，提高程序开发效率和代码可维护性，包括<strong>静态库和动态库</strong>。</p><ul><li><p>静态库</p><ul><li><p>在程序编译链接时被包含进最终的可执行文件中</p></li><li><p>程序运行时，静态库中的代码成为程序的一部分</p></li><li><p>Linux系统中，静态库通常以.a结尾</p></li></ul></li><li><p>动态库</p><ul><li><p>在程序运行时被动态加载</p></li><li><p>多个应用程序可以共享同一份库文件，从而节省磁盘空间和内存</p></li><li><p>动态库在Linux系统中通常以.so为结尾</p></li></ul></li></ul><p>shell是<strong>一类命令解释程序的统称</strong>，为用户提供与操作系统交互的接口。用户通过shell提供的界面输入命令，shell解析这些命令并调用相应的程序来执行，然后将执行的结果反馈给用户。功能有：</p><ul><li><p>命令执行：用户输入命令后，shell查找命令并执行。</p></li><li><p>重定向和管道</p><ul><li><p>重定向：可将命令的输出保存到文件中，或者从文件中读取输入。</p></li><li><p>管道：允许将一个命令的输出作为另一个命令的输入。</p></li></ul></li><li><p>作业控制：允许用户控制后台作业的执行，如暂停、恢复和终止作业。</p></li><li><p>脚本编程：shell还是一个程序开发与运行环境，允许用户编写并执行由一系列命令组成的脚本程序，自动实现复杂任务操作。</p></li></ul><h2 id="Linux的核心特征"><a href="#Linux的核心特征" class="headerlink" title="Linux的核心特征"></a>Linux的核心特征</h2><p>Linux系统作为一种不断发展的现代操作系统，既继承了类Unix系统的共性，又拥有众多独特特性。</p><p><strong>专有软件不是Linux的核心特征。</strong></p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>Linux基于开源协议发布，其源代码可以自由地查看、修改和分发推动了全球范围内的合作与改进，使Linux系统持续进化。</p><h3 id="多用户和多任务"><a href="#多用户和多任务" class="headerlink" title="多用户和多任务"></a>多用户和多任务</h3><ul><li><p>多用户即多用户同时共同使用计算机。各个用户执行不同程序，提供安全机制，隔离用户。</p></li><li><p>多任务即启动一个任务后，继续执行其他任务，并允许用户在前台和后台多个任务间进行切换。</p></li></ul><h3 id="硬件支持与广泛兼容性"><a href="#硬件支持与广泛兼容性" class="headerlink" title="硬件支持与广泛兼容性"></a>硬件支持与广泛兼容性</h3><p>Linux支持广泛的硬件平台，包括个人计算机、服务器、嵌入式设备和超级计算机，并能在多种CPU架构上运行，如x86、x86_64、ARM、SPARC等。</p><p>Linux与众多开放标准和协议兼容，如POSIX、UNIX规范等。</p><h3 id="稳定可靠、网络功能强大与可定制性"><a href="#稳定可靠、网络功能强大与可定制性" class="headerlink" title="稳定可靠、网络功能强大与可定制性"></a>稳定可靠、网络功能强大与可定制性</h3><ul><li><p>Linux成熟稳定，能长时间运行无需重启，在服务器领域应用广泛。</p></li><li><p>网络功能强大，支持各种网络协议和标准，广泛用于各类网络服务器。</p></li><li><p>Linux提供高度可定制性，用户可根据自身需求选择不同的桌面环境、窗口管理器和应用程序。其发行版众多，可挑选适合自己的Linux版本。</p></li></ul><h3 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h3><p>Linux系统获得了广泛的社区支持，社区由开发者、用户和爱好者组成，他们共同贡献代码、分享知识、提供技术支持并推广Linux的使用。</p><p>在内核开发方面，有Linux内核社区；几乎每个Linux发行版都有自己的社区，如Ubuntu、Debian、openEuler社区。</p><h1 id="基本概念与使用"><a href="#基本概念与使用" class="headerlink" title="基本概念与使用"></a>基本概念与使用</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>UNIX是一个多用户操作系统，用户在使用UNIX系统前必须进行登录，登录是识别用户身份、分配资源允许用户使用系统的过程。</p><p>登录方式主要有本地登录和远程登录（<code>ssh 用户名@ip地址或域名</code>）。</p><p><code>passwd [username]</code>修改自己或别人的口令，也可以用于生成初始口令（root）。</p><p>退出登录shell的三种方法：</p><ul><li><code>exit</code></li><li>[Ctrl+D]</li><li><code>logout</code></li></ul><p><code>quit</code>不能退出系统。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>用户登录成功后，就能看到用于输入命令的命令行，以及在命令行中为用户提示信息的命令提示符。</p><p>最简单的命令提示符只有一个字符：</p><ul><li>管理员（root）：<code>#</code></li><li>普通用户：<code>$</code></li></ul><p>用户可以设置提示符，显示丰富系统信息。</p><p>命令行快捷键：</p><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">[Ctrl+h]</td><td align="center">删除单个字符</td></tr><tr><td align="center">[Ctrl+u]</td><td align="center">删除单行</td></tr><tr><td align="center">[Ctrl+a]</td><td align="center">跳到开头</td></tr><tr><td align="center">[Ctrl+e]</td><td align="center">调到结尾</td></tr><tr><td align="center">[Ctrl+c]</td><td align="center">中断运行</td></tr><tr><td align="center">[Ctrl+z]</td><td align="center">挂起程序</td></tr><tr><td align="center">[Ctrl+l]</td><td align="center">清屏</td></tr><tr><td align="center">[Tab]</td><td align="center">自动补全</td></tr></tbody></table><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>命令分为<strong>外部命令</strong>和<strong>内部命令</strong>。</p><ul><li>外部命令：磁盘中程序的命令（<code>man</code>，<code>info</code>）</li><li>内部命令：shell本身的一部分或shell内部识别、执行的命令，执行速度快（<code>help</code>）</li></ul><p>不同的流派Unix选项写法不同，但一般会兼容：</p><table><thead><tr><th align="center">流派</th><th align="center">连接符写法</th><th align="center">选项表示</th></tr></thead><tbody><tr><td align="center">System V（常用）</td><td align="center"><code>-</code></td><td align="center">字母</td></tr><tr><td align="center">BSD</td><td align="center"></td><td align="center">字母</td></tr><tr><td align="center">GNU</td><td align="center"><code>--</code></td><td align="center">单词</td></tr></tbody></table><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>通过<code>who</code>命令可以查看登录终端。</p><ul><li><p><strong>物理终端</strong>：一套输入输出设备，用于用户登录和使用计算机；如连接在计算机上的显示器、键盘鼠标；与名词主机对应</p></li><li><p><strong>虚拟终端</strong>（tty，teletypewriter，电传打字机的简称）：<strong>附加在物理终端之上</strong>，用软件方式虚拟实现。类Unix系统启动后默认为用户创建几个虚拟终端，实现多用户的同时登录或单用户的多终端登录。虚拟终端对应的设备文件是<code>/dev/tty#</code>（#为非负整数）。</p></li><li><p>终端为<code>:0</code>时表示是<strong>图形用户界面终端</strong>。</p></li></ul><p>虚拟终端可以使用虚拟控制台实现。Linux通常启用6个虚拟终端：tty1图形终端，tty2-tty6字符终端。可以使用<strong>虚拟控制台</strong>切换虚拟终端：</p><ul><li>切换方式1：Ctrl-Alt-F[1-6]</li><li>切换方式2：<code>#chvt n</code></li></ul><p>通过<code>tty</code>命令来查看当前的虚拟终端号。但是<code>tty</code>并不都是虚拟终端。</p><p><strong>伪终端</strong>（pty）是由<strong>远程登录软件或终端模拟软件</strong>模拟出的终端，主要有两种应用场景：</p><ul><li>图形界面下进行命令操作</li><li>远程登录</li></ul><p>pts(pseudo-terminal slave)是pty的实现方法。伪终端以<code>pts/n</code>的形式命名。</p><p>使用<code>whoami</code>可以查看用户名，<code>who am i</code>可以查看终端号等。</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell有很多种类，在<code>/bin/*sh</code>中：</p><table><thead><tr><th align="center">名称</th><th align="center">解释</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>sh</code></td><td align="center">Bourne Shell（sh）</td><td align="center">大多数UNIX操作系统的标准shell和默认shell</td></tr><tr><td align="center"><code>ksh</code></td><td align="center">Korn Shell（ksh）</td><td align="center">Bourne Shell的一个超集，<code>sh</code>程序可以不修改在<code>ksh</code>上运行</td></tr><tr><td align="center"><code>csh</code></td><td align="center">C Shell（csh）</td><td align="center">由加州大学伯克利分校开发，采用C语言风格的语法</td></tr><tr><td align="center"><code>bash</code></td><td align="center">Bourne Again Shell（bash）</td><td align="center">Linux的标准shell和默认shell，基于<code>sh</code></td></tr></tbody></table><p>只需要键入新shell名就可以更换shell。本质是创建shell子进程，在子进程中运行新shell。如果想永久改变，可以修改账户配置文件<code>/etc/passwd</code>或使用<code>chsh</code>命令。</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>编译源代码安装与基于网络存储库安装。</p><ul><li><p>编译软件源代码：</p><p>  从软件的官方网站或可信的第三方网站下载软件的源代码，然后使用编译工具进行编译完成安装过程。这种安装软件方法较为灵活，可以选择下载特定版本或者最新版本。软件包每次更新都需要重新编译，对初学者存在一定难度。</p></li><li><p>基于网络存储库安装</p><p>  各种Linux发行版有许多官方和非官方的软件存储库，保存了大量经过编译的软件包，可以直接用于安装或更新。可以通过包管理器工具访问存储库，选择所需软件进行安装或更新。简单易行，适合初学者。软件已经过编译，安装速度比从源代码编译更快。</p></li></ul><p>基于网络库的安装工具有两种，dnf和apt：</p><table><thead><tr><th align="center">安装工具</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">apt（Advanced Package Tool）</td><td align="center">基于Debian的Linux发行版中使用的包管理器。提供命令行界面，使户能够方便搜索、安装、更新和卸载软件包。具有自动解决依赖关系的功能，可以快速地安装复杂的软件包集合。还提供了软件仓库管理功能，允许用户方便地添加、删除和配置软件仓库。</td></tr><tr><td align="center">dnf（Dandified YUM）</td><td align="center">dnf 是 YUM（Yellowdog Updater, Modified）的下一代版本管理器，旨在解决 YUM 的一些性能和依赖管理问题，并提供更好的用户体验。提供了命令行界面，支持软件包的搜索、安装、更新和卸载。具有速度快、可扩展性强，支持并可以通过插件来扩展其功能，支持多线程并发下载和安装，提高了软件包的安装速度</td></tr></tbody></table><p>dnf命令语法格式为<code>dnf [子命令] [选项] [软件包名称...]</code>，常用子命令有：</p><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>install</code></td><td align="center">安装软件包</td></tr><tr><td align="center"><code>update</code></td><td align="center">更新软件包</td></tr><tr><td align="center"><code>remove</code></td><td align="center">卸载软件包</td></tr><tr><td align="center"><code>grouplist</code></td><td align="center">显示所有可用的软件包组，包括已安装的和未安装的</td></tr><tr><td align="center"><code>groupinstall</code></td><td align="center">安装软件包组</td></tr></tbody></table><p>常用选项有<code>-y</code>，即对安装过程中所有的询问表示同意。</p><p>可以使用yum（dnf）安装软件包组。软件包组是服务于一个共同的目的一组软件包，例如系统工具集等。使用dnf可以对软件包组进行安装&#x2F;删除等操作，使相关操作更高效：<code>dnf groupinstall -y “Development Tools”</code></p><h2 id="系统启动或关闭"><a href="#系统启动或关闭" class="headerlink" title="系统启动或关闭"></a>系统启动或关闭</h2><p>Linux系统的关闭通常由关机命令触发，为确保系统安全、稳定地关闭，一般包括以下关键步骤：</p><ol><li>管理员发起关机请求：在命令行中输入<code>shutdown</code>、<code>halt</code>或<code>poweroff</code>等命令请求关闭系统</li><li>系统发送关机信号：系统初始化进程（如systemd）收到关机命令后，执行关机流程</li><li>停止所有运行的服务：停止所有正在运行的服务和进程，如网络服务、文件共享服务等</li><li>卸载文件系统：系统卸载所有已挂载的文件系统，以防止数据损坏</li><li>执行自定义关机脚本：系统可能会运行预定义的关机脚本，进行数据同步、清理缓存等操作</li><li>关闭硬件设备：系统通知所有硬件设备安全关闭，如硬盘驱动器停止运转</li><li>关闭电源：系统关闭计算机的电源</li></ol><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><p> <code>shutdown [选项] [时间]</code>命令：关机或重启。</p><p>主要选项有：</p><ul><li><code>h</code> ：停止系统，关机</li><li><code>r</code> ：重启系统</li></ul><p>例如：</p><ul><li><code># shutdown -h now</code>：立即关机</li><li><code># shutdown -h 22:45</code>：在22:25关机</li><li><code># shutdown -r +30</code>：30分钟后重启</li></ul><p><code>reboot</code>命令：重启。</p><p><code>halt</code>命令：在大多数系统中等效于<code>shutdown -h now</code>。</p><p><code>poweroff</code>命令：首先关闭所有运行的服务，卸载文件系统，然后关闭系统电源。</p><h1 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h1><p>打开vi的命令：<code>vi [选项] [文件]</code>。常用选项有：</p><ul><li><code>-c</code>：打开时执行指定的vi命令</li><li><code>-R</code>：只读打开，可强制保存</li><li><code>-M</code>：只读打开，不可强制保存</li><li><code>-r</code>：恢复文件</li><li><code>+num</code>：从第<code>num</code>行开始</li></ul><p>保存：<code>:[ a,b（保存从a至b行到） ] w [新文件名]</code>，例如<code>: 1,4 w test.c</code>。</p><p>退出：<code>:q</code>，使用<code>:q!</code>强制退出。使用<code>:x</code>、<code>:wq</code>或[Z][Z]保存并退出。</p><p>vi的<code>:version</code>命令可以显示当前的vi版本等信息。</p><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>启动vi后自动进入命令模式，输入<code>:</code>进入ex命令模式（又称为末行模式），按[i]、[I]、[a]、[A]、[o]、[O]进入输入模式。输入模式按[Esc]回到命令模式。</p><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">[i]</td><td align="center">在光标左侧输入文本</td></tr><tr><td align="center">[I]</td><td align="center">在光标所在行开头输入文本</td></tr><tr><td align="center">[a]</td><td align="center">在光标右侧输入文本</td></tr><tr><td align="center">[A]</td><td align="center">在光标所在行结尾输入文本</td></tr><tr><td align="center">[o]</td><td align="center">在光标上面创建新行，输入文本</td></tr><tr><td align="center">[O]</td><td align="center">在光标下面创建新行，输入文本</td></tr></tbody></table><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><p>在命令模式下，除了方向键，也可以用别的按键移动光标：</p><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">左移</td></tr><tr><td align="center">Backspace</td><td align="center">左移</td></tr><tr><td align="center">j</td><td align="center">下移</td></tr><tr><td align="center">回车</td><td align="center">下移到下一行行首</td></tr><tr><td align="center">k</td><td align="center">上移</td></tr><tr><td align="center">l</td><td align="center">右移</td></tr><tr><td align="center">空格</td><td align="center">右移</td></tr><tr><td align="center">nh</td><td align="center">左移n格</td></tr><tr><td align="center">nj</td><td align="center">下移n格</td></tr><tr><td align="center">nk</td><td align="center">上移n格</td></tr><tr><td align="center">nl</td><td align="center">右移n格</td></tr></tbody></table><p>大范围移动光标：</p><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">移动到行首</td></tr><tr><td align="center">$</td><td align="center">移动到行尾</td></tr><tr><td align="center">nw</td><td align="center">向右移动n个单词（跨行）</td></tr><tr><td align="center">nb</td><td align="center">向左移动n个单词（跨行）</td></tr><tr><td align="center">ne</td><td align="center">移动到后n个单词的词尾（跨行）</td></tr><tr><td align="center">gg</td><td align="center">移动到最开头</td></tr><tr><td align="center">G</td><td align="center">移动到尾行行首</td></tr><tr><td align="center">nG</td><td align="center">移动到第n行行首</td></tr><tr><td align="center">:n</td><td align="center">移动到第n行行首</td></tr><tr><td align="center">[Ctrl]+[g]</td><td align="center">获取行号</td></tr></tbody></table><h2 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h2><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">nx</td><td align="center">删除光标开始的n个字符</td></tr><tr><td align="center">nc{范围限定符}</td><td align="center">删除光标开始的n个限定范围，然后进入插入模式</td></tr><tr><td align="center">nd{范围限定符}</td><td align="center">删除光标开始的n个限定范围</td></tr></tbody></table><table><thead><tr><th align="center">范围限定符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">光标之前到行首，不包含光标</td></tr><tr><td align="center">$</td><td align="center">光标开始到行尾</td></tr><tr><td align="center">w</td><td align="center">光标开始到词尾</td></tr></tbody></table><p>特殊的，有一些删除命令：</p><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">ncc</td><td align="center">删除本行开始的n行，然后进入插入模式</td></tr><tr><td align="center">ndd</td><td align="center">删除本行开始的n行</td></tr></tbody></table><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">ny{范围限定符}</td><td align="center">复制光标开始的n个限定范围</td></tr></tbody></table><table><thead><tr><th align="center">范围限定符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">光标之前到行首，不包含光标</td></tr><tr><td align="center">$</td><td align="center">光标开始到行尾</td></tr><tr><td align="center">w</td><td align="center">光标所在的单词</td></tr><tr><td align="center">y</td><td align="center">光标所在的行</td></tr></tbody></table><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">粘贴到下一行或光标右边的位置</td></tr><tr><td align="center">P</td><td align="center">粘贴到上一行或光标左边的位置</td></tr></tbody></table><p>需要注意的是，<strong>使用dd删除文本时，它会同时被复制</strong>。</p><h2 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h2><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">撤销最近的一次修改</td></tr><tr><td align="center">U</td><td align="center">撤销当前行的所有修改</td></tr><tr><td align="center">[Ctrl]+[r]</td><td align="center">撤销撤销操作</td></tr><tr><td align="center">.</td><td align="center">重复上一次的修改</td></tr></tbody></table><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>/[文字]</code></td><td align="center">向后搜索</td></tr><tr><td align="center"><code>?[文字]</code></td><td align="center">向前搜索</td></tr><tr><td align="center">n</td><td align="center">定位到下一个项，<strong>与命令方向相同</strong></td></tr><tr><td align="center">N</td><td align="center">定位到上一个项，<strong>与命令方向相同</strong></td></tr></tbody></table><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>使用s命令：<code>: [行范围（默认为当前行），%表示全文] s / &#123;被替换项&#125; / &#123;替换项&#125; / [g（全行替换，如果没有g则会只替换每一行的第一个）][c（确认后再替换）]</code></p><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>通过选项可以定制vi编辑器的行为。主要使用<code>:set &#123;选项&#125;</code>命令。</p><ul><li><code>:set</code>：显示修改过的选项的值。</li><li><code>:set X?</code>：显示选项X的值。</li><li><code>:set all</code>：查看所有选项以及它们的设置。</li><li>布尔值选项：使用<code>:set X</code>或<code>:set noX</code>以设置或取消。</li><li>数值型选项：使用<code>:set X=number</code>，注意等号前后无空格。</li><li>字符串选项：使用<code>:set X=string</code></li></ul><p>有很多选项可以设置：</p><table><thead><tr><th align="center">选项</th><th align="center">性质</th><th align="center">默认值</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>nu</code></td><td align="center">布尔值</td><td align="center"><code>nonu</code></td><td align="center">显示行号</td></tr><tr><td align="center"><code>ts</code></td><td align="center">数值型</td><td align="center"></td><td align="center">缩进宽度</td></tr><tr><td align="center"><code>ai</code></td><td align="center">布尔值</td><td align="center"></td><td align="center">自动缩进</td></tr><tr><td align="center"><code>mouse</code></td><td align="center">字符串</td><td align="center"></td><td align="center">使能鼠标</td></tr><tr><td align="center"><code>encoding</code></td><td align="center">字符串</td><td align="center"></td><td align="center">编码方式</td></tr></tbody></table><p>在vi中设置的都是暂时的，退出即失效。需要修改配置文件达到永久效果。路径有：</p><table><thead><tr><th align="center">路径</th><th align="center">性质</th></tr></thead><tbody><tr><td align="center"><code>/etc/virc</code></td><td align="center">全局配置文件</td></tr><tr><td align="center"><code>/$HOME/.virc</code></td><td align="center">用户配置文件</td></tr><tr><td align="center"><code>/$HOME/.vim/virc</code></td><td align="center">用户配置文件</td></tr><tr><td align="center"><code>/$HOME/.exrc</code></td><td align="center">用户配置文件</td></tr></tbody></table><p>优先级递减。</p><h2 id="在vi中执行shell命令"><a href="#在vi中执行shell命令" class="headerlink" title="在vi中执行shell命令"></a>在vi中执行shell命令</h2><p>输入<code>:!&#123;command&#125;</code>、<code>:r !&#123;command&#125;</code>可以将执行结果加入文本当中，<code>:r &#123;文件名&#125;</code>可以将文件内容插入文本，一般都是在下面起新的一行。</p><h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><p>磁盘从逻辑上划分一个到多个分区，每个分区被格式化为特定类型的文件系统，在每个分区中，文件系统通过目录来组织文件。</p><p>目录可以看做一种容器，用于组织和管理其他文件和目录。Linux提供命令，在磁盘上创建、组织和查找目录和文件。</p><p>Linux继承了UNIX对文件的广义定义，一切皆文件。主要有：</p><ul><li>普通文件：数据的集合，如文本、图像、音频、视频、程序等</li><li>目录文件：用于文件的组织，包含关于其他文件的信息</li><li>特殊文件：包含与外部设备相联系的信息，系统中每个设备分别对应一个文件</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>目录本质上是一个账本，记录了该目录中包含的文件和子目录的名称，以及它们在文件系统中的位置（通过inode编号）。</p><p>目录以层次形式进行组织，从根目录<code>/</code>向下延伸。</p><h3 id="特殊的目录"><a href="#特殊的目录" class="headerlink" title="特殊的目录"></a>特殊的目录</h3><table><thead><tr><th align="center">目录</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>/</code></td><td align="center">根目录（root目录），包含了整个文件系统，目录树起点</td></tr><tr><td align="center"><code>/bin</code></td><td align="center">存放用户可以使用的可执行文件（外部命令，例如<code>cal</code>、<code>date</code>、<code>who</code>、<code>sh</code>、<code>bash</code>），有的系统存放在<code>/usr/bin</code></td></tr><tr><td align="center"><code>/sbin</code></td><td align="center">存放系统管理员（root）可以使用的系统管理命令（<code>agetty</code>、<code>fsck</code>、<code>halt</code>、<code>reboot</code>、<code>shutdown</code>、<code>useradd</code>），有的系统存放在<code>/usr/sbin</code>、<code>/usr/local/sbin</code></td></tr><tr><td align="center"><code>/lib</code>或<code>/lib64</code></td><td align="center">存放函数库和模块文件，有的系统存放在<code>/usr/lib</code>、<code>/usr/lib64</code></td></tr><tr><td align="center"><code>/boot</code></td><td align="center">存放Linux系统启动时用到的文件（内核：<code>/boot/vmlinuz-*</code>启动配置文件：<code>/boot/grub2</code>等）</td></tr><tr><td align="center"><code>/dev</code></td><td align="center">存放设备文件。设备文件是一种特殊文件，代表计算机物理部件或虚拟部件（<code>/dev/tty</code>代表终端，<code>/dev/null</code>代表空设备）</td></tr><tr><td align="center"><code>/mnt</code>，<code>/media</code></td><td align="center">用于临时挂载其他文件系统</td></tr><tr><td align="center"><code>/proc</code></td><td align="center">虚拟文件系统，将内核和进程运行状态归档为文本文件，通过这些文件可以查看硬件和正在运行的进程信息（使用<code>cat /proc/meminfo</code>或<code>cat /proc/cpuinfo</code>）</td></tr><tr><td align="center"><code>/root</code></td><td align="center">管理员root的主目录</td></tr><tr><td align="center"><code>/home</code></td><td align="center">存放所有普通用户主目录</td></tr><tr><td align="center"><code>/etc</code></td><td align="center">存放系统管理所需的配置文件（<code>/etc/passwd</code>，<code>/etc/profile</code>）和子目录，如用户信息、服务的启动脚本、常用服务的配置文件等</td></tr><tr><td align="center"><code>/usr</code></td><td align="center">存放应用程序。<code>/usr/bin</code>存放用户应用命令；<code>/usr/sbin</code>存放管理员使用的系统管理命令；<code>/usr/src</code>存放内核源代码</td></tr><tr><td align="center"><code>/opt</code></td><td align="center">主机额外安装软件的目录</td></tr><tr><td align="center"><code>/var</code></td><td align="center">存放经常变化或增长的文件，如日志、缓存、邮件、打印队列等。<code>/var/log</code>存放各种程序的日志文件</td></tr><tr><td align="center"><code>/run</code></td><td align="center">存放一些服务和程序运行后产生的信息，如进程ID、锁文件、套接字等。</td></tr><tr><td align="center"><code>/tmp</code></td><td align="center">存放临时文件，所有用户都可以访问和写入。</td></tr><tr><td align="center"><code>/sys</code></td><td align="center">存放与内核相关的信息，如<code>/sys/module</code>，<code>/sys/class</code>等</td></tr><tr><td align="center"><code>/srv</code></td><td align="center">存放一些服务启动后需要提取或访问的数据，如FTP服务、Web服务等</td></tr></tbody></table><h3 id="主目录和工作目录"><a href="#主目录和工作目录" class="headerlink" title="主目录和工作目录"></a>主目录和工作目录</h3><p>主目录是管理员在创建用户时为其分配的特定目录。用户登录时，自动进入主目录，其名称通常与用户名相同。</p><p><code>root</code>用户的主目录是<code>/root</code>。</p><p>工作目录是用户现在在文件系统中所在的目录。</p><h3 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h3><ol><li>长度约束：1 ~ 255个字符</li><li>唯一性约束：同一目录下不得存在同名文件</li><li>大小写敏感</li><li>字符约束尽量避免使用<code>&lt;</code>、<code>&gt;</code>、<code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>、<code>&#123;</code>、<code>&#125;</code>、<code>*</code>、<code>?</code>、<code>”</code>、<code>’</code>、<code>-</code>、<code>$</code>、<code>^</code>、<code>空格</code></li><li>推荐使用<code>A</code> ~ <code>Z</code>、<code>a</code> ~ <code>z</code>、<code>0</code> ~ <code>9</code>、<code>_</code> 、<code>.</code></li></ol><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><code>cd</code>命令</h3><p>用于改变工作目录（change directory）。</p><p><code>cd</code>：返回用户主目录。</p><p><code>cd  ~ [用户名]</code>：进入其他用户或自己的主目录，前提是拥有权限。</p><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a><code>mkdir</code>命令</h3><p>创建目录，可以一次创建多个。</p><p><code>-p</code>选项，可以一次创建多层目录。</p><h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a><code>rmdir</code>命令</h3><p>删除空目录。</p><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a><code>ls</code>命令</h3><p>显示目录内内容（list）。</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td align="center">列出包含隐藏文件的所有文件</td></tr><tr><td align="center"><code>-l</code></td><td align="center">显示详细信息</td></tr><tr><td align="center"><code>-d</code></td><td align="center">列出目录文件本身，而不列出目录中的文件</td></tr><tr><td align="center"><code>-i</code></td><td align="center">列出文件的索引节点</td></tr></tbody></table><p><code>-l</code>显示格式例如：</p><table><thead><tr><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center"><code>-rw-r--r--</code></td><td align="center"><code>1</code></td><td align="center"><code>david</code></td><td align="center"><code>stu</code></td><td align="center"><code>48</code></td><td align="center"><code>Jun 25 12:28</code></td><td align="center"><code>文件名</code></td></tr><tr><td align="center">文件类型与权限</td><td align="center">链接数</td><td align="center">创建者</td><td align="center">所属的组</td><td align="center">文件大小（字节）</td><td align="center">最后修改时间</td><td align="center">文件名</td></tr></tbody></table><p>在第一列中，第1个字符表示文件类型，第2 ~ 10个字符表示权限设置。</p><p>第1个字符的意义：</p><table><thead><tr><th align="center">字符</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center"><code>d</code></td><td align="center">目录文件</td></tr><tr><td align="center"><code>-</code></td><td align="center">普通文件</td></tr><tr><td align="center"><code>b</code></td><td align="center">块设备文件</td></tr><tr><td align="center"><code>c</code></td><td align="center">字符设备文件</td></tr><tr><td align="center"><code>l</code></td><td align="center">链接文件</td></tr></tbody></table><p>第2 ~ 10个字符分三组，所有者、组用户、其他人，分别对应3个字符。</p><table><thead><tr><th align="center">字符</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td align="center">读权限</td></tr><tr><td align="center"><code>w</code></td><td align="center">写权限</td></tr><tr><td align="center"><code>x</code></td><td align="center">执行权限</td></tr><tr><td align="center"><code>-</code></td><td align="center">无权限</td></tr></tbody></table><p>第二列表示文件的链接数。</p><p>第三列表示文件的所有者，通常与创建者相同，可以发生转移。</p><p>第四列表示文件所属的组，创建时属于用户所在的组。</p><p>第五列表示文件大小，单位为字节。</p><p>第六列表示上一次修改的时间。</p><p>第七列表示文件名。</p><p><code>-a</code>可以显示隐藏文件，即以<code>.</code>开头的文件。</p><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a><code>cat</code>命令</h3><p>显示一个或多个文件的内容。</p><h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a><code>more</code>命令</h3><p>分页显示文件。</p><h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a><code>head</code>命令</h3><p>显示前若干行内容，默认为10行。</p><p>通过<code>-n</code>选项指定显示多少行。</p><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a><code>tail</code>命令</h3><p>显示后若干行内容，显示行数和<code>-n</code>用法与<code>head</code>相同。</p><p>可以使用<code>-f</code>持续显示内容，用于监控文件是否有新增，直到[Ctrl]+[C]停止命令。</p><h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a><code>wc</code>命令</h3><p>用于统计行数、字数（不含空格或制表符的字符串）、字符数。</p><p>若没有指定文件名，则从键盘输入，直到按下[Ctrl]+[D]。</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-l</code></td><td align="center">统计行数</td></tr><tr><td align="center"><code>-c</code></td><td align="center">统计字符数</td></tr><tr><td align="center"><code>-w</code></td><td align="center">统计字数</td></tr></tbody></table><h3 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a><code>diff</code>命令</h3><p>比较两个文件内容是否一致。</p><table><thead><tr><th align="center">更改提示</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>a</code></td><td align="center">增加的行</td></tr><tr><td align="center"><code>d</code></td><td align="center">删除的行</td></tr><tr><td align="center"><code>c</code></td><td align="center">修改的行</td></tr></tbody></table><p>可以选择选项来忽略大小写、忽略空格等操作。</p><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a><code>rm</code>命令</h3><p>删除文件。</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-i</code></td><td align="center">删除前要求确认</td></tr><tr><td align="center"><code>-r</code></td><td align="center">递归删除目录下所有文件</td></tr><tr><td align="center"><code>-f</code></td><td align="center">强制删除</td></tr></tbody></table><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a><code>cp</code>命令</h3><p>复制。用法有：</p><ul><li><code>cp &#123;文件名1&#125; &#123;文件名2&#125;</code></li><li><code>cp （多个）&#123;文件名&#125; &#123;目录&#125;</code></li></ul><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-i</code></td><td align="center">若目标文件已存在则要求确认是否要覆盖</td></tr><tr><td align="center"><code>-r</code></td><td align="center">递归复制目录下所有文件</td></tr></tbody></table><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a><code>mv</code>命令</h3><p>移动文件。用法有：</p><ul><li><code>mv &#123;文件名1&#125; &#123;文件名2&#125;</code>：移动文件并改名</li><li><code>mv （多个）&#123;文件名&#125; &#123;目录&#125;</code></li></ul><p>选项同<code>cp</code>命令。</p><h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a><code>ln</code>命令</h3><p>在已存在文件和新文件中创建链接，类似于引用。改变一个文件，链接的文件也会被改变。用法有：</p><ul><li><code>ln &#123;已存在的文件&#125; &#123;新文件名&#125;</code></li><li><code>ln （多个）&#123;文件名&#125; &#123;目录&#125;</code>：在目录中创建同名的链接文件</li></ul><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-s</code></td><td align="center">创建软链接，类似于快捷方式，其中包含路径指针，访问它就是访问源文件的路径</td></tr></tbody></table><h3 id="paste命令"><a href="#paste命令" class="headerlink" title="paste命令"></a><code>paste</code>命令</h3><p>用于按列合并。用法是<code>paste [选项] &#123;（多个）文件名&#125;</code>。</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-d</code></td><td align="center">指定分隔符，默认是制表符<code>\t</code></td></tr><tr><td align="center"><code>-s</code></td><td align="center">将每个文件的每一行都按顺序拼接到一行上</td></tr></tbody></table><h2 id="文件名匹配"><a href="#文件名匹配" class="headerlink" title="文件名匹配"></a>文件名匹配</h2><p>shell允许用户使用指定的模式匹配文件名：</p><table><thead><tr><th align="center">字符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>?</code></td><td align="center">匹配任意单个字符</td></tr><tr><td align="center"><code>*</code></td><td align="center">匹配任意的0 ~ n个字符</td></tr><tr><td align="center"><code>[列表]</code></td><td align="center">匹配文件名中任<strong>一</strong>在列表中的字符</td></tr><tr><td align="center"><code>[!列表]</code></td><td align="center">匹配文件名中任<strong>一</strong>不在列表中的字符</td></tr></tbody></table><p><code>[列表]</code>和<code>[!列表]</code>是不能为空字符的。</p><p>需要注意的是，<code>rm -rf report*</code>和<code>rm -rf report *</code>差别很大。前者是删除所有<code>report</code>开头的文件，后者是删除<code>report</code>，然后删除所有文件。</p><h2 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h2><h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a><code>find</code>命令</h3><p>用于搜索文件。格式为<code>find &#123;路径名&#125; &#123;搜索选项&#125; &#123;动作选项&#125;</code>。</p><h4 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h4><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-name</code></td><td align="center">根据文件名查找</td></tr><tr><td align="center"><code>-type</code></td><td align="center">根据类型查找</td></tr><tr><td align="center"><code>-size n</code></td><td align="center">根据大小查找</td></tr><tr><td align="center"><code>-mtime n</code></td><td align="center">根据最后修改日期查找</td></tr></tbody></table><p>根据文件名查找，使用通配符时，需要用引号扩起文件名。</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><table><thead><tr><th align="center">字符</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center"><code>d</code></td><td align="center">目录文件</td></tr><tr><td align="center"><code>f</code></td><td align="center">普通文件</td></tr><tr><td align="center"><code>b</code></td><td align="center">块设备文件</td></tr><tr><td align="center"><code>c</code></td><td align="center">字符设备文件</td></tr></tbody></table><h4 id="逻辑查找符"><a href="#逻辑查找符" class="headerlink" title="逻辑查找符"></a>逻辑查找符</h4><table><thead><tr><th align="center">查找符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-a</code></td><td align="center">与</td></tr><tr><td align="center"><code>-o</code></td><td align="center">或</td></tr><tr><td align="center"><code>!</code></td><td align="center">非</td></tr><tr><td align="center"><code>()</code></td><td align="center">逻辑组合</td></tr></tbody></table><p>例如<code>find /dev -type b -o -type -c</code>。</p><h4 id="动作选项"><a href="#动作选项" class="headerlink" title="动作选项"></a>动作选项</h4><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>exec command &#123;&#125; \;</code></td><td align="center">对找到的文件执行<code>command</code></td></tr><tr><td align="center"><code>ok command &#123;&#125; \;</code></td><td align="center">执行前要求确认</td></tr></tbody></table><p><code>&#123;&#125;</code>是一个占位符，会代表<code>find</code>查找到的所有路径。<code>\</code>是转义符，因为<code>;</code>是一个特殊符号。<code>\;</code>是命令结束的标志。</p><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a><code>grep</code>命令</h3><p>在多个文件中查找满足格式的行，格式为<code>grep &#123;字符串&#125; [文件名]</code>。找到满足条件的行会从终端输出，若无指定文件则从键盘读入。</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-c</code></td><td align="center">只显示符合的行数</td></tr><tr><td align="center"><code>-j</code></td><td align="center">忽略大小写</td></tr><tr><td align="center"><code>-l</code></td><td align="center">只显示文件名</td></tr><tr><td align="center"><code>-n</code></td><td align="center">输出前显示行号</td></tr><tr><td align="center"><code>-v</code></td><td align="center">只显示<strong>不匹配</strong>的行</td></tr></tbody></table><h3 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a><code>cut</code>命令</h3><table><thead><tr><th align="center">选项</th><th align="center">意义</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><code>-f</code></td><td align="center">指定域位置</td><td align="center">如<code>1,3,5</code>、<code>1-3,5</code>，默认分隔符为制表符，即取出每行被制表符分割的第1、3、5列</td></tr><tr><td align="center"><code>-c</code></td><td align="center">指定字符位置</td><td align="center">如<code>1,3,5</code>，即取出每行第1、3、5个字符</td></tr><tr><td align="center"><code>-d</code></td><td align="center">指定域分割字符</td><td align="center">可以和<code>-f</code>一同使用，后面跟非默认分隔符，空格和其他有特殊意义的字符必须用双括号括起来</td></tr></tbody></table><h2 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h2><h3 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a><code>sort</code>命令</h3><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-d</code></td><td align="center">按字典序排序，忽略标点符号和控制字符</td></tr><tr><td align="center"><code>-f</code></td><td align="center">忽略大小写</td></tr><tr><td align="center"><code>-n</code></td><td align="center">数字以数值排序</td></tr><tr><td align="center"><code>-g</code></td><td align="center">数字以数值排序，且可以处理浮点数</td></tr><tr><td align="center"><code>-o</code></td><td align="center">输出存储在文件中</td></tr><tr><td align="center"><code>-r</code></td><td align="center"><strong>倒序</strong>排序</td></tr><tr><td align="center"><code>-k</code></td><td align="center">按指定字段排序，就是指定第几个域来排序</td></tr><tr><td align="center"><code>-u</code></td><td align="center">去除重复行</td></tr><tr><td align="center"><code>-c</code></td><td align="center">检查是否已经排序好了</td></tr></tbody></table><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>文件权限的意义和目录权限不同：</p><table><thead><tr><th align="center"></th><th align="center">读权限</th><th align="center">写权限</th><th align="center">执行权限</th></tr></thead><tbody><tr><td align="center">文件</td><td align="center">读取内容</td><td align="center">修改内容和删除文件</td><td align="center">作为程序执行</td></tr><tr><td align="center">目录</td><td align="center">列出内容</td><td align="center">创建、删除、重命名文件和子目录</td><td align="center">进入该目录</td></tr></tbody></table><p>文件权限可以使用3位8进制数表示：</p><ul><li><code>r</code>&#x3D;<code>4</code></li><li><code>w</code>&#x3D;<code>2</code></li><li><code>x</code>&#x3D;<code>1</code></li><li><code>-</code>&#x3D;<code>0</code></li></ul><h3 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h3><p>文件和目录的默认权限：</p><ul><li>文件：<code>666</code></li><li>目录：<code>777</code></li></ul><p>可以使用<code>umask</code>掩码表示默认情况下那些权限不会赋予新建的文件、目录，则初始权限为：</p><ul><li>文件：<code>666-umask</code></li><li>目录：<code>777-umask</code></li></ul><p>设置掩码可以用<code>umask &#123;数值&#125;</code>命令实现。</p><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a><code>chmod</code>命令</h3><p>更改文件权限，格式为：<code>chmod &#123;字符串&#125; &#123;文件名&#125;</code>。</p><p>字符串包括：</p><ul><li>对象：<code>u</code>、<code>g</code>、<code>o</code>、<code>a</code>，分别表示用户、组用户、其他用户、所有用户（代替<code>ugo</code>）</li><li>操作符：<code>-</code>、<code>+</code>、<code>=</code>，分别表示赋予权限、取消权限、设置权限</li><li>权限：<code>r</code>、<code>w</code>、<code>x</code>、<code>-</code></li></ul><p>也可以使用<code>chmod &#123;三位八进制数&#125; &#123;文件名&#125;</code>修改权限。</p><h2 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h2><p>Linux将每个文件和一个整数（索引节点号）关联，用来标识每个文件。索引号对应文件的基础信息保存在索引节点表（inode）中，存储在磁盘里。</p><p>Linux打开文件的过程是：</p><ol><li>查找目录项，获得索引节点号</li><li>找到文件的索引节点</li><li>读取元数据</li><li>定位文件数据</li></ol><p>文件名本质上是索引节点号的别名。</p><h1 id="shell-1"><a href="#shell-1" class="headerlink" title="shell"></a>shell</h1><p>shell是一个用户操作界面，是用户和内核交互的桥梁。登录系统后，shell启动；退出时，shell进程结束。</p><p>每个用户都有一个默认shell，通常在<code>/etc/passwd</code>中指定。</p><h2 id="shell的功能"><a href="#shell的功能" class="headerlink" title="shell的功能"></a>shell的功能</h2><ol><li>管道</li><li>IO重定向</li><li>文件名替换</li><li>环境控制</li><li>后台处理</li><li>命令执行</li><li>shell脚本</li></ol><p>注意：shell<strong>不能够装载内核</strong>。</p><h2 id="echo命令和元字符"><a href="#echo命令和元字符" class="headerlink" title="echo命令和元字符"></a><code>echo</code>命令和元字符</h2><p>将消息参数显示在终端上。</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-n</code></td><td align="center">禁止换行（转义符<code>\c</code>也可以）</td></tr><tr><td align="center"><code>-e</code></td><td align="center">解释反斜杠引导的转义符，且转义字符必须用<code>&quot;&quot;</code>括起</td></tr></tbody></table><p>元字符指的是shell中具有特殊含义与用途的字符。消除元字符可以使用：</p><ul><li><code>\</code>：后面的字符按照字面解释</li><li><code>&quot;&quot;</code>：括起来的字符除了<code>$</code>、<code>`</code>和<code>\</code>以外都按照字面解释</li><li><code>&#39;&#39;</code>：括起来的字符全按照字面解释</li></ul><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>shell为了响应用户请求，会将一些信息保存在shell变量中：</p><ul><li>环境变量用于配置和定义系统或用户环境，shell启动时就被创建并被赋予初始值</li><li>局部变量可以供用户定义shell函数或脚本，用户可以自己定义、修改、删除它们</li></ul><h3 id="set、unset命令和变量赋值"><a href="#set、unset命令和变量赋值" class="headerlink" title="set、unset命令和变量赋值"></a><code>set</code>、<code>unset</code>命令和变量赋值</h3><p><code>set</code>可以查看当前使用的所有shell变量，包括局部变量。<code>unset</code>用于删除不需要的变量。</p><p>可以直接使用<code>变量名=变量值</code>的方法赋值。</p><p>变量前加<code>$</code>访问变量值。</p><p>变量可以在命令行中保存复杂的参数或选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ all=-lFa<br>$ <span class="hljs-built_in">ls</span> <span class="hljs-variable">$all</span> myfirst<br><span class="hljs-comment">#等效于 $ ls -lFa myfirst</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ age=32<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$age</span> <span class="hljs-string">&quot;<span class="hljs-variable">$age</span>&quot;</span> <span class="hljs-string">&#x27;$age&#x27;</span><br><span class="hljs-comment">#输出 32 32 $age</span><br></code></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li><code>PATH</code>变量设置shell载入<strong>外部命令</strong>时依次进行查找的目录，路径间分隔符为冒号<code>:</code>，执行内部命令时不会查找，而是直接执行</li><li><code>HOME</code>变量用于保存用户主目录，用于其他命令定位主目录，即<code>/home/用户名</code>，<code>cd</code>命令没有参数时，自动回到<code>HOME</code></li><li><code>PS1</code>设置作为命令提示符的字符串。<code>PS1</code>中可以使用转义序列，需要用<code>&quot;&quot;</code>括起：</li></ul><table><thead><tr><th align="center">序列</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>\u</code></td><td align="center">用户名称</td></tr><tr><td align="center"><code>\h</code></td><td align="center">机器主机名</td></tr><tr><td align="center"><code>\w</code></td><td align="center">工作目录（完整路径）</td></tr><tr><td align="center"><code>\W</code></td><td align="center">工作目录（最底层）</td></tr><tr><td align="center"><code>\$</code></td><td align="center">若用户为<code>root</code>，则显示<code>#</code>，否则显示<code>$</code></td></tr><tr><td align="center"><code>\s</code></td><td align="center">当前运行的shell名称</td></tr><tr><td align="center"><code>\d</code></td><td align="center">当前日期</td></tr><tr><td align="center"><code>\t</code></td><td align="center">当前时间</td></tr><tr><td align="center"><code>\!</code></td><td align="center">命令序号</td></tr></tbody></table><ul><li><code>PS2</code>设置多行输入命令时（尾部写<code>\</code>），第二行及以后的提示符</li><li><code>SHELL</code>设置登录shell的完整路径，默认为<code>/bin/bash</code></li><li><code>PWD</code>保存当前目录的路径</li></ul><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>shell输入输出可以重定向到文件中。</p><ul><li><code>&gt;</code>是覆盖输出重定向，直接覆盖已有的文件或新建一个文件</li><li><code>&gt;&gt;</code>是追加输出重定向，在源文件末尾继续写</li><li><code>2&gt;</code>是标准错误重定向</li><li><code>&lt;</code>是输入重定向，从文件中读取信息</li><li><code>&lt;&lt;</code>是多行输入（Here Document），用于直接从命令行中输入多行数据</li></ul><p>环境变量的值被修改时，修改作用只会作用于当前会话，暂时改变。只有修改配置文件才能永久改变。</p><h2 id="shell元字符"><a href="#shell元字符" class="headerlink" title="shell元字符"></a>shell元字符</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="|元字符"></a><code>|</code>元字符</h3><p><code>|</code>被称为管道，将一个命令的输出传递给令一个命令作为输入，是命令行中实现进程间通信（ICP）的机制</p><p><code>tee</code>命令可以将标准输入的内容同时输出到标准输出和一个或多个文件中，通常以<code>&#123;command&#125; | tee [选项] &#123;（多个）文件名&#125;</code>为用法，把命令的输出同时输出到终端和文件中。</p><h3 id="元字符-1"><a href="#元字符-1" class="headerlink" title="`元字符"></a><code>`</code>元字符</h3><p><code>`</code>告诉shell先执行重音符号括起来的命令，命令的输出替换原来括起来的部分，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> the day is : `<span class="hljs-built_in">date</span>`<br><span class="hljs-comment">#输出 the day is : 2024年11月20日19:56:55</span><br></code></pre></td></tr></table></figure><h3 id="元字符-2"><a href="#元字符-2" class="headerlink" title=";元字符"></a><code>;</code>元字符</h3><p><code>;</code>在命令行中分隔多个命令，从左至右执行。</p><h3 id="元字符-3"><a href="#元字符-3" class="headerlink" title="()元字符"></a><code>()</code>元字符</h3><p>几个命令编在一个括号中，变成一组执行，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ (<span class="hljs-built_in">ls</span>; <span class="hljs-built_in">date</span>; <span class="hljs-built_in">pwd</span>) &gt; newfile<br></code></pre></td></tr></table></figure><h2 id="后台处理"><a href="#后台处理" class="headerlink" title="后台处理"></a>后台处理</h2><p>使用<code>&#123;command&#125; &amp;</code>可以让命令在后台运行。</p><p>多个命令一般可以直接写作<code>&#123;command1&#125; &amp; &#123;command2&#125; &amp;</code>而不需要<code>;</code>分隔，注意<code>&amp;</code>前后有空格。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="sleep命令"><a href="#sleep命令" class="headerlink" title="sleep命令"></a><code>sleep</code>命令</h3><p>使进程延迟多少秒再执行下一个命令。</p><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a><code>ps</code>命令</h3><p>不带选项时显示<strong>当前终端用户</strong>活动进程的状态。</p><table><thead><tr><th align="center">信息</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">PID</td><td align="center">进程ID</td></tr><tr><td align="center">TTY</td><td align="center">控制进程的终端号</td></tr><tr><td align="center">TIME</td><td align="center">进程已运行的时间（秒）</td></tr><tr><td align="center">CMD</td><td align="center">命令名</td></tr></tbody></table><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-f</code></td><td align="center">显示完整的进程列表和命令行</td></tr><tr><td align="center"><code>-e</code></td><td align="center">显示所有进程</td></tr></tbody></table><p>使用<code>ps aux</code>（或<code>-aux</code>，可能报错）和<code>ps -ef</code>命令可以查看所有进程的状态。<code>-ef</code>写作<code>ef</code>可能会被误认为是进程名。</p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a><code>kill</code>命令</h3><p>用于发信号给进程，进行进程通信。</p><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-l</code></td><td align="center">展示信号列表</td></tr></tbody></table><p>命令格式：<code>kill [-信号编号或信号名] &#123;PID&#125;</code>。</p><ul><li><code>9</code>号信号或<code>SIGKILL</code>为强行结束进程</li><li><code>15</code>号信号或<code>SIGTERM</code>为正常结束进程，一般不指定信号则默认发送<code>15</code>号信号</li></ul><p>用户只能终止自己的进程，管理员可以结束所有进程。</p><p><code>PID</code>为<code>0</code>时，指的是当前进程所在组的所有进程，而不是一个单独的进程。</p><h2 id="shell配置文件"><a href="#shell配置文件" class="headerlink" title="shell配置文件"></a>shell配置文件</h2><p>配置文件包含了各种命令和设置，用于定义变量和别名等。</p><p>系统配置文件有：</p><ul><li><code>/etc/profile</code>：设置系统整体环境与自启动程序；登录时执行</li><li><code>/etc/bashrc</code>：设置系统整体函数与缩写；打开bash时执行</li></ul><p>用户配置文件有：</p><ul><li><code> ~ /.bash_profile</code>：设置登录用户的bash环境；执行<code> ~ /.bashrc</code></li><li><code> ~ /.bashrc</code>：设置当前用户的bash环境；执行<code>/etc/bashrc</code></li><li><code> ~ /.bash_logout</code>：用户退出bash时执行</li></ul><p>关于非登录shell和登录shell：</p><ul><li>登录shell是通过了账户密码环节的启动的shell，执行<code> ~ /.bash_profile</code>、<code> ~ /.bash_login</code>或<code> ~ /.profile</code></li><li>非登录shell是在已登录的shell中打开新的shell时启动的，执行<code> ~ /.bashrc</code></li></ul><h3 id="etc-profile文件"><a href="#etc-profile文件" class="headerlink" title="/etc/profile文件"></a><code>/etc/profile</code>文件</h3><p>是一个ASCII文件，定义全局环境变量，如<code>PATH</code>等。</p><p>也可以设置<code>umask</code>值。</p><p><code>/etc/profile.d</code>是一个文件夹，保存应用程序所需的启动脚本，如颜色、语言等。</p><h3 id="etc-bashrc文件"><a href="#etc-bashrc文件" class="headerlink" title="/etc/bashrc文件"></a><code>/etc/bashrc</code>文件</h3><p>用于配置系统函数和缩写等，用户每次登陆环境都被读取，执行<code>.bashrc</code>文件：配置用户专用的bash环境。</p><p><code>.bash_logout</code>在退出bash时执行。</p><h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a><code>export</code>命令</h3><p>使一系列shell变量用于子shell。</p><h3 id="alias命令"><a href="#alias命令" class="headerlink" title="alias命令"></a><code>alias</code>命令</h3><p>为命令起一个名字：<code>alias &#123;别名&#125;=&#123;命令名&#125;</code>，如果有空格则要用<code>&quot;&quot;</code>括起来。没有参数则显示已定义的别名。</p><p>使用<code>unalias</code>取消别名。</p><h1 id="gcc和git"><a href="#gcc和git" class="headerlink" title="gcc和git"></a>gcc和git</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>gcc是GNU C编译器，g++是C++编译器，它们执行编译的步骤是：</p><ol><li>预处理：把头文件展开，去掉注释，替换宏，条件编译，产生<code>.i</code>文件（选项<code>-E</code>）</li><li>编译：转换为汇编语言，产生<code>.s</code>文件（选项<code>-S</code>）</li><li>汇编：转换为机器语言，产生<code>.o</code>文件（选项<code>-c</code>）</li><li>链接：链接目标代码，生成可执行程序（选项<code>-o</code>，以指定输出的文件名，默认为<code>.out</code>）</li></ol><h2 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h2><p>是GNU工程化编译工具，用于编译同一项目中众多相互关联的源码文件，将维护命令和编译命令写在<code>makefile</code>文件中，实现合理编译。</p><p>主要解决的问题有：</p><ol><li>大项目源码维护</li><li>减少重复编译时间：自动判断哪些代码修改过，只对改动后的代码进行编译</li></ol><p><code>makefile</code>语法规则：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">目标<span class="hljs-number">1</span>:依赖文件列表<br>&lt;<span class="hljs-literal">tab</span>&gt;命令列表<br><br><span class="hljs-comment">//目标：要产生的文件名称或动作的名称</span><br><span class="hljs-comment">//依赖文件：用于产生目标的输入文件</span><br><span class="hljs-comment">//命令：make执行的动作</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">cal:</span> cal.o <span class="hljs-keyword">sub</span>.o sum.o<br><span class="hljs-meta"># 要产生cal文件，依赖文件为cal.o，sub.o，sum.o</span><br>    gcc cal.o <span class="hljs-keyword">sub</span>.o sum.o -o cal<br>    <span class="hljs-meta"># 动作</span><br><br><span class="hljs-symbol">clean:</span> <br>    rm -rf *.o<br></code></pre></td></tr></table></figure><p><code>make</code>命令的用法：<code>make [-f file] [targets]</code>。</p><p>make默认会在工作目录中寻找<code>makefile</code>文件作为输入，而<code>-f</code>指定其以外的作为输入。</p><p>如果没有指定的目标，则<code>make</code>会默认实现<code>makefile</code>的第一个目标然后退出，可以指定一个或多个目标，用空格分隔。</p><p>例如<code>make clean</code>命令，就是执行上方的<code>clean</code>目标。</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git是Linus为了更好管理Linux内核开发而开发的开源分布式版本控制系统。</p><h3 id="配置邮箱和用户名"><a href="#配置邮箱和用户名" class="headerlink" title="配置邮箱和用户名"></a>配置邮箱和用户名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.name &#123;用户名&#125;<br><span class="hljs-comment"># 配置用户名</span><br>git config user.email &#123;邮箱&#125;<br><span class="hljs-comment"># 配置邮箱</span><br></code></pre></td></tr></table></figure><p>这是仓库级配置，只会影响本仓库。</p><p>全局配置如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name &#123;用户名&#125;<br>git config --global user.email &#123;邮箱&#125;<br></code></pre></td></tr></table></figure><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p><code>git clone &#123;远程仓库链接&#125;</code>。</p><p>克隆成功后用户会在本地拥有一个完全相同的git副本。</p><h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><ol><li>将文件添加到暂存区：<code>git add &#123;目录或.&#125;</code></li><li>提交暂存区的修改到本地仓库：<code>git commit -m &quot;说明信息&quot;</code></li></ol><h3 id="推送和拉取修改"><a href="#推送和拉取修改" class="headerlink" title="推送和拉取修改"></a>推送和拉取修改</h3><p><code>git push &#123;远程仓库&#125; &#123;本地分支&#125;</code>将本地分支推送到远程仓库。</p><p><code>git pull &#123;远程仓库&#125; &#123;远程分支&#125;</code>将远程分支的更改合并到本地分支。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是一种软件项目管理不同版本的方法。可以通过创建分支将项目分割成独立的开发线，每个分支可以拥有自己的代码库和开发人员。</p><p>分支操作有：</p><ul><li>列出分支 <code>git branch</code></li><li>创建分支 <code>git branch &#123;分支名&#125;</code></li><li>切换到分支 <code>git chechout &#123;分支名&#125;</code></li><li>删除分支 <code>git branch -d &#123;分支名&#125;</code></li></ul><h3 id="其他git操作"><a href="#其他git操作" class="headerlink" title="其他git操作"></a>其他git操作</h3><ul><li>查看当前状态 <code>git status</code></li><li>查看提交历史 <code>git log</code></li><li>查看和修改配置 <code>git config</code></li></ul><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><p>shell脚本无需编译，易于编写。一个shell脚本会将命令一次交给shell执行，一次一条，直到停止或出错。以<code>#</code>为注释。</p><p>shell的程序文件被称为<strong>脚本</strong>、<strong>shell过程</strong>或<strong>shell脚本</strong>。</p><p>执行脚本有三种方式：</p><ul><li>启动新的shell，例如<code>sh hello.sh</code>或<code>ksh hello.sh</code>。</li><li>使用当前shell执行，运用<code>.</code>命令或<code>source</code>命令，例如<code>. hello.sh</code>和<code>source hello.sh</code></li><li>将其转换为可执行文件，如<code>chmod u+x hello.sh</code>，然后再使用<code>./hello.sh</code></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>shell变量不需要先定义后使用，不支持数据类型，赋值都解释为字符串。</p><p>变量保存在内存中，直到其所在的shell进程结束或被<code>unset</code>清除。</p><p>直接将两个字符串放在一起就能够完成字符串拼接（注意被拼接的成员间不能有空格）</p><p>shell没有内部运算符供算术运算。</p><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a><code>expr</code>命令</h3><p>用于进行算术运算。运算符有：<code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>、<code>\%</code>，运算后输出到标准输出。符号左右要有空格，且参数只能是整数。</p><p><code>expr</code>中使用变量，需要用<code>$</code>取值。</p><p><code>expr</code>中也有逻辑运算符，写作<code>=</code>、<code>!=</code>、<code>\&lt;=</code>、<code>\&gt;=</code>、<code>\&lt;</code>、<code>\&gt;</code>。</p><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a><code>let</code>命令</h3><p>进行整数计算，并将表达式的值赋给变量。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> x=x+1<br></code></pre></td></tr></table></figure><p>运算符左右不需要空格，且无需<code>$</code>取值，可以直接使用。运算符也不需要转义符了。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="(())运算符"></a><code>(())</code>运算符</h3><p>支持将算术赋值表达式放到双括号中。变量用法和<code>let</code>一样。</p><h2 id="命令行输入"><a href="#命令行输入" class="headerlink" title="命令行输入"></a>命令行输入</h2><p>命令行参数又称为位置变量，是用户输入命令后在后面跟着的数据，使用空格分隔，传送给程序。按照顺序，参数会被命名为<code>$0</code>到<code>$9</code>。</p><table><thead><tr><th align="center">位置变量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>$0</code></td><td align="center">脚本文件名</td></tr><tr><td align="center"><code>$1</code> ~ <code>$9</code></td><td align="center">第1 ~ 9个命令行参数</td></tr><tr><td align="center"><code>$#</code></td><td align="center">命令行参数的个数</td></tr><tr><td align="center"><code>$@</code></td><td align="center">所有命令行参数，参数加引号时每个参数会被认为是一个字段（推荐使用）</td></tr><tr><td align="center"><code>$*</code></td><td align="center">所有命令行参数，参数加引号时每个参数都被合并成一个字符串</td></tr><tr><td align="center"><code>$?</code></td><td align="center">上一个命令返回的结果</td></tr><tr><td align="center"><code>$$</code></td><td align="center">正在执行进程的PID</td></tr></tbody></table><p>命令行参数多于9个时，后面的会被忽略，但是仍可以用<code>$*</code>获得。</p><p>使用<code>set</code>可以给<code>$1</code> ~ <code>$9</code>依次赋值。</p><h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a><code>read</code>命令</h3><p>从标准输入中读入字符串，存入变量中。若字符串数量多于变量的数量，则最后一个变量会存下剩下所有的字符串。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><code>if-then</code>结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition ]<br><span class="hljs-comment"># 注意条件前后加空格</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><code>if-then-else</code>结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><code>if-then-elif</code>结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition1 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">elif</span> [ condition2 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">elif</span> [ condition3 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a><code>test</code>命令</h3><p>条件表达式<code>[ condition ]</code>等效于<code>test condition</code>命令，真返回<code>0</code>，否则返回非<code>0</code>。注意，<code>test</code>命令中字符串必须使用<code>&quot;&quot;</code>括起。一般字符串的写法是：<code>test [选项] &#123;字符串&#125;</code>。</p><p>字符串比较与检测：</p><table><thead><tr><th align="center">操作符</th><th align="center">示例</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>=</code></td><td align="center"><code>$str1 = str2</code></td><td align="center">相同返回<code>0</code></td></tr><tr><td align="center"><code>!=</code></td><td align="center"><code>$str1 != str2</code></td><td align="center">不同返回<code>0</code></td></tr><tr><td align="center"><code>-n</code></td><td align="center"><code>-n $str</code></td><td align="center">包含字符返回<code>0</code></td></tr><tr><td align="center"><code>-z</code></td><td align="center"><code>-z $str</code></td><td align="center">不包含字符（空串）返回<code>0</code></td></tr></tbody></table><p>数值比较：</p><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>-eq</code></td><td align="center">相等返回<code>0</code></td></tr><tr><td align="center"><code>-ne</code></td><td align="center">不等返回<code>0</code></td></tr><tr><td align="center"><code>-gt</code></td><td align="center">左大于右返回<code>0</code></td></tr><tr><td align="center"><code>-ge</code></td><td align="center">左大于等于右返回<code>0</code></td></tr><tr><td align="center"><code>-lt</code></td><td align="center">左小于右返回<code>0</code></td></tr><tr><td align="center"><code>-le</code></td><td align="center">左小于等于右返回<code>0</code></td></tr></tbody></table><p><code>test</code>也可以检测文件属性：</p><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>-r</code></td><td align="center">文件是否存在且可读</td></tr><tr><td align="center"><code>-w</code></td><td align="center">文件是否存在且可写</td></tr><tr><td align="center"><code>-s</code></td><td align="center">文件是否存在且长度非零</td></tr><tr><td align="center"><code>-f</code></td><td align="center">文件是否存在且是普通文件</td></tr><tr><td align="center"><code>-d</code></td><td align="center">文件是否存在且是目录</td></tr></tbody></table><p>例如，检验<code>file1</code>是否为普通文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">file1=<span class="hljs-string">&quot;file1&quot;</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;存在&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><code>test</code>命令也可以使用逻辑运算符组合条件，例如<code>test &#123;表达式1&#125; &#123;运算符&#125; &#123;表达式2&#125; ... </code>，等效于<code>[ &#123;表达式1&#125; &#123;运算符&#125; &#123;表达式2&#125; ... ]</code>。</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>a</code></td><td align="center">与</td></tr><tr><td align="center"><code>o</code></td><td align="center">或</td></tr><tr><td align="center"><code>!</code></td><td align="center">非</td></tr></tbody></table><p>多个<code>test</code>也能组合：<code>test &#123;表达式1&#125; &#123;逻辑运算符&#125; test &#123;表达式2&#125;</code>，等效于<code>[ 表达式1 ] &#123;逻辑运算符&#125; [ 表达式2 ]</code>。</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>&amp;&amp;</code></td><td align="center">与</td></tr><tr><td align="center">&#96;</td><td align="center"></td></tr><tr><td align="center"><code>!</code></td><td align="center">非</td></tr></tbody></table><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> 变量值 <span class="hljs-keyword">in</span><br>&#123;值1&#125;)<br>    <span class="hljs-built_in">command</span><br>    ;;<br>&#123;值2&#125;)<br>    <span class="hljs-built_in">command</span><br>    ;;<br>*)<br>    <span class="hljs-built_in">command</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> 变量<br><span class="hljs-keyword">in</span> 取值列表<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>取值列表可以有很多种：</p><ul><li>列出所有成员，例如<code>in file1 file2 file3</code></li><li>等差数列，例如<code>&#123;起始值..结束值..步长&#125;</code>（步长为1可省略）或<code>seq 起始值 步长 结束值</code>（步长或起始值为1均可省略）</li><li>命令的执行结果</li></ul><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [ condition ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>只要<code>condition</code>为<code>0</code>就一直执行。</p><h3 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h3><p>写法和<code>while</code>一样，但是它是只要<code>condition</code>不为<code>0</code>就一直执行。</p><h3 id="终止控制"><a href="#终止控制" class="headerlink" title="终止控制"></a>终止控制</h3><ul><li><code>continue</code>结束本轮循环，进入下一次循环</li><li><code>break</code>结束循环</li></ul><h2 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h2><p><code>exit</code>命令可以立刻终止程序运行，格式为<code>exit n</code>，<code>n</code>为返回码。</p><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="磁盘和文件系统管理"><a href="#磁盘和文件系统管理" class="headerlink" title="磁盘和文件系统管理"></a>磁盘和文件系统管理</h2><p>磁盘和磁盘分区是文件系统管理的基础，以设备文件的形式存在，并允许用户通过系统工具，如<code>mkfs</code>和<code>mount</code>进行操作，例如创建、挂载文件系统和格式化等。</p><p>磁盘和磁盘分区设备文件位于<code>/dev</code>目录下，命名为<code>xxyn</code>：</p><ul><li><code>xx</code>表示设备类型<ul><li><code>hd</code>：IDE磁盘</li><li><code>sd</code>：SATA等磁盘</li><li><code>vd</code>：虚拟磁盘</li></ul></li><li><code>y</code>表示设备编号，<code>a</code>为第1个，以此类推</li><li><code>n</code>为磁盘分区号<ul><li><code>1</code> ~ <code>4</code>为主分区或扩展分区</li><li><code>5</code>以后为逻辑分区</li></ul></li></ul><p><code>/dev/xxy</code>是一个整体的磁盘，<code>dev/xxyn</code>是这个磁盘上的一个分区。</p><h3 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a><code>fdisk</code>命令</h3><p>对磁盘进行分区。语法为：<code>fdisk &#123;磁盘设备名&#125;</code>。使用<code>-l</code>选项可以显示磁盘分区表信息。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /dev/sdb<br><span class="hljs-comment"># 在第二块sd设备上创建分区</span><br></code></pre></td></tr></table></figure><h3 id="lsblk命令"><a href="#lsblk命令" class="headerlink" title="lsblk命令"></a><code>lsblk</code>命令</h3><p>用于列出块设备信息，用途与<code>fdisk -l</code>类似。</p><h3 id="blkid命令"><a href="#blkid命令" class="headerlink" title="blkid命令"></a><code>blkid</code>命令</h3><p>用于查看块设备的文件系统类型，<code>LABEL</code>、<code>UUID</code>等信息。</p><h3 id="mkfs命令"><a href="#mkfs命令" class="headerlink" title="mkfs命令"></a><code>mkfs</code>命令</h3><p>用于在磁盘分区上创建文件系统，语法为<code>mkfs [选项] &#123;磁盘分区名&#125;</code>，选项<code>-t</code>用于创建执行的文件系统类型。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs -t ext4 /dev/sdb1<br><span class="hljs-comment"># 分区类型指定为ext4</span><br></code></pre></td></tr></table></figure><h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a><code>mount</code>命令</h3><p>用于挂载磁盘分区，语法为<code>mount [选项] &#123;磁盘分区文件&#125; &#123;目录&#125;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -t ext4 /dev/sdb1 /mnt/mdisk<br><span class="hljs-comment"># 将/dev/sdb1挂载到/mnt/mdisk，文件系统类型指定为ext4</span><br><br>mount<br><span class="hljs-comment"># 查看已挂载的文件系统</span><br><br>mount -a<br><span class="hljs-comment"># 将etc/fstab中所有的文件系统挂载</span><br></code></pre></td></tr></table></figure><h3 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a><code>umount</code>命令</h3><p>用于卸载文件系统，<code>umount &#123;设备文件名/挂载文件系统的目录名&#125;</code>。</p><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a><code>df</code>命令</h3><p>列出磁盘分区空间使用情况，<code>-h</code>选项以易读方式显示。</p><h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a><code>du</code>命令</h3><p>显示目录的磁盘使用情况。<code>-a</code>选项显示目录中目录和文件的占用情况。</p><h2 id="归档和压缩：tar工具"><a href="#归档和压缩：tar工具" class="headerlink" title="归档和压缩：tar工具"></a>归档和压缩：<code>tar</code>工具</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>使用<code>tar -cvf &#123;目标文件名&#125; &#123;（多个）文件名或目录&#125;</code>将一组文件打包到一个文件中。</p><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-c</code></td><td align="center">创建存档文件</td></tr><tr><td align="center"><code>-v</code></td><td align="center">显示打包文件信息，列出里面都有些什么</td></tr><tr><td align="center"><code>-f</code></td><td align="center">指定生成的存档的文件名</td></tr></tbody></table><h3 id="查看打包文件"><a href="#查看打包文件" class="headerlink" title="查看打包文件"></a>查看打包文件</h3><p>使用<code>tar -tvf &#123;文件名&#125;</code>查看包中文件的信息。</p><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-t</code></td><td align="center">列出存档中的内容</td></tr><tr><td align="center"><code>-v</code></td><td align="center">显示打包文件的<strong>详细信息</strong></td></tr><tr><td align="center"><code>-f</code></td><td align="center">指定存档的文件名</td></tr></tbody></table><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>使用<code>tar -xvf &#123;文件名&#125;</code>解包。</p><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-x</code></td><td align="center">还原被打包文件</td></tr><tr><td align="center"><code>-v</code></td><td align="center">显示打包文件的信息</td></tr><tr><td align="center"><code>-f</code></td><td align="center">指定存档的文件名</td></tr></tbody></table><p>使用<code>tar -xvf &#123;文件名&#125; &#123;特定文件名&#125;</code>可以只解出包中特定的那个文件，并将其信息显示出来。</p><h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><p>如果同时打包并压缩，可以用<code>-z</code>、<code>-Z</code>、<code>-j</code>选项配合上面的命令一起使用。</p><ul><li><code>tar -cvzf &#123;filename.tar.gz&#125; &#123;files&#125;</code>：打包压缩</li><li><code>tar -xvzf &#123;filename.tar.gz&#125;</code>：解压缩并解包</li></ul><p><code>gzip</code>和<code>gunzip</code>也可以进行压缩或解压，但是往往使用<code>tar</code>命令一次完成压缩或解压。</p><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><h3 id="at命令"><a href="#at命令" class="headerlink" title="at命令"></a><code>at</code>命令</h3><p>用于在指定时间执行一个或一组命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">at 04 tomorrow<br>at &gt; <span class="hljs-built_in">sort</span> BIG_FILE<br><span class="hljs-comment"># 未指定输出文件，将以电子邮件将输出信息传送给用户</span><br>at &gt; [Ctrl+d]<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-l</code></td><td align="center">列出所有<code>at</code>命令提交的作业</td></tr><tr><td align="center"><code>-m</code></td><td align="center">作业完成时向用户发送一条确认信息</td></tr><tr><td align="center"><code>-r</code></td><td align="center">从调度作业中删除指定的作业号</td></tr></tbody></table><h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a><code>crontab</code>命令</h3><p>配置用户自己的定时任务，语法为<code>crontab [-u 用户名] file（将制定文件中的任务加载到crontab中）</code>或<code>crontab [-u 用户名] &#123;-l | -r | -e&#125;</code>。</p><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-l</code></td><td align="center">列出定时任务的详细内容</td></tr><tr><td align="center"><code>-r</code></td><td align="center">删除用户的定时任务</td></tr><tr><td align="center"><code>-e</code></td><td align="center">编辑用户的定时任务</td></tr><tr><td align="center"><code>-u</code></td><td align="center">设定用户的定时任务</td></tr></tbody></table><p><code>crontab</code>可以设置周期性执行的任务，语法为<code>f1 f2 f3 f4 f5 command</code>。</p><table><thead><tr><th align="center">参数</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>f1</code></td><td align="center">分钟（<code>0</code> ~ <code>59</code>）</td></tr><tr><td align="center"><code>f2</code></td><td align="center">小时（<code>0</code> ~ <code>23</code>）</td></tr><tr><td align="center"><code>f3</code></td><td align="center">日期（<code>1</code> ~ <code>31</code>）</td></tr><tr><td align="center"><code>f4</code></td><td align="center">月份（<code>1</code> ~ <code>12</code>）</td></tr><tr><td align="center"><code>f5</code></td><td align="center">星期几（<code>0</code> ~ <code>6</code>），<code>0</code>代表星期天</td></tr><tr><td align="center"><code>command</code></td><td align="center">需要执行的命令或脚本文件</td></tr></tbody></table><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>用户分为根账户、系统账户、普通用户账户。</p><ul><li>根用户：<code>root</code>，不受约束的控制系统</li><li>系统账户：对系统特定组件进行操作的用户</li><li>普通用户账户：提供对系统的交互性访问，对关键的系统文件和目录访问权限有限</li></ul><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>组是具有相同特性的用户的集合，是对用户进行资源分配的一种方式，按照性质划分为系统组和私有组。</p><p>组长好不能登录计算机，设置的目的仅仅是便于权限的统一组织和分配。</p><h3 id="账号配置文件"><a href="#账号配置文件" class="headerlink" title="账号配置文件"></a>账号配置文件</h3><ul><li><code>etc/passwd</code>保存用户账户信息</li><li><code>etc/shadow</code>保存用户密码信息</li><li><code>etc/group</code>保存组账户信息</li></ul><p><code>etc/passwd</code>文件<code>root</code>用户可读可写，其他用户可读，每行一个记录，每个记录7个字段，用冒号分隔：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;用户名&#125;</span><span class="language-xml">:</span><span class="hljs-template-variable">&#123;密码flag，x表示设置了密码，空表示无密码&#125;</span><span class="language-xml">:</span><span class="hljs-template-variable">&#123;用户ID&#125;</span><span class="language-xml">:</span><span class="hljs-template-variable">&#123;默认组ID&#125;</span><span class="language-xml">:</span><span class="hljs-template-variable">&#123;用户详细信息&#125;</span><span class="language-xml">:</span><span class="hljs-template-variable">&#123;用户主目录&#125;</span><span class="language-xml">:</span><span class="hljs-template-variable">&#123;登录时启动的shell&#125;</span><br></code></pre></td></tr></table></figure><p><code>useradd</code>命令可以创建用户账户。</p><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>-u</code></td><td align="center">指定用户号</td></tr><tr><td align="center"><code>-g</code></td><td align="center">指定默认组</td></tr><tr><td align="center"><code>-s</code></td><td align="center">指定默认shell</td></tr></tbody></table><p><code>usermod</code>命令可以修改用户账户。</p><p><code>userdel</code>命令可以删除用户账户。</p><h3 id="身份切换"><a href="#身份切换" class="headerlink" title="身份切换"></a>身份切换</h3><p><code>su</code>命令可以切换身份：<code>su [-]（同时切换到新工作环境） [用户名]</code>。</p><p>平级升级切换需要输入密码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二手房房价数据的爬取、清洗、可视化、预测</title>
    <link href="/2024/crawer/"/>
    <url>/2024/crawer/</url>
    
    <content type="html"><![CDATA[<h1 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h1><h2 id="爬虫和人机验证"><a href="#爬虫和人机验证" class="headerlink" title="爬虫和人机验证"></a>爬虫和人机验证</h2><p>利用Selenium库和Edge Driver可唤起实体浏览器，并捕获网站中的<code>Element</code>元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python">count=<span class="hljs-number">0</span><br>dataList=[]<br><span class="hljs-comment"># 浏览器可无头化：</span><br><span class="hljs-comment"># options=webdriver.EdgeOptions()</span><br><span class="hljs-comment"># options.add_argument(&#x27;--headless&#x27;)</span><br><span class="hljs-comment"># driver = webdriver.Edge(options=options)</span><br><span class="hljs-comment"># driver = webdriver.Edge()</span><br>driver = webdriver.Edge()<br>flag=<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>):    <span class="hljs-comment"># 爬取第几页</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取第&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;页&quot;</span>)<br>    url=baseUrl+<span class="hljs-built_in">str</span>(i)<br>    driver.get(url)<br>    <span class="hljs-keyword">if</span> flag:<br>        time.sleep(<span class="hljs-number">10</span>)<br>        flag=<span class="hljs-number">0</span><br>    <span class="hljs-built_in">print</span>(driver.title)<br>    item0=driver.find_elements(By.CLASS_NAME,<span class="hljs-string">&quot;lj-lazy&quot;</span>)<br>    item1=driver.find_elements(By.CLASS_NAME,<span class="hljs-string">&quot;title&quot;</span>)<br>    item2=driver.find_elements(By.CLASS_NAME,<span class="hljs-string">&quot;positionInfo&quot;</span>)<br>    item3=driver.find_elements(By.CLASS_NAME,<span class="hljs-string">&quot;houseInfo&quot;</span>)<br>    item4=driver.find_elements(By.CLASS_NAME,<span class="hljs-string">&quot;totalPrice &quot;</span>)<br>    item5=driver.find_elements(By.CLASS_NAME,<span class="hljs-string">&quot;unitPrice &quot;</span>)<br>    item6 = driver.find_elements(By.CLASS_NAME, <span class="hljs-string">&quot;followInfo&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(item2)):<br>        data=[]<br>        data.append(item1[i].text)  <span class="hljs-comment"># 概况</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&quot;</span>+<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;个：&quot;</span>+item1[i].text)<br>        data.append(item2[i].text.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 小区名</span><br>        data.append(item2[i].text.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 所属地区</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>))&gt;<span class="hljs-number">0</span>:<br>            data.append(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 其他信息</span><br>        <span class="hljs-keyword">else</span>:<br>            data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>))&gt;<span class="hljs-number">1</span>:<br>            data.append(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">else</span>:<br>            data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>))&gt;<span class="hljs-number">2</span>:<br>            data.append(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">else</span>:<br>            data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>))&gt;<span class="hljs-number">3</span>:<br>            data.append(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">3</span>])<br>        <span class="hljs-keyword">else</span>:<br>            data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>))&gt;<span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">4</span>].split(<span class="hljs-string">&quot;(&quot;</span>))&gt;<span class="hljs-number">0</span>:<br>                data.append(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">4</span>].split(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">4</span>].split(<span class="hljs-string">&quot;(&quot;</span>))&gt;<span class="hljs-number">1</span>:<br>                    amount = re.search(<span class="hljs-string">r&#x27;共(\d+)层&#x27;</span>, item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">4</span>].split(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">if</span> amount:<br>                        <span class="hljs-comment"># 提取第一个捕获组的内容</span><br>                        number = amount.group(<span class="hljs-number">1</span>)<br>                        data.append(number)<br>                    <span class="hljs-keyword">else</span>:<br>                        data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>))&gt;<span class="hljs-number">5</span>:<br>            data.append(item3[i].text.split(<span class="hljs-string">&quot;|&quot;</span>)[<span class="hljs-number">5</span>])<br>        <span class="hljs-keyword">else</span>:<br>            data.append(<span class="hljs-string">&#x27;未知数据&#x27;</span>)<br><br>        data.append(item4[i].text.split()[<span class="hljs-number">0</span>]+item4[i].text.split()[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 总价</span><br>        data.append(item5[i].text)  <span class="hljs-comment"># 单价</span><br>        data.append(item6[i].text.split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">0</span>])<br>        data.append(item6[i].text.split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">1</span>])<br>        data.append(item0[i].get_attribute(<span class="hljs-string">&quot;data-original&quot;</span>))  <span class="hljs-comment"># 图片</span><br>        dataList.append(data)<br>        count=count+<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;完成&quot;</span>)<br>driver.quit()<br></code></pre></td></tr></table></figure><p>倘若遇到人机验证，可<code>time.sleep()</code>给我们手动输入验证码的时间。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>利用xlwt库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params">dataList,savepath,count</span>):<br>    book = xlwt.Workbook(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>,style_compression=<span class="hljs-number">0</span>)<br>    sheet = book.add_sheet(<span class="hljs-string">&#x27;二手房&#x27;</span>, cell_overwrite_ok=<span class="hljs-literal">True</span>)<br>    col = (<span class="hljs-string">&quot;概况&quot;</span>,<span class="hljs-string">&quot;小区名&quot;</span>,<span class="hljs-string">&quot;所属地区&quot;</span>,<span class="hljs-string">&quot;户型&quot;</span>,<span class="hljs-string">&quot;面积&quot;</span>,<span class="hljs-string">&quot;朝向&quot;</span>,<span class="hljs-string">&quot;装潢&quot;</span>,<span class="hljs-string">&quot;楼层高低&quot;</span>,<span class="hljs-string">&quot;总楼层数&quot;</span>,<span class="hljs-string">&quot;建筑类型&quot;</span>,<span class="hljs-string">&quot;总价&quot;</span>,<span class="hljs-string">&quot;单价&quot;</span>,<span class="hljs-string">&quot;关注度&quot;</span>,<span class="hljs-string">&quot;发布时间&quot;</span>,<span class="hljs-string">&quot;图片地址&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">15</span>):<br>        sheet.write(<span class="hljs-number">0</span>,i,col[i])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,count):<br>        data = dataList[i]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">15</span>):<br>            sheet.write(i+<span class="hljs-number">1</span>,j,data[j])<br>    book.save(savepath)<br></code></pre></td></tr></table></figure><h2 id="多线程化"><a href="#多线程化" class="headerlink" title="多线程化"></a>多线程化</h2><p>直接调用库即可，可启动多个浏览器进行爬虫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">page_start,pages_end, savepath</span>):<br>    all_data = []<br><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=(pages_end-page_start+<span class="hljs-number">1</span>)) <span class="hljs-keyword">as</span> executor:<br>        futures = [executor.submit(scrape_page, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(page_start, pages_end + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>            page_data = future.result()<br>            all_data.extend(page_data)<br><br>    saveData(all_data, savepath)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功抓取 <span class="hljs-subst">&#123;pages_end-page_start+<span class="hljs-number">1</span>&#125;</span> 页数据并保存到 <span class="hljs-subst">&#123;savepath&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p>主要调用Pandas和Numpy：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">column_names = [<span class="hljs-string">&#x27;概况&#x27;</span>,<span class="hljs-string">&#x27;小区名&#x27;</span>,<span class="hljs-string">&#x27;所属地区&#x27;</span>,<span class="hljs-string">&#x27;户型&#x27;</span>,<span class="hljs-string">&#x27;面积&#x27;</span>,<span class="hljs-string">&#x27;朝向&#x27;</span>,<span class="hljs-string">&#x27;装潢&#x27;</span>,<span class="hljs-string">&#x27;楼层高低&#x27;</span>,<span class="hljs-string">&#x27;总楼层数&#x27;</span>,<span class="hljs-string">&#x27;建筑类型&#x27;</span>,<span class="hljs-string">&#x27;总价&#x27;</span>,<span class="hljs-string">&#x27;单价&#x27;</span>,<span class="hljs-string">&#x27;关注度&#x27;</span>,<span class="hljs-string">&#x27;发布时间&#x27;</span>,<span class="hljs-string">&#x27;图片地址&#x27;</span>]<br>data = pd.read_excel(<span class="hljs-string">&#x27;二手房.xls&#x27;</span>, usecols=column_names, engine=<span class="hljs-string">&#x27;xlrd&#x27;</span>)<br>data.head()<br>df=pd.DataFrame(data)<br>df[<span class="hljs-string">&#x27;概况&#x27;</span>]=df[<span class="hljs-string">&#x27;概况&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27; &#x27;</span>)<br>df[<span class="hljs-string">&#x27;小区名&#x27;</span>]=df[<span class="hljs-string">&#x27;小区名&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;所属地区&#x27;</span>]=df[<span class="hljs-string">&#x27;所属地区&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;户型&#x27;</span>]=df[<span class="hljs-string">&#x27;户型&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;面积&#x27;</span>]=df[<span class="hljs-string">&#x27;面积&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;面积&#x27;</span>]=df[<span class="hljs-string">&#x27;面积&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;平米&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;朝向&#x27;</span>]=df[<span class="hljs-string">&#x27;朝向&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>.strip)<br>df[<span class="hljs-string">&#x27;装潢&#x27;</span>]=df[<span class="hljs-string">&#x27;装潢&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;楼层高低&#x27;</span>]=df[<span class="hljs-string">&#x27;楼层高低&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;建筑类型&#x27;</span>]=df[<span class="hljs-string">&#x27;建筑类型&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;总价&#x27;</span>]=df[<span class="hljs-string">&#x27;总价&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;万&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;单价&#x27;</span>]=df[<span class="hljs-string">&#x27;单价&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;单价&#x27;</span>]=df[<span class="hljs-string">&#x27;单价&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;元/平&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;关注度&#x27;</span>]=df[<span class="hljs-string">&#x27;关注度&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;人关注&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;关注度&#x27;</span>]=df[<span class="hljs-string">&#x27;关注度&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;发布时间&#x27;</span>]=df[<span class="hljs-string">&#x27;发布时间&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>df[<span class="hljs-string">&#x27;发布时间&#x27;</span>] = df[<span class="hljs-string">&#x27;发布时间&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;以前发布&#x27;</span>, <span class="hljs-string">&#x27;前&#x27;</span>)<br>df[<span class="hljs-string">&#x27;发布时间&#x27;</span>] = df[<span class="hljs-string">&#x27;发布时间&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;前发布&#x27;</span>, <span class="hljs-string">&#x27;前&#x27;</span>)<br>df[<span class="hljs-string">&#x27;总楼层数&#x27;</span>] = df[<span class="hljs-string">&#x27;总楼层数&#x27;</span>].astype(<span class="hljs-built_in">int</span>, errors=<span class="hljs-string">&#x27;ignore&#x27;</span>)<br>df = df.astype(&#123;<span class="hljs-string">&#x27;单价&#x27;</span>: <span class="hljs-built_in">float</span>, <span class="hljs-string">&#x27;总价&#x27;</span>: <span class="hljs-built_in">float</span>, <span class="hljs-string">&#x27;面积&#x27;</span>: <span class="hljs-built_in">float</span> ,<span class="hljs-string">&#x27;关注度&#x27;</span>: <span class="hljs-built_in">int</span>&#125;)<br>df = df.drop_duplicates(subset=[<span class="hljs-string">&#x27;概况&#x27;</span>,<span class="hljs-string">&#x27;小区名&#x27;</span>,<span class="hljs-string">&#x27;所属地区&#x27;</span>,<span class="hljs-string">&#x27;户型&#x27;</span>,<span class="hljs-string">&#x27;面积&#x27;</span>,<span class="hljs-string">&#x27;朝向&#x27;</span>,<span class="hljs-string">&#x27;装潢&#x27;</span>,<span class="hljs-string">&#x27;楼层高低&#x27;</span>,<span class="hljs-string">&#x27;总楼层数&#x27;</span>,<span class="hljs-string">&#x27;建筑类型&#x27;</span>,<span class="hljs-string">&#x27;总价&#x27;</span>,<span class="hljs-string">&#x27;单价&#x27;</span>,<span class="hljs-string">&#x27;关注度&#x27;</span>,<span class="hljs-string">&#x27;发布时间&#x27;</span>,<span class="hljs-string">&#x27;图片地址&#x27;</span>])<br>df = df[df[<span class="hljs-string">&#x27;总楼层数&#x27;</span>] != <span class="hljs-string">&#x27;未知数据&#x27;</span>]<br><span class="hljs-comment"># print(df[&#x27;总楼层数&#x27;].value_counts())</span><br><br>df.to_excel(<span class="hljs-string">&quot;清洗.xlsx&quot;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>可以做到简单的去除重复数据、格式标准化、类型转换。</p><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>主要利用Matplotlib，也可使用Pyecharts。</p><h1 id="数据预测"><a href="#数据预测" class="headerlink" title="数据预测"></a>数据预测</h1><p>主要使用Scikit-Learn机器学习。</p><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2><p>要将非数值数据进行编码，可采用<strong>标签编码、独热编码、平均值编码</strong>等方式，我们主要采用的是独热编码和平均值编码。</p><h3 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h3><p>将数据编码为列向量的形式，即非“本特征”定义为<code>0</code>，否则为<code>1</code>。但是为了拟合的准确性，我们需要丢弃每个元素进行独热编码后的第一列（即<code>drop_first=True</code>语句）。独热编码适合类型少的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">preOneHot</span>(<span class="hljs-params">data</span>):    <span class="hljs-comment"># 使用OneHot预处理数据</span><br>    types = data[[<span class="hljs-string">&#x27;楼层高低&#x27;</span>, <span class="hljs-string">&#x27;建筑类型&#x27;</span>]]<br>    types_encoded = pd.get_dummies(types, drop_first=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> types_encoded<br></code></pre></td></tr></table></figure><h3 id="平均值编码"><a href="#平均值编码" class="headerlink" title="平均值编码"></a>平均值编码</h3><p>即编码为该特征目标值的平均值。适合类型多的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">PreAverage</span>(<span class="hljs-params">df, feature, target</span>):    <span class="hljs-comment"># 平均值编码</span><br>    encoding_map = df.groupby(feature)[target].mean()<br>    <span class="hljs-keyword">return</span> df[feature].<span class="hljs-built_in">map</span>(encoding_map)<br></code></pre></td></tr></table></figure><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>在对数据进行编码后，就可以划分为训练集和测试集了。其中还用StandardScaler进行了正态分布化，可以提高训练效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">data = inputData()<br>final_data = preData(data)<br>X = final_data.values<br>y = data[targetCols].values.ravel()<br><br><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.6</span>, random_state=<span class="hljs-number">400</span>)<br><br>scaler = StandardScaler()   <span class="hljs-comment"># 数据标准化，转化成正态分布</span><br>X_train = scaler.fit_transform(X_train)<br>X_test = scaler.transform(X_test)<br></code></pre></td></tr></table></figure><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><p>回归模型有很多种，但我们必须选择性能最好的那个，所以先每一个都试一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">models = &#123;<br>    <span class="hljs-string">&#x27;K-邻近算法&#x27;</span>: KNeighborsRegressor(),<br>    <span class="hljs-string">&#x27;线性回归&#x27;</span>: LinearRegression(),<br>    <span class="hljs-string">&#x27;岭回归&#x27;</span>: Ridge(),<br>    <span class="hljs-string">&#x27;拉索回归&#x27;</span>: Lasso(),<br>    <span class="hljs-string">&#x27;决策树回归&#x27;</span>: DecisionTreeRegressor(),<br>    <span class="hljs-string">&#x27;支持向量回归&#x27;</span>: SVR()<br>&#125;<br><br><span class="hljs-keyword">for</span> name, model <span class="hljs-keyword">in</span> models.items():              <span class="hljs-comment"># 每个模型都试一遍</span><br>    model.fit(X_train, y_train)<br>    y_pred = model.predict(X_test)<br>    r2 = r2_score(y_test, y_pred)               <span class="hljs-comment"># r2值</span><br>    mse = mean_squared_error(y_test, y_pred)    <span class="hljs-comment"># 均方根误差</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;模型 <span class="hljs-subst">&#123;name&#125;</span> 的 r2 值为：<span class="hljs-subst">&#123;r2:<span class="hljs-number">.4</span>f&#125;</span>，RMSE 值为 <span class="hljs-subst">&#123;np.sqrt(mse):<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br><br>    R = random.randrange(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(X_test))  <span class="hljs-comment"># 取随机数</span><br>    y_true = y_test[R]<br>    X_sample = X_test[R].reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)         <span class="hljs-comment"># 转置向量</span><br><br>    y_pred_sample = model.predict(X_sample)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;房价真实值为：<span class="hljs-subst">&#123;y_true:<span class="hljs-number">.2</span>f&#125;</span>，房价推测值为：<span class="hljs-subst">&#123;y_pred_sample[<span class="hljs-number">0</span>]:<span class="hljs-number">.2</span>f&#125;</span>，差值为：<span class="hljs-subst">&#123;<span class="hljs-built_in">abs</span>(y_pred_sample[<span class="hljs-number">0</span>] - y_true):<span class="hljs-number">.2</span>f&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;综合以上，可以看到线性回归、岭回归、拉索回归的效果是最好的&quot;</span>)<br></code></pre></td></tr></table></figure><p>接下来，就可以用线性回归模型进行拟合预测了。结合可交互界面就可以完成本项目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《面向对象程序设计》笔记</title>
    <link href="/2024/oop/"/>
    <url>/2024/oop/</url>
    
    <content type="html"><![CDATA[<p>这是本人为了应付学校oop考试（结果还是喜提3.7），以课程ppt为基础整合出来给自己复习的文章。</p><p><a href="https://github.com/Kisechan/oop-notes">Markdown源文件（Github仓库）</a></p><p>仓库里的内容会不定期更新。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向对象的三要素"><a href="#面向对象的三要素" class="headerlink" title="面向对象的三要素"></a>面向对象的三要素</h2><ul><li><p>封装与数据屏蔽</p></li><li><p>继承与重用</p></li><li><p>多态</p></li></ul><h2 id="面向对象编程的过程"><a href="#面向对象编程的过程" class="headerlink" title="面向对象编程的过程"></a>面向对象编程的过程</h2><ul><li><p>OOA：面向对象分析（干什么）</p></li><li><p>OOD：面向对象设计（怎样干）</p></li><li><p>OOP：面向对象编程（实现）</p></li></ul><h2 id="面向对象的原则"><a href="#面向对象的原则" class="headerlink" title="面向对象的原则"></a>面向对象的原则</h2><table><thead><tr><th align="center">原则</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">单一职责</td><td align="center">一个大类不如多个小类灵活</td></tr><tr><td align="center">接口隔离</td><td align="center">依赖关系建立在最少的接口上</td></tr><tr><td align="center">开放封闭</td><td align="center">对扩展开放、对修改关闭</td></tr><tr><td align="center">依赖倒转</td><td align="center">最好关联抽象类，越抽象越底层</td></tr><tr><td align="center">里氏替换</td><td align="center">子类对象可以完全顶替父类，而程序的行为没有变</td></tr><tr><td align="center">迪米特</td><td align="center">一个对象应该对其他对象有最少的了解</td></tr><tr><td align="center">合成聚合复用</td><td align="center">尽量使用合成（成员与对象存活时间相同，例如有成员<code>Engine _engine</code>）&#x2F;聚合（成员与对象存活时间不同，例如有成员<code>Engine* _engine</code>），尽量不使用继承</td></tr></tbody></table><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>a[b]</code>等效于<code>*(a+b)</code>，数组名就是指针。</p><p>类似于<code>int (*p)[4]</code>这样的写法中，<code>p</code>指的是一个指向元素数量为<code>4</code>的<code>int</code>型数组的指针。</p><h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>指针函数用来申请空间或者查找数据，函数指针用来动态指定参与运算的函数。</p><ul><li>定义指针函数：<code>int* f(int x)</code><br><br/><code>int*</code>是返回类型，<code>f</code>是函数的名字。</li><li>定义函数指针：<code>int (*g)(int)</code><br><br/><code>int</code>是返回类型，<code>g</code>是函数指针的名字。<br><strong>函数指针的使用更像是一个变量</strong>，保存着函数，定义在<code>main()</code>或者其他的函数里面。</li></ul><p>如果要用<code>typedef</code>来给函数指针起别名，可以参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*the_func_pointer_name)</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>调用<code>the_func_pointer_name</code>关键字就可以定义一个参数为两个<code>int</code>，返回值为<code>int</code>的函数指针。</p><p>给函数指针赋值可以用<code>函数名</code>或<code>&amp;函数名</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*the_func_pointer_name)</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br>the_func_pointer_name a,b;<br>a=f;<br>b=&amp;g;<br></code></pre></td></tr></table></figure><p>特别地，<code>int (*F(int x))(int,int)</code>是一个函数，其返回值是一个函数指针<code>int (*F)(int,int)</code>，这个函数指针对应的函数有两个<code>int</code>类型的参数，调用形参<code>int x</code>之后返回。可以参考<code>typedef</code>在函数指针中的用法。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>指针常量<code>int* const p</code>：<code>p</code>指向的地址不可以被改变，数组头就是类似的。</li><li>常量指针<code>const int* p</code>或<code>int const *p</code>：<code>p</code>指向的地址可以改变，但是<code>*p</code>是一个常量。<br/><br>常量<code>const int</code>类型的变量，其地址不能被赋给<code>int*</code>类型的指针，而必须是赋给常量指针<code>const int*</code>，否则会使权限被外界扩大。</li><li>指向常量的常量指针<code>const int *const p</code>：既不能修改地址，也不能修改指向的量。</li></ul><table><thead><tr><th align="center">定义</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>const int *const p</code></td><td align="center">指向常量的指针常量</td></tr><tr><td align="center"><code>int const * const p</code></td><td align="center">指向常量的指针常量</td></tr><tr><td align="center"><code>int * const p</code></td><td align="center">指针常量</td></tr><tr><td align="center"><code>int const * p</code></td><td align="center">常量指针</td></tr></tbody></table><p>定义<code>const</code>指针的意义：</p><ul><li><strong>内部需要</strong>：<code>this</code>和常成员函数的<code>this</code></li><li><strong>参数传递</strong>：传递过程中权限被缩小的机制，使数据得到保护，责任划分清楚</li></ul><p>例如：</p><table><thead><tr><th align="center">定义</th><th align="center">意义</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><code>void A(int const *const p);</code></td><td align="center">指向常量的指针常量</td><td align="center"></td></tr><tr><td align="center"><code>void B(int *const p);</code></td><td align="center">指针常量</td><td align="center">数组内容可能被修改</td></tr><tr><td align="center"><code>void C(int const *p);</code></td><td align="center">常量指针</td><td align="center"></td></tr><tr><td align="center"><code>void D(int *p);</code></td><td align="center">普通指针</td><td align="center">数组内容可能被修改</td></tr></tbody></table><p><code>const</code>还有一个重要用法：用于<strong>常成员函数</strong>。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>普通的函数传参存在形式歧义。</p><p>如果有一个函数，它的参数是一个类<code>A</code>，那么参数传递相当于：<code>class A swap.a = main.a</code>，就是在这个函数的作用域里面重新创建了一个这样的对象，并将其赋值为传入的参数，会引起拷贝构造函数或赋值运算的调用，如果这个过程很复杂，代价就会非常大。如果<code>Class A</code>继承或者组合了其他类。则要引起拷贝构造函数的层层调用，代价更大。使用引用则可以改善。</p><p><strong>引用就是别名</strong>。定义必须初始化：<code>int&amp; i=j;</code>。因为如果<code>int&amp; i=j;</code>，那么<code>i==j</code>且<code>&amp;i==&amp;j</code>。引用一旦被定义了，就不能再被修改，它和指针的意义是等价的，只不过更直白,所以是使用<code>&amp;</code>运算符定义。</p><h2 id="与指针的关系"><a href="#与指针的关系" class="headerlink" title="与指针的关系"></a>与指针的关系</h2><ul><li>引用可以代替指针常量：<ul><li><code>int i;int *const p＝&amp;i;</code><br/><br>  等效于：</li><li><code>int  &amp;p=i;</code></li></ul></li><li>引用数组<code>int a[10]</code>时，可以采用：<ul><li><code>int (&amp;f)[10]=a;</code></li></ul></li><li>没有引用的引用。</li><li>不存在<code>void</code>类型的引用。</li><li>引用与<code>const</code>：<ul><li>引用一般不能强制类型转换，例如<code>int a=1;</code>时，<code>float &amp;b=a;</code>和<code>float &amp;c=float(a);</code>、<code>float &amp;d=(float)a;</code>是不被允许的，但是如果将它定义为<code>float const &amp;e=a;</code>则是可以的。</li><li><code>int &amp;i=1;</code>是错误的，但是<code>int const &amp;i=1;</code>正确</li></ul></li></ul><h2 id="函数返回引用和返回变量"><a href="#函数返回引用和返回变量" class="headerlink" title="函数返回引用和返回变量"></a>函数返回引用和返回变量</h2><h3 id="返回变量"><a href="#返回变量" class="headerlink" title="返回变量"></a>返回变量</h3><p>返回变量的优点包括：</p><ul><li><p>安全性：</p><p>返回一个值的副本可以保证调用者无法直接修改原始对象，因为它们操作的是不同的副本。</p></li><li><p>简单性：</p><p>对于小型对象或内置类型（如整数、浮点数等），返回值副本通常更加简单和高效。</p></li><li><p>线程安全性：</p><p>在多线程环境下，每个线程可以安全地操作自己的返回值副本，避免了竞态条件的问题。</p></li></ul><p>一些缺点：</p><ul><li><p>性能开销：</p><p>返回大型对象时，需要进行复制操作，可能会带来较大的性能开销，尤其是在频繁调用和处理大对象时。</p></li></ul><h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3><p>返回引用意味着函数返回的是原始对象的引用，调用者可以直接访问和修改原始对象。</p><p>优点包括：</p><ul><li><p>性能效率：</p><p>避免了返回值时的对象复制，节省了时间和空间开销，特别是对于大型对象而言。</p></li><li><p>直接操作对象：</p><p>允许调用者直接修改原始对象的状态，适用于需要在函数内部修改对象状态并且这些修改需要在函数外部保持的情况。</p></li></ul><p>潜在的问题和注意事项：</p><ul><li><p>潜在的安全性问题：</p><p>调用者可以通过返回的引用直接修改对象，这可能导致意外的副作用或错误状态，尤其是在多线程或复杂逻辑下。</p></li><li><p>生命周期管理：</p><p>返回引用时需要确保引用的对象在函数返回后仍然有效，避免返回了一个<strong>垂悬引用</strong>。</p></li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>通常情况下，可以遵循以下原则来选择返回变量或返回引用：</p><ul><li><p><strong>小型对象或内置类型</strong>：优先考虑返回变量，因为复制开销较小，而且不会涉及引用悬挂的问题。</p></li><li><p><strong>大型对象</strong>：考虑返回引用，以避免复制开销，但需注意引用的有效性和可能的副作用。</p></li><li><p><strong>需要修改原始对象状态</strong>：只能返回引用，因为返回值的复制将不会影响原始对象。</p></li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>定义一个类就是定义一个类型。</p><p>基本形式，<strong>注意分号</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">float</span> c;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从结构到类：</p><table><thead><tr><th align="center">概念</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">结构</td><td align="center">单纯堆积数据空间构造的类型。</td></tr><tr><td align="center">类</td><td align="center">不但描述数据空间，还描述其操作的自定义类型。</td></tr><tr><td align="center">变量</td><td align="center">由内部数据类型或衍生的结构类型所产生的实体。</td></tr><tr><td align="center">对象</td><td align="center">由类产生的实体。<br/>本质上，变量也是对象，只不过简单一点罢了。</td></tr></tbody></table><p>类的作用：</p><ul><li>外壳保护作用</li><li>外壳内外分明</li><li>接口标准清晰</li><li>责任方便维护</li></ul><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p>成员的权限是对外的直接权限，对内没有权限限制。外部包括：非成员函数和其它类的成员函数。</p><p><code>private</code>与<code>protected</code>只有在继承时有区别。</p><p>成员函数之间相当于同作用域互相可见，非成员函数不在相同作用域：</p><ul><li>作用域<ul><li>成员函数属于类, 成员函数定义是类设计的一部分, 其作用域是类作用域。</li><li>普通函数一般是全局函数。</li></ul></li><li>操作主体<ul><li>成员函数的操作主体是对象,使用时通过捆绑对象来行使其职责。</li><li>普通函数被调用时没有操作主体。</li></ul></li></ul><h2 id="占有的内存"><a href="#占有的内存" class="headerlink" title="占有的内存"></a>占有的内存</h2><p>实例化的类占有的内存与非静态数据成员和虚函数（因为要构造虚函数表）有关。</p><p>静态数据成员和成员函数不占用实例化的类的空间。</p><p>需要注意的是，即便一个类只有静态数据成员和成员函数，它实例化后占有的空间也不会是<code>0</code>，而至少是<code>1</code>个字节，因为需要给它分配地址，则至少要有<code>1</code>字节。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>变量的作用域是<code>&#123;&#125;</code>内或其后的全部内容，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-comment">//输出全局变量a</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-number">2</span>;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-comment">//输出main中定义的a</span><br><br>    cout&lt;&lt;::a&lt;&lt;endl;<br>    <span class="hljs-comment">//全局对象被屏蔽后的强行访问</span><br>    &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">3</span>;<br>        cout&lt;&lt;a&lt;&lt;endl;<br>        <span class="hljs-comment">//输出新域中的a</span><br>    &#125;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-comment">//输出main中定义的a</span><br>    <span class="hljs-built_in">f</span>();<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-comment">//输出main中定义的a</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-comment">//输出全局变量a</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-number">4</span>;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-comment">//输出新域中的a</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类定义的作用域也等同于变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>    &#123;<br>        <span class="hljs-type">int</span> b;<br>    &#125;;<br>    A s;    <span class="hljs-comment">//正常</span><br>    B t;    <span class="hljs-comment">//正常</span><br>    &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>        &#123;<br>            <span class="hljs-type">int</span> c;<br>        &#125;;<br>        A s;    <span class="hljs-comment">//正常</span><br>        B t;    <span class="hljs-comment">//正常</span><br>        C u;    <span class="hljs-comment">//正常</span><br>    &#125;<br>    A s;    <span class="hljs-comment">//正常</span><br>    B t;    <span class="hljs-comment">//正常</span><br>    C u;    <span class="hljs-comment">//报错</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <br>    A s;    <span class="hljs-comment">//正常</span><br>    B t;    <span class="hljs-comment">//报错</span><br>    C u;    <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>区分类定义作用域和类作用域：</p><ul><li><strong>类定义作用域</strong>:<ul><li>从类定义结束开始，到从外面包围类定义的块结束（若类定义外无包围块，则结束于文件）。</li><li>在类定义作用域中，可以定义这个类的变量。</li><li>使用类的程序员在类定义作用域下编程。</li></ul></li><li><strong>类作用域</strong>:<ul><li>类定义内部及成员函数定义内部。</li><li>实现类的程序员在类作用域下编程。</li></ul></li></ul><p>如果需要在类作用域外进行定义，需要使用运算符<code>::</code>。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>可以在函数声明前加上<code>inline</code>语句，进行显性定义或者声明。复杂语句（循环、多分支）不适合内联。小的成员函数如果在类内定义，一般编译器会默认为内联函数。内联函数可以提高代码效率。</p><p>内联函数的定义和声明不能分开。</p><p>对于<code>inline</code>限定的函数，具体是不是采取内联方式编译是取决于编译器的。对于较大较复杂的函数，编译器不会内联编译，所以只能说<code>inline</code>是给编译器的一个“建议”。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>成员函数不属于对象，通过内部隐含<code>*this</code>的定义<code>A *const this=&amp;对象X</code>来知道调用者是谁。</p><h3 id="成员函数的作用域"><a href="#成员函数的作用域" class="headerlink" title="成员函数的作用域"></a>成员函数的作用域</h3><p>可以参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Student.h中：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-type">float</span> score;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">x</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">/*成员函数x()*/</span>&#125;<br>&#125;;<br><span class="hljs-comment">//Student.cpp中：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">x</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">/*新的x()*/</span>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::p</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-type">int</span> age = <span class="hljs-number">1</span>;  <br>    age=<span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">this</span>-&gt;age=<span class="hljs-number">5</span>;<br>    Student::age = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//必须要有this-&gt;或::用来区分p()中新定义的age和类中的</span><br>    <span class="hljs-built_in">x</span>();    <span class="hljs-comment">//成员函数x()</span><br>    ::<span class="hljs-built_in">x</span>();  <span class="hljs-comment">//新的x()</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>常成员函数不允许出现改变对象状态的行为，此时<code>this</code>是一个指向常量的指针。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::p</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;age&lt;&lt;a;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，还有一些例如常量对象（已经被<code>const</code>处理了）调用成员函数的问题。常量对象不能调用改变对象状态的成员函数。</p><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重载以以下的因素为依据：</p><ul><li>参数类型</li><li>参数个数</li><li>参数顺序</li><li>参数是否是<strong>常量指针或常引用</strong></li><li>常成员函数</li></ul><p>但是要注意的是：</p><ul><li><p>返回类型不能够作为重载的依据。</p></li><li><p>所有的重载函数需要在同一个定义域中。</p></li><li><p>如果普通函数不存在，那么都调用常成员函数。<br/>关于常成员函数的重载，也可以参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;not const&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;const&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    <span class="hljs-type">const</span> A b=a;<br>    a.<span class="hljs-built_in">p</span>();  <span class="hljs-comment">//调用非常成员函数</span><br>    b.<span class="hljs-built_in">p</span>();  <span class="hljs-comment">//调用常成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只有常引用或常量指针才能重载，如果是下面这种情况，那么不会构成重载，因为不是空间权限的传递，而是值的传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(A <span class="hljs-type">const</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(A s)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于可以类型转换的参数，按照下面的顺序进行重载：</p><ol><li>严格匹配</li><li>其次相容类型匹配</li><li>最后用户定义类型转换</li></ol><p>  这样来尽量避免类型相容二义性，用“名称压轧技术”实现。  </p></li><li><p>默认从左端开始匹配重载。</p></li></ul><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>重载是从左端开始匹配的，但是默认参数从右端开始设置，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j=<span class="hljs-number">11</span>,<span class="hljs-type">int</span> k=<span class="hljs-number">12</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     cout&lt;&lt;i&lt;&lt;j&lt;&lt;k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">x</span>();        <span class="hljs-comment">//错误</span><br>    <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">//输出结果：    1 11 12</span><br>    <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);     <span class="hljs-comment">//输出结果：    1 2 12</span><br>    <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);   <span class="hljs-comment">//输出结果：    1 2 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认参数会对依靠参数进行重载的函数产生影响，因为会改变参数的数量，可能造成二义性。</p><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><h3 id="模板与函数"><a href="#模板与函数" class="headerlink" title="模板与函数"></a>模板与函数</h3><p>使用泛类型。例如定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span>;<br></code></pre></td></tr></table></figure><p>函数在得到参数以后，按照类型反向推演出实例化的函数，下一次再使用时，就不再进行推演实例化。其参数类型必须严格匹配，否则会导致推演错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-built_in">swap</span>(a,b);<br></code></pre></td></tr></table></figure><p>但是如果指定了类型，就会强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(a,b); <span class="hljs-comment">//显式</span><br></code></pre></td></tr></table></figure><p>和函数默认参数一样，模板也可以有默认参数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S,<span class="hljs-keyword">typename</span> T=<span class="hljs-type">int</span>&gt;<br></code></pre></td></tr></table></figure><p>需要注意的是，模板类型声明不能共享，typename不能节省。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T&amp; a,U&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a,T&amp; b)</span>        <span class="hljs-comment">//错误</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果同时有非模板函数和模板函数，则优先调用非重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a,T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* &amp;a,<span class="hljs-type">int</span>* &amp;b)</span>  <span class="hljs-comment">//优先调用</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以有模板重载，但VC++不支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">x</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">x</span><span class="hljs-params">(T *x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与函数类似，类也可以进行模板操作。</p><p>模板函数可以使用<code>export</code>关键字进行多文件编程，不过代价太大，主流编译器均不支持。</p><h1 id="名字空间和嵌套类"><a href="#名字空间和嵌套类" class="headerlink" title="名字空间和嵌套类"></a>名字空间和嵌套类</h1><p>名字空间是一个作用域，用于解决名字冲突的风险，可以包含变量、对象，函数和类型的定义。可以开放定义或在<code>&#123;&#125;</code>外定义。一个类本身就是一个特殊的名字空间。<code>using namespace</code>语句类似于友元。<code>namespace</code>语句可以为名字空间起一个别名。</p><p>一个类可以嵌套另一个类。嵌套类基本是类内和类外的关系，对象空间不包含。外界访问被嵌套类受权限制约，而被嵌套类可以无条件访问外围类的静态成员、类型名称。嵌套类的意义在于隐藏代码和避免头文件包含。</p><h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p>构造函数就是在构造一个类时，将该类的所有成员初始化的函数；析构函数则是在一个类结束生命时（函数结束或者被<code>delete</code>），将所有的类成员消灭，回收它们占有的空间的函数。</p><p>构造函数与类同名，没有返回类型，构造时自动调用，可以重载。可以用于初始化，不能直接调用。</p><p>析构函数也没有返回类型，析构时自动调用，没有参数，不能重载。不提倡主动调用析构函数。</p><h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><p>在构造函数函数体前面可以采用类似于<code>A():a(b),c(d)</code>的操作，称为成员初始化列表。</p><p>成员初始化列表不同于赋值。赋值是在对象存在以后再进行操作，而初始化则是直接在对象构造完成前进行操作。</p><p>对于引用和<code>const</code>成员的初始化，只能在成员初始化列表中实现。</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>构造函数在构造时执行，全局变量的构造函数在<code>main()</code>函数之前执行，若全局对象分散在不同的源文件中，那么构造顺序时随机的。静态对象的构造函数在首次被调用时执行一次，在程序结束时析构。</p><p>从复用的结构而言，对于有继承和组合的类，先执行包含的类或继承的父类的构造函数，以文本上的定义顺序执行构造，而与构造函数初始化列表中<code>ClassA():ClassB(x),ClassC(y)&#123;&#125;</code>的执行顺序无关。</p><p>对象析构时，按构造函数执行的逆序进行。</p><p>对于对象数组，在用<code>delete[]</code>进行析构时，先析构靠后的，之后一个一个向前析构。</p><h2 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h2><p>成员类不允许在定义时初始化，因为它仅仅是一个类型，而没有空间分配。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br>    string name;<br>    StudentID id;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(string pName,<span class="hljs-type">int</span> ssID=<span class="hljs-number">0</span>)<br>    &#123;<br>        name=pName;<br>        <span class="hljs-function">StudentID <span class="hljs-title">id</span><span class="hljs-params">(ssID)</span></span>; <span class="hljs-comment">//错误</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="关于动态内存"><a href="#关于动态内存" class="headerlink" title="关于动态内存"></a>关于动态内存</h2><p><code>malloc()</code>和对应的<code>free()</code>函数不属于语言本身，于malloc.h中声明，因此在用它们执行申请动态内存时不能自动调用构造函数和析构函数。所以引入了<code>new</code>和<code>delete</code>关键字。</p><p>通过<code>new</code>关键字申请的动态空间位于堆区，不会主动释放，因此使用<code>new</code>创建的新对象不会自动在程序结束时调用析构函数释放它自己，需要主动管理。因此，对于含有指针和动态内存的类，也需要在析构函数中执行<code>delete[]</code>语句释放空间。</p><p>需要注意的一点是，用<code>malloc()</code>和<code>free()</code>构造和消灭的对象是不会主动调用构造函数和析构函数的。</p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>如果让一个<code>A</code>类型的类进行<code>A b=a;</code>这样的操作，则会调用（默认的）拷贝构造函数<code>A(const A&amp;)</code>，为<code>b</code>初始化。</p><p>调用拷贝构造函数产生的效果分为浅拷贝和深拷贝。浅拷贝指的是只拷贝地址，深拷贝则是拷贝了地址上的内容。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在将一个输入进行类型转换，转换成一个类时，通常会调用对应的构造函数。</p><blockquote><p>如果构造函数用了<code>explicit</code>关键字，那么则不接受隐式的类型转换。例如，如果一个类<code>A</code>只有从<code>int</code>构造的构造函数，那么如果加上了<code>explicit</code>之后，<code>A a=1;</code>这样的操作是不合法的，因为不能够隐式调用它了，去掉了则可以。</p></blockquote><p>类型转换并不是万能的，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">aa</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">aa</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>)&#123;id=a;&#125;<br>    <span class="hljs-type">int</span> id;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bb</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bb</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">2</span>)&#123;id=a;&#125;<br>    <span class="hljs-type">int</span> id;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m</span><span class="hljs-params">(aa a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;a.id&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m</span><span class="hljs-params">(bb a)</span></span><br><span class="hljs-function"></span>&#123;<br>   cout&lt;&lt;a.id&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">m</span>(<span class="hljs-number">9</span>);    <span class="hljs-comment">//存在二义性</span><br>&#125;           <span class="hljs-comment">//转换不能太复杂，不允许多参数，不允许间接转换</span><br></code></pre></td></tr></table></figure><h2 id="默认的构造函数与析构函数"><a href="#默认的构造函数与析构函数" class="headerlink" title="默认的构造函数与析构函数"></a>默认的构造函数与析构函数</h2><p>默认构造函数就是不带任何参数的构造函数，如果没有给一个类定义构造函数，编译器就会自己给它加上一个默认的，把类里面的所有参数都初始化为<code>0</code>。默认析构函数同理。</p><p>如果把一个构造函数定义为<code>Myclass()=default;</code>也可以显式将其声明为默认的构造函数。</p><p>同样，对于拷贝构造函数，如果没有给一个类显式定义，那么编译器也会默认生成一个。</p><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>将一个函数或类设置友元可以让其获得访问此类的<code>protected</code>和<code>private</code>成员。可以解决一些效率问题和格式问题。友元是单向的，且不具备传递性。它一定程度上破坏了类的封装性，扩大了自由函数与类对类的访问权限，谨慎使用。</p><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>利用函数机制重载运算符，不过其成员不能全是基本类型，其内部的同名运算符保持原来的含义，优先级也不会改变。重载的运算符可以是成员函数也可以是非成员函数。</p><p>赋值运算符、自增自减运算符应当返回引用。</p><h2 id="成员或非成员"><a href="#成员或非成员" class="headerlink" title="成员或非成员"></a>成员或非成员</h2><table><thead><tr><th align="center">权限</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">只能是成员的运算符</td><td align="center"><code>=</code></td><td align="center"><code>()</code></td><td align="center"><code>[]</code></td><td align="center"><code>-&gt;</code></td></tr><tr><td align="center"><del>只能是友元的运算符</del></td><td align="center"><del><code>&lt;&lt;</code></del></td><td align="center"><del><code>&gt;&gt;</code></del></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">既可以友元也可以成员的</td><td align="center"><code>+</code></td><td align="center"><code>-</code></td><td align="center">etc.</td><td align="center"></td></tr><tr><td align="center">不能被重载的运算符</td><td align="center"><code>::</code></td><td align="center"><code>.</code></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>但是，如果一个运算符是成员，那么它的左边必须是一个类类型。所以对于混合使用的运算符，例如<code>+</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s=<span class="hljs-string">&quot;hello&quot;</span>;<br>string t=<span class="hljs-string">&quot;hello&quot;</span>+s; <span class="hljs-comment">//错误：&quot;hello&quot;不是一个类</span><br></code></pre></td></tr></table></figure><h2 id="一般的算术运算符"><a href="#一般的算术运算符" class="headerlink" title="一般的算术运算符"></a>一般的算术运算符</h2><p>如果是在类外定义运算符重载，则和一般写函数差不多，参数是两个。</p><p>如果是在类内定义算术运算符，参数只有一个，而且需要注意返回的应当是<code>*this</code>的引用：</p><ul><li><p>支持链式操作符：</p><ul><li>返回 <code>*this</code> 允许类实例在操作符链中进行修改和连续调用。例如，如果一个类重载了 <code>+</code> 运算符返回 <code>*this</code>，那么可以连续对该对象进行操作，而不需要每次都创建新的对象。</li></ul></li><li><p>原地修改对象：</p><ul><li>返回 <code>*this</code> 允许在不创建新对象的情况下，直接在当前对象上进行修改。这在某些情况下可以提高性能和效率，特别是对于一些复杂的数据结构或者需要频繁修改的对象。</li></ul></li><li><p>一致性和约定：</p><ul><li>返回 <code>*this</code> 是一种约定和惯例，它告诉用户重载的 <code>+</code> 运算符确实是在修改当前对象而非创建新对象。这样的约定对于代码的可读性和理解是有益的。</li></ul></li></ul><h2 id="I-O运算符"><a href="#I-O运算符" class="headerlink" title="I&#x2F;O运算符"></a>I&#x2F;O运算符</h2><p>重载输入、输出运算符的第一个形参是对非常量的<code>ostream</code>或<code>istream</code>对象的引用，因为我们不能直接复制一个<code>ostream</code>对象，而之所以是非常量对象，是因为向其中写入内容会改变其状态；第二个形参是对于类的引用，引用是为了避免复制实参，而它可以是常量是因为我们的操作不会改变它的状态。</p><p>重载输入、输出运算符的函数既可以是成员函数也可以是友元函数。</p><p>友元函数形同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="hljs-type">const</span> data&amp; item)<br>&#123;<br>    os&lt;&lt;item.<span class="hljs-built_in">name</span>()&lt;&lt;flush;<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">//返回os形参</span><br>&#125;<br></code></pre></td></tr></table></figure><p>成员函数形同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os) <span class="hljs-type">const</span><br>&#123;<br>    os&lt;&lt;<span class="hljs-built_in">name</span>()&lt;&lt;flush;<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">//返回os形参</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它们必须是一个非成员函数。如果它们是成员函数，那么它们的左侧是我们这个类的一个对象，然而左侧应该是<code>istream</code>或<code>ostream</code>对象。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的返回值一般是<strong>引用</strong>，否则不能连续赋值，因为每一次赋值都会产生一个临时变量，会影响到连续赋值的结果。</p><p>如果没有给一个类定义赋值运算符的重载，编译器就会生成一个默认的赋值运算符重载，和默认拷贝构造函数差不多。</p><h2 id="自增、自减运算符"><a href="#自增、自减运算符" class="headerlink" title="自增、自减运算符"></a>自增、自减运算符</h2><p>和赋值运算符一样，<strong>前置自增自减运算符的返回值也是引用</strong>。重载前置自增自减运算符<code>++x</code>的声明应该写成<code>A&amp; operator++();</code>。</p><p>后置的应该声明成<code>A&amp; operator++(int);</code>，它接受一个不被使用的<code>int</code>形参，默认为<code>0</code>。后置版本可以不是引用。一般是生成一个<code>A</code>类型的<code>ret</code>记录<code>*this</code>，然后操作<code>*this</code>，返回<code>ret</code>。</p><p>使用<code>p.operator++()</code>或<code>p.operator++(0)</code>可以显式调用该运算符。</p><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>静态成员的空间不包含在对象中，在<code>main()</code>之前构造，生命周期等同于全局对象。多个个体对象共享一个共有数据。</p><p>静态成员函数不再与对象<code>this</code>默认联系，但可以访问非<code>public</code>成员。</p><h2 id="关于static关键字"><a href="#关于static关键字" class="headerlink" title="关于static关键字"></a>关于<code>static</code>关键字</h2><p><code>static</code>有三种用法</p><ul><li><p>函数外的静态变量（与 extern 相对）</p><p>  内部链接性变量，仅能在一个编译单元中使用，不与其他编译单元共享。</p></li><li><p>函数中的静态变量（与栈空间中的局部变量相对）</p><p>  位于变量数据区，因此函数返回时不析构的变量。</p></li><li><p>类中的静态成员变量（与对象成员相对）</p><p>  所有实例共享的变量。</p></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承的本质实际上就是由上到下完全的复制，但是继承方式在对内可见性上做了手脚；对外可见性则没有改变。继承后的对外权限等于或低于继承类型 。继承类型省略默认为<code>private</code>继承。<code>private</code>成员继承后只对原来兄弟方法可见。子类不能访问父类中的<code>private</code>成员，父类不能也做不到访问子类的所有内容。</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202406021046984.png"></p><p>派生的内容则等同于原始类的定义。派生类对象包含父类对象全部内容，<strong>凡是父类对象可以出现的地方都可以用子类对象代替</strong>，反之不可。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;;<br>A* p=<span class="hljs-keyword">new</span> B;   <span class="hljs-comment">//这是允许的</span><br></code></pre></td></tr></table></figure><p><code>public</code>继承使用的最多，是最重要的，产生的后代称为“子类”，<code>protected</code>继承和<code>private</code>继承得到的类<strong>都不是子类</strong>。<strong>“凡是父类对象可以出现的地方可以用子类对象代替”不再适用</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202406021048565.png"></p><p>如果子类与父类中的成员（函数或对象）重名，则子类覆盖父类的成员。需要使用<code>::</code>强行访问。</p><p><strong>构造函数、拷贝构造函数、析构函数和赋值函数不能被继承。</strong></p><h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><p>组合指的是一个类中有另一个类为其成员，继承则是完全的另一种复用方式，因此，不能用组合类代替被组合类实现类似于子类代替父类的用法。因为没有继承关系，所以组合中，<code>protected</code>也等效于<code>private</code>。</p><p>组合和继承都是实现复用的手段，但是尽量使用组合，因为是黑箱复用依赖较少。被组合的成员内部的成员和本级其他成员，相互访问权限相当于类外关系。被组合成员内部的成员的成员的成员，etc，外面对其访问权限属于逐级类外叠加的关系。</p><h2 id="继承与构造函数"><a href="#继承与构造函数" class="headerlink" title="继承与构造函数"></a>继承与构造函数</h2><p>子类的构造函数可以在<code>&#123;&#125;</code>中初始化父类的成员，但不提倡。不过，如果<code>id</code>是父类<code>A</code>中的成员<code>B():id(9)&#123;&#125;</code>这样的操作是不允许的，只能用<code>B():A(9)&#123;&#125;</code>这样的操作调用父类的构造函数。</p><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>如果子类中有一个与父类完全相同的成员函数定义，那么会覆盖掉父类中原本的函数，可以使用<code>::</code>强行访问。但是要注意与重载的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automobile</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;机械变速&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<span class="hljs-keyword">public</span> Automobile<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;  <br>        cout&lt;&lt;<span class="hljs-string">&quot;自动变速&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    Automobile ObjA;<br>    Car ObjB;<br>    ObjA.<span class="hljs-built_in">Run</span>();<br>    ObjB.<span class="hljs-built_in">Run</span>();   <span class="hljs-comment">//编译错误，不是重载</span><br>    ObjB.Automobile::<span class="hljs-built_in">Run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>以及：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automobile</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;“机械变速”&quot;</span>&lt;&lt;endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">   </span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;“机械变速1.0”&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<span class="hljs-keyword">public</span> Automobile<br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;  <br>      cout&lt;&lt;<span class="hljs-string">&quot;“自动变速“&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   Automobile ObjA;<br>   Car ObjB;<br>   ObjA.<span class="hljs-built_in">Run</span>();<br>   ObjA.<span class="hljs-built_in">Run</span>(<span class="hljs-number">1</span>);<br>   ObjB.<span class="hljs-built_in">Run</span>();<br>   ObjB.<span class="hljs-built_in">Run</span>(<span class="hljs-number">2</span>);               <span class="hljs-comment">//出错</span><br>   ObjB.Automobile::<span class="hljs-built_in">Run</span>(<span class="hljs-number">2</span>);   <span class="hljs-comment">//正常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有的时候需要注意隐性的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automobile</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;“机械变速”&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<span class="hljs-keyword">public</span> Automobile<br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;  <br>      cout&lt;&lt;<span class="hljs-string">&quot;“自动变速“&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fn</span><span class="hljs-params">(Automobile *p)</span>  <span class="hljs-comment">//进行了类型转换</span></span><br><span class="hljs-function"></span>&#123;<br>   p-&gt;<span class="hljs-built_in">Run</span>();<br>   <span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-built_in">Fn</span>(<span class="hljs-keyword">new</span> Automobile);  <span class="hljs-comment">//机械变速</span><br>   <span class="hljs-built_in">Fn</span>(<span class="hljs-keyword">new</span> Car);         <span class="hljs-comment">//机械变速</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><p>只不过我们希望，<code>Fn(new Car)</code>这个操作能输出<code>自动变速</code>，这就需要多态，所以需要引入虚函数，用<code>virtual</code>关键字定义。派生类中的函数只要原型相同，则自动具有虚函数性质，其<code>virtual</code>关键字可省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automobile</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;“机械变速”&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<span class="hljs-keyword">public</span> Automobile<br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;  <br>      cout&lt;&lt;<span class="hljs-string">&quot;“自动变速“&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fn</span><span class="hljs-params">(Automobile *p)</span>  <span class="hljs-comment">//进行了类型转换</span></span><br><span class="hljs-function"></span>&#123;<br>   p-&gt;<span class="hljs-built_in">Run</span>();<br>   <span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-built_in">Fn</span>(<span class="hljs-keyword">new</span> Automobile);  <span class="hljs-comment">//机械变速</span><br>   <span class="hljs-built_in">Fn</span>(<span class="hljs-keyword">new</span> Car);         <span class="hljs-comment">//自动变速</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多态的意义在于：</p><ul><li><p>是追求<strong>用指针管理继承体系对象</strong>的结果。</p></li><li><p>多态性使得应用程序使用类体系中的不同层次对象共存的复杂局面达到了一种可管理的境界；程序员从使用孤立的类，到使用分层的类，让各种对象“同场竞技”，并且能充分展现其个性。</p></li><li><p>不支持多态的语言不能称为面向对象的语言。</p></li></ul><p>编译器通过函数名、参数个数、参数类型、参数顺序相同判断是否覆盖基类虚函数。但是如果两个虚函数的返回值分别是引用和相同类型的变量，那么并不会判定为两个虚函数。</p><p>虚函数的工作原理在于<strong>动态联编</strong>：</p><table><thead><tr><th align="center">联编</th><th align="center">编译</th><th align="center">调用</th></tr></thead><tbody><tr><td align="center">静态联编<br/>（早期联编）</td><td align="center">编译时完成</td><td align="center">对象调用函数、非多态调用</td></tr><tr><td align="center">动态联编<br/>（滞后联编）</td><td align="center">运行时完成</td><td align="center">多态调用</td></tr></tbody></table><p>静态联编可在编译时确定，是因为可以确定被调用函数所在的类。<strong>动态联编的祖先指针指向了一个后代对象</strong>，但是不容易知道其类型，于是凡有虚函数的类均要维护一个虚表，实例化每个对象时为其增加一个指针，并指向这个虚表（与类型对应），虚函数调用时不需确定对象类型，通过该虚指针即可找到所要链接函数，这样才能确定链接函数是哪个类的。</p><p>虚函数调用的<code>this</code>指针长度也于非虚函数不同。非虚函数<code>this</code>指针自调用者开始，加上调用者类型长度为止（实现者&#x3D;调用者），虚函数<code>this</code>指针自调用者开始，加上实现者类型长度止（实现者&#x3D;对象的类型）。虚函数不予编译检查（虚指针的值无法确认而无法检查），因此无错，执行时则实现者类型已知（因为有虚表），才会出错。</p><p>多态的应用场景主要有<strong>指针、引用和成员函数</strong>，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Running X::f1()&quot;</span>&lt;&lt;endl;  <span class="hljs-built_in">f4</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Running X::f2()&quot;</span>&lt;&lt;endl;  <span class="hljs-built_in">f3</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Running X::f3()&quot;</span>&lt;&lt;endl;  <span class="hljs-built_in">f4</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Running X::f4()&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>:<span class="hljs-keyword">public</span> X<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Running Y::f1()&quot;</span>&lt;&lt;endl;   <span class="hljs-built_in">f2</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Running Y::f3()&quot;</span>&lt;&lt;endl;   <span class="hljs-built_in">f4</span>();&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   X &amp;p =*(<span class="hljs-keyword">new</span> Y);<br>   p.<span class="hljs-built_in">f1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>虚函数使用注意事项：</p><ul><li><p>构造函数和析构函数调用虚函数时，不支持多态。</p></li><li><p><strong>析构函数是推荐作为虚函数的</strong>，例如<code>A *p=new B;delete p;</code>，这样<code>delete</code>掉的地址理论上是只有<code>A</code>的那一部分，调用父类<code>A</code>的构造函数，不会调用子类<code>B</code>的构造函数，容易造成内存泄漏。</p></li><li><p><strong>构造函数不能是虚函数</strong>。</p></li><li><p>非成员函数、静态成员函数和内联函数不能是虚函数。</p></li></ul><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><p>函数签名指的是函数的声明部分，包括函数的名称、参数类型及其顺序（参数列表），但不包括函数的实现体或函数体：</p><ul><li><p>函数名称</p></li><li><p>参数的数量</p></li><li><p>每个参数的类型（按顺序，<code>const</code>属性也包括在内）</p></li><li><p><strong>返回类型不影响函数签名</strong></p></li></ul><p>函数签名的目的是唯一标识一个函数的调用形式，它在编译和链接过程中用于解析函数调用。编程语言通常要求函数签名在同一作用域中唯一，即不同函数在同一作用域下不能有相同的函数签名，以确保函数调用的准确性和一致性。</p><p>虚函数的覆盖就是根据函数签名是否一致来判断是否要覆盖掉父类同名的这个虚函数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Derived</code>类中的<code>func()</code>仍然会覆盖掉基类的同名函数，尽管它们的返回类型不一样。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果基类中的一个虚函数不能给出有意义的实现，那么一般就会将它声明为纯虚函数，例如<code>virtual void p()=0;</code>。</p><p>含有纯虚函数的类被称作抽象类。这些类没有独立于具体类存在的意义,纯粹为了抽象而存在，它们不能被实例化为对象，一般用来作为基类继承，但是<strong>可以有指针或引用</strong>。</p><p>如果一个类继承了一个抽象类，但是没有将<strong>所有</strong>的纯虚函数<code>virtual void p()</code>变为一般的虚函数，那这个子类还是一个抽象类。纯虚函数可以有定义代码，供强行访问。析构函数可以是纯虚函数，但是必须要有定义代码。</p><p>抽象类可以使得数据结构更为清晰。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>如果一个类，同时继承自两个父类，两个父类中还分别有一个名字一样的成员，那么在调用它们时必须要用<code>::</code>区分。</p><p>但是如果是产生了“孙继承”，例如两个类<code>Master</code>和<code>PhD</code>分别继承自同一个基类<code>Student</code>，然后一个新类<code>M_P</code>继承自<code>Master</code>和<code>PhD</code>，就会导致混乱，<code>Master</code>和<code>PhD</code>的域下面各有一个<code>Student</code>域，操作起来会很麻烦，也不能使用<code>Student* p=&amp;M_P</code>这样的写法，因为<code>Student</code>是不明确的。</p><p>这样的话，就可以采用<strong>虚继承</strong>，在继承时加上<code>virtual</code>关键字。<code>M_P</code>则是分别继承自<code>Master</code>、<code>PhD</code>（这两个理论上也继承自<code>Student</code>，但是不会实例化）和<code>Student</code>三个基类。但是，这个时候<code>Student* p=&amp;M_P</code>是成立的，因为，<code>Student*</code>指针是明确的，就是<code>M_P</code>继承的那个<code>Student</code>基类。<code>Master</code>、<code>PhD</code>的<code>Student</code>基类会产生一个<strong>虚指针</strong>，供这两个类在访问它们的父类时使用。虚拟继承的基类直接派生类构造函数放弃向上传导。这种情况下，<code>Student</code>只会实例化一次。</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202406021337183.svg"></p><p>需要注意的是，虚拟继承和虚函数（多态、抽象类）没有关系。实际问题也应尽量避免多重继承。 </p><h2 id="终结类"><a href="#终结类" class="headerlink" title="终结类"></a>终结类</h2><p>如果给一个类加上<code>final</code>关键字，会让它不能被继承，称为终结类。</p><p>把基类的构造函数设为<code>private</code>也可以让它不能被继承。</p><h1 id="I-O类"><a href="#I-O类" class="headerlink" title="I&#x2F;O类"></a>I&#x2F;O类</h1><h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p><code>ostream</code>和<code>istream</code>是类的名称，iostream是该类的头文件</p><blockquote><p><code>ostream &amp;operator&lt;&lt;(ostream out,char *p);</code></p><p><code>ostream &amp;operator&lt;&lt;(ostream out,int p);</code></p><p><code>ostream &amp;operator&lt;&lt;(ostream out,char p);</code></p><p><code>ostream &amp;operator&lt;&lt;(ostream out,float p); </code></p></blockquote><p><code>cout</code>、<code>cin</code>为<code>ostream</code>、<code>istream</code>类的全局对象，不可复制。</p><table><thead><tr><th align="center">定义</th><th align="center">流</th><th align="center">默认输入&#x2F;输出</th></tr></thead><tbody><tr><td align="center"><code>ostream cout(stdout);</code></td><td align="center">标准输出</td><td align="center">默认为屏幕</td></tr><tr><td align="center"><code>ostream cin(stdin);</code></td><td align="center">标准输入</td><td align="center">默认为键盘</td></tr><tr><td align="center"><code>ostream cerr(stderr);</code></td><td align="center">标准出错</td><td align="center">默认为屏幕</td></tr><tr><td align="center"><code>ostream clog(stdprn);</code></td><td align="center">标准打印</td><td align="center">默认为打印机</td></tr></tbody></table><h2 id="I-O操纵器"><a href="#I-O操纵器" class="headerlink" title="I&#x2F;O操纵器"></a>I&#x2F;O操纵器</h2><p>头文件iomanip中包含I&#x2F;O操纵器（manipulator），一些常用的操纵器有：</p><table><thead><tr><th align="center">控制器</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><code>std::setw()</code></td><td align="center">设置字段宽度</td></tr><tr><td align="center"><code>std::setprecision()</code></td><td align="center">设置浮点数的精度</td></tr><tr><td align="center"><code>std::setfill()</code></td><td align="center">设置填充字符</td></tr><tr><td align="center"><code>std::left</code>、<code>std::right</code>、<code>std::internal</code></td><td align="center">设置对齐方式</td></tr><tr><td align="center"><code>std::fixed</code>、<code>std::scientific</code></td><td align="center">设置浮点数的输出格式</td></tr></tbody></table><h2 id="文件流类"><a href="#文件流类" class="headerlink" title="文件流类"></a>文件流类</h2><p><code>ofstream</code>是文件输出类，<code>ifstream</code>是文件输入类，它们在fstream.h里面定义。<code>fstream</code>是多继承子类。文件流类没有<code>cou</code>t和<code>cin</code>这样的标准全局对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ofstream::<span class="hljs-built_in">ofstream</span>(<span class="hljs-type">char</span> *pFilename,<span class="hljs-type">int</span> mode=ios::out,<span class="hljs-type">int</span> port=filebuf::openprot);<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">打开方式</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>ios::ate</code></td><td align="center">如果文件存在末尾追加</td></tr><tr><td align="center"><code>ios::trunc</code></td><td align="center">如果文件存在清除内容（默认）</td></tr><tr><td align="center"><code>ios::in</code></td><td align="center">输入能力（ifstream默认）</td></tr><tr><td align="center"><code>ios::out</code></td><td align="center">输出能力（ofstream默认）</td></tr><tr><td align="center"><code>ios::nocreate</code></td><td align="center">文件不存在返回错误</td></tr><tr><td align="center"><code>ios::noreplace</code></td><td align="center">文件存在返回错误</td></tr><tr><td align="center"><code>ios::binary</code></td><td align="center">二进制方式</td></tr></tbody></table><table><thead><tr><th align="center">保护方式</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>filebuf::openprot</code></td><td align="center">允许共享</td></tr><tr><td align="center"><code>filebuf::sh_none</code></td><td align="center">独占</td></tr><tr><td align="center"><code>filebuf::sh_read</code></td><td align="center">读共享</td></tr><tr><td align="center"><code>filebuf::sh_write</code></td><td align="center">写共享</td></tr></tbody></table><h2 id="串流类"><a href="#串流类" class="headerlink" title="串流类"></a>串流类</h2><p><code>ostrstream</code>是串输出类，<code>istrstream</code>是串输入类，在strstream.h里面定义。<code>strstream</code>是多继承子类。</p><p>也没有<code>cout</code>和<code>cin</code>这样的标准全局对象：</p><blockquote><p><code>ostrstream::ostream(char * ,int size);</code></p><p><code>istrstream::istream(char * ,int size);</code></p></blockquote><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>用<code>throw</code>语句抛出异常，<code>try</code>标记一块代码，<code>catch</code>处理异常，可有一个以上，只捕获<code>try</code>标记的代码块中抛出的异常。<code>try</code>只能有一个形参。</p><p>如果发生了异常，则只中断<code>try</code>中的代码块。<code>try</code>和<code>catch</code>必须相邻，顺序不能颠倒；<code>throw</code>和<code>catch</code>可以跨函数放置。对于一般的参数类型，<code>catch</code>的参数是严格匹配的，如果没有<code>catch</code>捕获异常，则会调用<code>abort()</code>函数。</p><p><code>catch(基类类型)</code>能够捕获<code>throw 派生类对象</code>，<code>catch(基类指针)</code>能够捕获<code>throw 派生类指针</code>，反之不可以。所以<code>catch(基类)</code>总放在<code>catch(派生类)</code>后面。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多态实验</title>
    <link href="/2024/polymorphic/"/>
    <url>/2024/polymorphic/</url>
    
    <content type="html"><![CDATA[<h1 id="组合模式的应用"><a href="#组合模式的应用" class="headerlink" title="组合模式的应用"></a>组合模式的应用</h1><p>每个公司都有总部、多个分公司、多个办事处等，为上下级同构实体关系。每个实体均有人力部、财务部、销售部等职能部门，不再有下级部门。分公司下面继续有子公司……总部需要快速了解总公司的：组织结构+实体职责展示。（两个多态函数，输出文字即可）。</p><h1 id="关于组合模式和程序的分析"><a href="#关于组合模式和程序的分析" class="headerlink" title="关于组合模式和程序的分析"></a>关于组合模式和程序的分析</h1><p>“组合模式”指的是将对象组合成树形结构以表示“<strong>部分—整体</strong>”的一种层次结构。这就需要实验人将“总公司”、“子公司”、“办事处”及其部门实体等对象抽象成为一个组合模式结构，例如：</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202405252229869.svg" alt="参考结构示意图"></p><p>在我们的模拟程序中就可以用类模拟一个子公司或总公司，其中包含子公司和办事处类的指针。而子公司类和办事处类都拥有人力部、财务部、销售部等基本部门，这就可以通过<strong>继承</strong>一个基本实体类来实现。</p><p>这样我们就可以构造出一个树结构了，类定义的代码<em>class.h</em>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>std::string Func1;<br>std::string Func2;<br>std::string Func3;<br><span class="hljs-built_in">Base</span>();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Agency</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br>std::string Func;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> tag;<br><span class="hljs-built_in">Agency</span>();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Company</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> tag;<br>std::vector &lt;Company*&gt; Branches;<br>std::vector &lt;Agency*&gt; Agencies;<br><span class="hljs-built_in">Company</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Company</span>(<span class="hljs-type">int</span> branchnum, <span class="hljs-type">int</span> agencynum, <span class="hljs-type">int</span> num);<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，类Base有一个纯虚成员函数show()，是一个抽象类，它代表着基本职能实体的信息；类Agency封装着办事处的信息，继承自类Base；类Company代表着子公司或总公司，也是继承自类Base，存储着Company指针和Agency指针，代表其衍生出来的子公司和办事处。</p><p>各个类的构造函数可以参考<em>class.cpp</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base::<span class="hljs-built_in">Base</span>()<br>&#123;<br>Func1 = <span class="hljs-string">&quot;人力部&quot;</span>;<br>Func2 = <span class="hljs-string">&quot;财务部&quot;</span>;<br>Func3 = <span class="hljs-string">&quot;销售部&quot;</span>;<br>&#125;<br>Agency::<span class="hljs-built_in">Agency</span>()<br>&#123;<br>Func = <span class="hljs-string">&quot;办事处&quot;</span>;<br>tag = <span class="hljs-number">0</span>;<br>&#125;<br>Company::<span class="hljs-built_in">Company</span>() = <span class="hljs-keyword">default</span>;<br>Company::<span class="hljs-built_in">Company</span>(<span class="hljs-type">int</span> branchnum, <span class="hljs-type">int</span> agencynum, <span class="hljs-type">int</span> num)<br>&#123;<br>tag = num;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; branchnum; i++)<br>&#123;<br>Branches.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> Company);<br>Branches[i]-&gt;tag = i + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; agencynum; i++)<br>&#123;<br>Agencies.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> Agency);<br>Agencies[i]-&gt;tag = i + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>show()函数是类中的一个<strong>虚函数</strong>，在Company类和Agency类中都对它进行了定义的覆盖，以达到多态的目的，这样，调用不同的类中的show()函数就可以做到不同的效果。例如，调用Agency中的show()，会输出它自己的基本信息和它父类Base的一些信息；调用Company中的show()，会输出它自己以及所有子公司和办事处的信息。具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Agency::show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;办事处&quot;</span> &lt;&lt; tag &lt;&lt; <span class="hljs-string">&quot;职能有：&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; Func &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; Func1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; Func2 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; Func3 &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Company::show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (tag != <span class="hljs-number">0</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;子公司&quot;</span> &lt;&lt; tag &lt;&lt; <span class="hljs-string">&quot;下属有：&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;总公司下属有：&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>std::cout &lt;&lt; Func1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; Func2 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; Func3 &lt;&lt; std::endl;<br><span class="hljs-keyword">if</span> (!Agencies.<span class="hljs-built_in">empty</span>())<br>&#123;<br>std::cout &lt;&lt; Agencies.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个办事处&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Agencies.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>Agencies[i]-&gt;<span class="hljs-built_in">show</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!Branches.<span class="hljs-built_in">empty</span>())<br>&#123;<br>std::cout &lt;&lt; Branches.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个子公司&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Branches.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>Branches[i]-&gt;<span class="hljs-built_in">show</span>();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试与实现可参考<em>main.cpp</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;class.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Company <span class="hljs-title">Com</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;<br>Com.Branches[<span class="hljs-number">2</span>]-&gt;<br>Branches.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Company</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, Com.Branches.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>Com.<span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202405252245405.png" alt="调用结果"></p><p>可以看到，我们的操作都是实现了的。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>构造函数需要放在public里面</li><li>加一个static变量观感会更好，但是要注意类内声明类外定义</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上简单的Socket通信：echo程序</title>
    <link href="/2024/socket/"/>
    <url>/2024/socket/</url>
    
    <content type="html"><![CDATA[<h3 id="关于Socket"><a href="#关于Socket" class="headerlink" title="关于Socket"></a>关于Socket</h3><p>客户端和服务器通常运行在不同的主机上，而对主机而言，网络也是一种I&#x2F;O设备。如今，几乎每个计算机系统都支持TCP&#x2F;IP协议。而与此同时，“套接字（socket）接口”是一组函数，可以与I&#x2F;O函数结合起来创建网络应用，每当调用套接字函数时，系统都会调用内核模式中的TCP&#x2F;IP函数。</p><p>对于内核而言，一个socket就是通信的一个端点；而从程序的角度来说，一个socket就是一个有相应的描述符的打开文件。internet的socket地址存放在一个类型为sockaddr_in的结构体中。而socket通信相关的函数都需要一个指向该结构的指针。</p><p>构建socket首先要将其初始化。在Windows平台上，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NOWARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br>WSADATA wsadata; <br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Socket打开失败！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;已打开Socket&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化之后，服务端和客户端就可以分别利用socket()函数创建一个socket描述符了，使之成为一个通信的端点。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SOCKET serSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>AF表示我们正在使用IPv4协议，AF_INET表明我们正在使用32位IP地址，SOCK_STREAM表示这个socket是一个端点。而socket()返回的变量只是部分打开的，不能对其进行读写操作。</p><p>之后，我们就要定义一个sockaddr_in类型的结构体，并对其中的参数进行初始化，绑定IP地址与端口，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SOCKADDR_IN addr; <br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">6000</span>);<br></code></pre></td></tr></table></figure><p>客户端可以调用connect()函数建立与服务器的连接，而服务器则利用bind()、listen()、accept()函数与客户端进行连接。在连接成功之后就可以进行通信了。</p><p>服务端主程序代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">bind</span>(serSocket, (SOCKADDR*)&amp;addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR)); <br><span class="hljs-built_in">listen</span>(serSocket, <span class="hljs-number">1024</span>); <br>SOCKADDR_IN clientsocket;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(SOCKADDR);<br>SOCKET serConn = <span class="hljs-built_in">accept</span>(serSocket, (SOCKADDR*)&amp;clientsocket, &amp;len); <br><span class="hljs-keyword">if</span> (serConn != <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与客户端链接成功&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与客户端链接失败！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">closesocket</span>(serConn);<span class="hljs-comment">//关闭</span><br><span class="hljs-built_in">WSACleanup</span>();<br></code></pre></td></tr></table></figure><p>客户端主程序代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">connect</span>(clientSocket, (SOCKADDR*)&amp;client_in, <span class="hljs-built_in">sizeof</span>(SOCKADDR)))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与服务器链接成功！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与服务器链接失败！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">closesocket</span>(clientSocket);<br><span class="hljs-built_in">WSACleanup</span>();<br></code></pre></td></tr></table></figure><p>构建好了如上socket通信的框架之后，就可以进行功能搭建了。我们可以模拟一个echo程序的功能，客户端输入一个字符串，服务端收到它，再将它原模原样地返回。</p><p>完整的客户端代码<em>client.cpp</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> sendBuf[<span class="hljs-number">1024</span>];<br><span class="hljs-type">char</span> receiveBuf[<span class="hljs-number">1024</span>];<br><span class="hljs-type">char</span> ip[<span class="hljs-number">1024</span>];<br>cout &lt;&lt; <span class="hljs-string">&quot;输入服务器ip&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; ip;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>WSADATA wsadata;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;客户端Socket已打开&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;客户端Socket打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br>SOCKET clientSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>SOCKADDR_IN client_in;<br>client_in.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(ip);<br>client_in.sin_family = AF_INET;<br>client_in.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">6000</span>);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">connect</span>(clientSocket, (SOCKADDR*)&amp;client_in, <span class="hljs-built_in">sizeof</span>(SOCKADDR)))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与服务器链接成功！&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;发出信息:&quot;</span>;<br><span class="hljs-built_in">gets_s</span>(sendBuf, <span class="hljs-number">1024</span>);<br><span class="hljs-built_in">send</span>(clientSocket, sendBuf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">recv</span>(clientSocket, receiveBuf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;收到信息：&quot;</span> &lt;&lt; receiveBuf &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与服务器链接失败！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">closesocket</span>(clientSocket);<br><span class="hljs-built_in">WSACleanup</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的服务端代码<em>server.cpp</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NOWARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> Buf[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>WSADATA wsadata;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Socket打开失败！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;已打开Socket&quot;</span> &lt;&lt; endl;<br>&#125;<br>SOCKET serSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>SOCKADDR_IN addr;<br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">6000</span>);<br><span class="hljs-built_in">bind</span>(serSocket, (SOCKADDR*)&amp;addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR));<br><span class="hljs-built_in">listen</span>(serSocket, <span class="hljs-number">1024</span>);<br>SOCKADDR_IN clientsocket;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(SOCKADDR);<br>SOCKET serConn = <span class="hljs-built_in">accept</span>(serSocket, (SOCKADDR*)&amp;clientsocket, &amp;len);<br><span class="hljs-keyword">if</span> (serConn != <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与客户端链接成功&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;服务端收到:&quot;</span> &lt;&lt; Buf &lt;&lt; endl;<br><span class="hljs-built_in">recv</span>(serConn, Buf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;服务端回复：&quot;</span> &lt;&lt; Buf &lt;&lt; endl;<br><span class="hljs-built_in">send</span>(serConn, Buf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与客户端链接失败！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">closesocket</span>(serConn);<br><span class="hljs-built_in">WSACleanup</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程图可参考：</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202405191725630.svg"></p><h3 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h3><p>如果有两个或多个客户端，就需要衍生出子线程分别为他们服务，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202405191703045.png"><br><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202405191703385.png"></p><p>不过，C++提供的thread库能够帮我们简单地实现多线程编程，其中的thread对象可以创建一个新线程执行函数，让其与主线程并行运行（执行detach()函数），再用vector容器存储它就可以很容易地达到多线程编程的效果。</p><p>我们为服务端创建的SOCKET对象serConn承担着accept客户端的任务，如果侦测到有服务端成功连接，就在vector中创建一个新线程并运行它（sockFunc()函数）。</p><p>拥有了多线程运行的<em>server_threads.cpp</em>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NOWARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockFunc</span><span class="hljs-params">(SOCKET serConn)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> Buf[<span class="hljs-number">1024</span>];<br>cout &lt;&lt; <span class="hljs-string">&quot;与客户端链接成功&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">recv</span>(serConn, Buf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;服务端收到:&quot;</span> &lt;&lt; Buf &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;服务端回复：&quot;</span> &lt;&lt; Buf &lt;&lt; endl;<br><span class="hljs-built_in">send</span>(serConn, Buf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">closesocket</span>(serConn);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>WSADATA wsadata;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Socket打开失败！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;已打开Socket&quot;</span> &lt;&lt; endl;<br>&#125;<br>SOCKET serSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>SOCKADDR_IN addr;<br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">6000</span>);<br><span class="hljs-built_in">bind</span>(serSocket, (SOCKADDR*)&amp;addr, <span class="hljs-built_in">sizeof</span>(SOCKADDR));<br><span class="hljs-built_in">listen</span>(serSocket, <span class="hljs-number">1024</span>);<br>vector&lt;thread&gt; tcp;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>SOCKADDR_IN clientsocket;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(SOCKADDR);<br>SOCKET serConn = <span class="hljs-built_in">accept</span>(serSocket, (SOCKADDR*)&amp;clientsocket, &amp;len);<br><span class="hljs-keyword">if</span> (serConn != <span class="hljs-number">-1</span>)<br>&#123;<br>tcp.<span class="hljs-built_in">emplace_back</span>(sockFunc, serConn);<br><span class="hljs-keyword">if</span> (tcp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">joinable</span>())<br>&#123;<br><span class="hljs-comment">//cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tcp.back().get_id() &lt;&lt; &quot; is joinable!&quot; &lt;&lt; endl;</span><br>tcp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">detach</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;与客户端链接失败！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">WSACleanup</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><p><a href="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202405191722416.7z">点击下载</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>我是菜鸡</p><ul><li><p><a href="https://blog.csdn.net/wu2304211/article/details/53819311">【1】</a></p></li><li><p><a href="https://www.cnblogs.com/Reyzal/p/6742553.html">【2】</a></p></li><li><p><a href="https://blog.csdn.net/qq_37245700/article/details/134718505">【3】</a></p></li><li><p><a href="https://blog.csdn.net/qq_44101612/article/details/100022786">【4】</a></p></li><li><p><a href="https://www.jb51.net/article/254190.htm#_label1">【5】</a></p></li><li><p><a href="https://www.cnblogs.com/DOMLX/p/9613861.html">【6】</a></p></li><li><p>【7】CSAPP</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可视化Dijkstra算法模拟地图导航</title>
    <link href="/2024/dijkstra/"/>
    <url>/2024/dijkstra/</url>
    
    <content type="html"><![CDATA[<p>用qt写了一个能够实现可视化Dijkstra算法模拟寻路的小程序</p><p>没有写任何关于人性化的功能，只有纯粹的算法，如果输入的时候点了cancel或者输入了错误数据会导致程序直接崩溃）</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404302115952.png" alt="示例"></p><p><a href="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404302105526.7z">下载源码</a></p><p><a href="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404302104761.7z">下载程序</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《现代物理有机化学》笔记：有机电子材料</title>
    <link href="/2022/essay1/"/>
    <url>/2022/essay1/</url>
    
    <content type="html"><![CDATA[<h3 id="17-1-1-无限-pi-体系：特别的聚乙炔"><a href="#17-1-1-无限-pi-体系：特别的聚乙炔" class="headerlink" title="17.1.1 无限$\pi$体系：特别的聚乙炔"></a>17.1.1 无限$\pi$体系：特别的聚乙炔</h3><p>首先绘制出“聚乙炔”的能级图：</p><p><img src="https://pic1.zhimg.com/80/v2-206a58e6e7864cfa3c4842feb743e224_1440w.jpg" alt="聚乙炔的能带结构"></p><p>而我们处理的策略就是将线性体系以环多烯的方式处理，因为它们的电子结构差不多，它们的能级满足以下关系：$\epsilon &#x3D;\alpha +2\cos(\frac{2\pi i}{ N})\times \beta$，其中$i$为轨道节点数目，$N$为原子总数目。例如，我们分析环戊二烯自由基（$N&#x3D;5$）：</p><p><img src="https://pic3.zhimg.com/v2-4cecf94a5adfc14d5b1a93da13b5cbe6_r.jpg" alt="环戊二烯自由基的能级图"></p><p>其中，$i&#x3D;\pm 2$时的轨道是反键轨道，其余的是成键轨道。那么，当$N\to +  \infty $时，我们就可以作出$\epsilon$关于$i$变化的图像：</p><p><img src="https://pic3.zhimg.com/80/v2-b12e5f350ca8746e3b1e701b7789fbb2_1440w.webp" alt="横轴代表节点数i，纵轴表示各能级能量"></p><p>可以看出，它类似于一个正弦曲线，最小值为$\alpha+2\beta$，最大值为$\alpha-2\beta$。</p><p>倘若我们将固体化学的概念引入这里，比如“晶胞”，即“重复单元”，然而，无限$\pi$体系中的所有$\mathrm{CH} $都是等价的，即聚乙炔的晶胞都是一个$\mathrm{CH} $，那么我们定义$a$为一个$\mathrm{CH} $的大小，和$k$($k&#x3D;\frac{2\pi i}{Na} $)由于$-\frac{N}{a} \le i\le +\frac{N}{a}$，那么$-\frac{\pi}{a} \le k\le +\frac{\pi}{a}$，将$k$代入$\epsilon$的定义式中，得到$\epsilon&#x3D;\alpha+\cos( ka )\times\beta$，则可以作出相应的图像：</p><p><img src="https://pic3.zhimg.com/80/v2-c33a766665d782c30f0e1314e50e7252_1440w.webp" alt="能级能量和$k$大小的关系，其中$k=\frac{\pi}{a}$时称作“Brillouion区边界”"></p><p>代表着能带内“相”的关系，代表着“相空间”，即$\pi$轨道相位组合的方式。$k&#x3D;0$时，所有单体的相位相同，$k&#x3D;\frac{\pi}{a} $时，所有单体的相位相反。</p><p><img src="https://pic3.zhimg.com/80/v2-e2806950cd9a483f4ce94b9c71dc43de_1440w.webp" alt="单体的相位（如果认为单体指的是两个$\mathrm{CH} $）"></p><p>$k&#x3D;0$时，所有相位相同，此时能量应最低，为$\alpha+2\beta$； 时，所有单体的相位相反，能量最高，为$\alpha-2\beta$；而π轨道（如上图中左下侧）异相组合时，能量应呈现非键轨道特性，为$\alpha$。（注意：这里原书认为单体，即重复单元为两个$\mathrm{CH} $，那么相应地，单体长度也会扩大两倍，变成 $a’$，$a’&#x3D;2a$）</p><p><img src="https://pic1.zhimg.com/80/v2-111c4155f5a7e56eba8fb6b36348ebf0_1440w.webp"></p><p>不过，不管怎么取“晶胞”，分子的电子结构都不会改变，那么理论上，聚乙炔的π轨道应当全满，$\pi^{\star}$ 轨道应当全空，其Fermi能级（$E_{F}$，和HOMO是一个意思）就在中间，能量为$\alpha$ 。但在这个模型中，能带（$\pi$ 和 $\pi^{\star}$ 轨道组成的）之间的能级差（$E_{g}$，能隙）应该为 ，所以，聚乙炔就应该是一种有机金属导体了！可惜事实真的如此吗？</p><p>更何况，真实的材料可不会是一维的，所以以上分析还是有点瑕疵。这也是Hückel理论的一个缺陷。</p><hr><h3 id="17-1-2-Peierls形变"><a href="#17-1-2-Peierls形变" class="headerlink" title="17.1.2 Peierls形变"></a>17.1.2 Peierls形变</h3><p>我们发现，在Hückel理论中，聚乙炔的能隙等于$0$，而环丁二烯也是一个类似的体系：</p><p><img src="https://pic3.zhimg.com/v2-f48b12622dcd959b9c0546b8c694758a_r.jpg" alt="正方形和矩形形式的环丁二烯的能级"></p><p>如果不谈反芳香性等等因素的话，那环丁二烯本来应该是正方形的，这没什么问题。但是它实际上处于一个矩形的构型（长键长$1.54\mathrm{Å}$，短键长$1.37\mathrm{Å}$），这就导致HOMO和LUMO裂分，从而变得更稳定——矩形的构型能量比正方形低$5-10\mathrm{kcal&#x2F;mol}$——这也可以被称作是“伪Jahn-Teller效应”。因此，环丁二烯的基态应该是单重态（上图右），而非三重态（上图左），正方形的构型其实算是两种矩形构型交替变化的一个过渡态罢了。</p><p><img src="https://pic1.zhimg.com/80/v2-2f9637e74065a834c237c46f5cdf50a0_1440w.webp" alt="&quot;Jahn-Teller效应&quot;"></p><p>类似的效应在聚乙炔中也出现了，按照我们的预期，聚乙炔的C-C键应该都是等长的——可事实却不是这样，它的键长发生了形变，变成了长短交替的结构。几何形变让它出现了能隙，$E_{g}&#x3D;1.5\mathrm{eV}$，所以实际上，聚乙炔是一种半导体，这种形变叫做Peierls形变。</p><p><img src="https://pic1.zhimg.com/v2-f9e69cc4e90775e82b73494d9f7f800c_r.jpg" alt="形变导致的聚乙炔能量变化"></p><p><img src="https://pic2.zhimg.com/80/v2-b61538d0f411c01d9aa70b4a410458a5_1440w.webp" alt="假想的聚乙炔电子结构，所有的电子都是离域的"></p><p>此时，聚乙炔的HOMO（也就是$E_{F}$）是低于$\alpha$的，确实是稳定化了。其实在多数中性、闭壳的$\pi$体系中，这种长短键交替的现象是比较常见的。苯算是一个特例，由于强$\sigma$键的束缚，它的键长的确是均一的。</p><hr><h3 id="17-1-3-掺杂"><a href="#17-1-3-掺杂" class="headerlink" title="17.1.3 掺杂"></a>17.1.3 掺杂</h3><p>在$\pi$体系共轭聚合物中，聚乙炔等等只能算是半导体，而绝缘体更是普遍的情况。所以，为了改善它们的导电性，掺杂是一个很好的办法。例如把聚合物置于氧化剂（如$\mathrm{AsF_{5}}$，$\mathrm{I_{2}}$）氛围中，让其失去电子，引入正电荷，进行p型掺杂；或是用还原剂（如金属钠，萘-钠）处理进行n型掺杂。那么我们先讨论p型掺杂。</p><p><img src="https://pic3.zhimg.com/80/v2-983c851545c6e99b4642fe06b188dc46_1440w.webp" alt="掺杂后的聚乙炔和聚对苯撑（PPP）的结构"></p><p>进行n型掺杂，引入正电荷或自由基后会产生一个部分离域的正离子，为什么是部分离域呢？</p><ul><li><p>我们知道，烯丙基自由基比乙基自由基稳定，是因为它有离域体系，然而随着离域体系越来越大，自由基应该是更稳定的，随着碳原子数的增加，例如戊二烯基自由基，肯定是比烯丙基自由基稳定的，但是它们之间能量的差值会越来越小，到最后，离域提供的稳定化能只能说是微乎其微，不足挂齿了。（可能可以用共轭饱和理论来解释）</p></li><li><p>另外，由于Peierls形变为聚合物提供了稳定化能，但是掺和进来的正离子或自由基打乱了这个节奏，离域的能量不足以补偿打乱Peierls形变抬升的能量。</p></li></ul><p>随着掺杂得越来越多，产生的部分离域的电荷和自由基（称作“极化子”）也会变得越来越多，使得电导率上升。</p><p>这样掺杂的一个结果，就是能够形成“中间能隙束缚态”，代表着电子的缺失，也可以看作空轨道的引入，单占轨道从价带中独立出去。它的另一种解释是极化子的形成消除了Peierls形变。并且，新轨道的产生使得光学跃迁成为了可能，让产生的聚合物带上了颜色。</p><p><img src="https://pic2.zhimg.com/v2-b7004a6baec99318b3f453123953fea5_r.jpg" alt="中间能隙束缚态的形成"></p><p>重度掺杂也会导致“双极化子”的形成，它可能是两个极化子复合而成的。如果极化子是自由基，则它们会复合成新键；若是电荷，库仑斥力不应该会阻碍它们的复合吗？在气相中的确是这样的，但在固相中，材料的介电系数更大，减小了库仑斥力，并且引入的阴离子，如 $\mathrm{As_{2}F_{11}^{-}}$、$\mathrm{I_{3}^{-}}$等，扩散能力较强，屏蔽了其电荷，促使双极化子产生。</p><p><img src="https://pic1.zhimg.com/80/v2-1f81bd10ba97ebeb7c563a7241b2464c_1440w.webp" alt="双极化子的产生，注意：极化子比图示的更加离域"></p><p>与金属导体不同，这些聚合物的电导率（$\sigma$，电阻率$\rho$的倒数）常常与温度反相关，这是因为极化子的移动会导致碳骨架（它们的键长、键角等）轻微地改变，这需要一定的热活化能。金属在低温时，干扰晶格中自由电子运动的振动会减少。综上，电导率与温度的关系也是判定是否为金属导体的一大标准。</p><p>以上是对于p型掺杂半导体的论述，同理，n型掺杂也是差不多的。</p><hr><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>特别感谢<a href="https://www.zhihu.com/people/lei-si-chen-48">@lesscho</a> 对本文的斧正，感恩捏！</p><hr><p>原文发表在<a href="https://zhuanlan.zhihu.com/p/659350625">知乎</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>化学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下载测试</title>
    <link href="/1970/DownloadTest/"/>
    <url>/1970/DownloadTest/</url>
    
    <content type="html"><![CDATA[<p>测试download</p><hr><p>插入Pdf<br><a href="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404301419177.pdf">测试Pdf</a></p><p>利用图床上传的图片：</p><p><img src="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404301412998.jpg" alt="测试图片"></p><p>测试压缩包1：直接链接到图床：</p><p><a href="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404301827975.zip">测试压缩包</a></p><p>测试压缩包2：用html代码写的</p><p><a href="https://cdn.jsdelivr.net/gh/Kisechan/Picture-Bed-Kisechan@master/img/202404301827975.zip" target="_blank">测试压缩包</a></p><blockquote><p>两种方法都可以实现通过图床提供的压缩包下载，但是不能将其以图片形式插入，否则不能提供下载<br><br>原理就是直接插入一个图床链接，点进去就是到图床的对应链接，进入下载环节<br><br>但是如果插入的是相对地址，<a href="https://blog.csdn.net/qq_42555291/article/details/108349294">据传</a>不能够正常下载，必须要给图床链接才能正常下载</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello!??</title>
    <link href="/1970/Hello/"/>
    <url>/1970/Hello/</url>
    
    <content type="html"><![CDATA[<h1 id="第一次测试-test"><a href="#第一次测试-test" class="headerlink" title="第一次测试 test"></a>第一次测试 test</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><p>如题，这是一个测试文章！</p><p><strong>粗体字体</strong></p><p><em>斜体字体</em></p><blockquote><p>这是引用</p></blockquote><p><a href="https://kisechan.github.io/">这是一个链接</a></p><p><img src="/./img/1.png" alt="这是一个图片&lt;br/&gt;很可爱不是吗（"></p><ul><li>列表1</li><li>列表2<ul><li>列表2.1</li><li>列表2.2</li></ul></li></ul><hr><p>分割线</p><hr><p><del>这是要被删除的文字</del></p><p><u>这行文字已被添加下划线</u></p><p><code>Hello</code> World.</p><p>这是？？？代码块</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br>cin&gt;&gt;i;<br>cout&lt;&lt;i&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是表格<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是脚注1">[1]</span></a></sup></p><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><p>测试公式：</p><p>$$ E&#x3D;mc^2 $$</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是脚注1<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
